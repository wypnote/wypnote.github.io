<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>code数学知识篇(下)</title>
      <link href="/2025/07/24/code%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%AF%87(%E4%B8%8B)/"/>
      <url>/2025/07/24/code%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%AF%87(%E4%B8%8B)/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>code数学知识篇(上)</title>
      <link href="/2025/07/16/code%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%AF%87(%E4%B8%8A)/"/>
      <url>/2025/07/16/code%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%AF%87(%E4%B8%8A)/</url>
      
        <content type="html"><![CDATA[<h2 id="质数"><a href="#质数" class="headerlink" title="质数"></a>质数</h2><h3 id="AcWing-866-试除法判定质数"><a href="#AcWing-866-试除法判定质数" class="headerlink" title="AcWing 866. 试除法判定质数"></a>AcWing 866. 试除法判定质数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_prime</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">is_prime</span>(x)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AcWing-867-分解质因数"><a href="#AcWing-867-分解质因数" class="headerlink" title="AcWing 867. 分解质因数"></a>AcWing 867. 分解质因数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i,s ++ ;</span><br><span class="line">                cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">   <span class="keyword">if</span> (x &gt; <span class="number">1</span>) cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="built_in">divide</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AcWing-868-筛质数—朴素"><a href="#AcWing-868-筛质数—朴素" class="headerlink" title="AcWing 868. 筛质数—朴素"></a>AcWing 868. 筛质数—朴素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> primes[N], cnt;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (st[i]) <span class="keyword">continue</span>;</span><br><span class="line">        primes[cnt ++ ] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + i; j &lt;= n; j += i)</span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">get_primes</span>(n);</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AcWing-868-筛质数—线性筛法"><a href="#AcWing-868-筛质数—线性筛法" class="headerlink" title="AcWing 868. 筛质数—线性筛法"></a>AcWing 868. 筛质数—线性筛法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> primes[N], cnt;  <span class="comment">// primes[] 保存质数， cnt 是质数个数</span></span><br><span class="line"><span class="type">bool</span> st[N];   <span class="comment">// st[i] = true  表示 i 不是质数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) primes[cnt ++ ] = i;  <span class="comment">// 如果 i 未被标记， i 是质数</span></span><br><span class="line">        <span class="comment">// i是质数就筛掉i与primes中所有质数的乘积；i是非质数筛掉i与primes中所有&lt;=最小质因子的乘积</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;  <span class="comment">// 标记 primes[j] * i 为合数</span></span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;  <span class="comment">// i 含有 primes[j] 这个质因子， 终止</span></span><br><span class="line">            <span class="comment">// 如果i % primes[j] == 0   </span></span><br><span class="line">            <span class="comment">//那么primes[j]一定是primes[j] * i的最小质因子</span></span><br><span class="line">            <span class="comment">// 如果i % primes[j] != 0   </span></span><br><span class="line">            <span class="comment">// 那么primes[j]一定小于i的所有质因子 primes[j]也一定是primes[j] * i的最小质因子</span></span><br><span class="line">           </span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            举个例子i=12， 首先 st[24] = true；</span></span><br><span class="line"><span class="comment">如果没有i%primes[j]的判断，那么会执行st[36] = true;</span></span><br><span class="line"><span class="comment">当i等于18的时候 st[i * primes[0]] = true;  这就是标记两次</span></span><br><span class="line"><span class="comment">思想就是，每次都用最小质数来标记，这也就不会出现重复标记的情况</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">get_primes</span>(n);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 第一次外层循环：i = 2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- primes[] 为空，st[] 所有元素为 `false`。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">标记：st[2 * 2] = st[4] = true;`</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 标记 4 为合数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">检查：if (2 % primes[0] == 0) break;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 2 % 2 == 0，跳出内层循环，表示 2 是最小质因子，后续无需检查更大的质数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">此时：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- primes[] = &#123;2&#125;</span></span><br><span class="line"><span class="comment">- st[] = &#123;false, false, false, true, false, false, false, false, false, false, false&#125;</span></span><br><span class="line"><span class="comment">- 合数 4 被标记为合数，跳出内层循环。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2. 第二次外层循环：i = 3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">标记：st[3 * 2] = st[6] = true;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 标记 6 为合数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">检查：if (3 % primes[0] == 0) break;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 3 % 2 != 0，继续执行下一个质数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">标记：st[3 * 3] = st[9] = true;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 标记 9 为合数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">检查：if (3 % primes[1] == 0) break;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 3 % 3 == 0，跳出内层循环，表示 3 是 9 的最小质因子。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">此时：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- primes[] = &#123;2, 3&#125;</span></span><br><span class="line"><span class="comment">- st[] = &#123;false, false, false, true, false, false, true, false, false, true, false&#125;</span></span><br><span class="line"><span class="comment">- 合数 6 和 9 被标记，跳出内层循环。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3. 第三次外层循环：i = 4</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 4 已经被标记为合数了，st[4] == true，跳过。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4. 第四次外层循环：i = 5</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">标记：st[5 * 2] = st[10] = true;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 标记 10 为合数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">检查：if (5 % primes[0] == 0) break;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 5 % 2 != 0，继续执行下一个质数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">标记：st[5 * 3] = st[15]，但 15 超出了范围。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">此时：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- primes[] = &#123;2, 3, 5&#125;</span></span><br><span class="line"><span class="comment">- st[] = &#123;false, false, false, true, false, false, true, false, false, true, true&#125;</span></span><br><span class="line"><span class="comment">- 合数 10 被标记。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><h3 id="AcWing-875-快速幂"><a href="#AcWing-875-快速幂" class="headerlink" title="AcWing 875. 快速幂"></a>AcWing 875. 快速幂</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) res = (LL)res * a % p;  <span class="comment">// 这里有个定理</span></span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a = (LL)a * a % p;  <span class="comment">// 反复平方</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, p;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;p);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, <span class="built_in">qmi</span>(a, b, p));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AcWing-876-快速幂求逆元"><a href="#AcWing-876-快速幂求逆元" class="headerlink" title="AcWing 876. 快速幂求逆元"></a>AcWing 876. 快速幂求逆元</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a / b = a * x(mod p)     a / b = a * b ^ -1    p是质数</span></span><br><span class="line"><span class="comment">// b * x = 1 (mod p)   求b * b ^ -1 = 1(mod p)</span></span><br><span class="line"><span class="comment">// 那么  x叫做  b 的 乘法逆元</span></span><br><span class="line"><span class="comment">// 费马定理 b^(p - 1) = 1(mod p)   b * b^(p - 2) = 1(mod p);这时候直接求b^(p - 2)即可</span></span><br><span class="line"><span class="comment">// 那么 b ^ -1 = b^(p - 2)     b * b^(p - 2) = 1(mod p) ---&gt;b ^ -1 = b^(p - 2)(mod p)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) res = res * a % p;</span><br><span class="line">        a = a * (LL)a % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, p;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;p);</span><br><span class="line">        <span class="keyword">if</span> (a % p == <span class="number">0</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">qmi</span>(a, p - <span class="number">2</span>, p));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h2><h3 id="AcWing-877-扩展欧几里得算法"><a href="#AcWing-877-扩展欧几里得算法" class="headerlink" title="AcWing 877. 扩展欧几里得算法"></a>AcWing 877. 扩展欧几里得算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据费马定理，任意正整数a, b都存在x, y使得ax + by = gcd(a, b)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b)  <span class="comment">// 如果b = 0, 则gcd(a, b) = 1 * a + 0 * b</span></span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> d = <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">    y -= a / b * x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        <span class="built_in">exgcd</span>(a, b, x, y);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>证明</strong></p><p><img src="https://bu.dusays.com/2025/07/24/6881a83f23eb9.png"></p><h3 id="AcWing-878-线性同余方程"><a href="#AcWing-878-线性同余方程" class="headerlink" title="AcWing 878. 线性同余方程"></a>AcWing 878. 线性同余方程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a * x ≡ b(mod m)   这个公式的意思(a * x) % m = b</span><br><span class="line"></span><br><span class="line">a * x = m * y + b   ---&gt;  a * x - m * y = b</span><br><span class="line">令 y&#x27; = -y    ----&gt; a * x + m * y&#x27; = b</span><br><span class="line">这里就是扩展欧几里得算法一样了 ，两边同时乘以 d / b 倍得到</span><br><span class="line">a * x * d / b + m * y&#x27; * d / b = d</span><br><span class="line">令 x0 = x * d / b， y0</span><br><span class="line">后面x ≡ x0 * (b / d) (mod m)</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> d = <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">    y -= a / b * x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;m);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        <span class="type">int</span> d = <span class="built_in">exgcd</span>(a, m, x, y);</span><br><span class="line">        <span class="keyword">if</span> (b % d) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (LL)b / d * x % m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码调试</title>
      <link href="/2025/05/30/%E4%BB%A3%E7%A0%81%E8%B0%83%E8%AF%95/"/>
      <url>/2025/05/30/%E4%BB%A3%E7%A0%81%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p><strong>一些代码调试的经验</strong></p><p>如果不清楚具体是哪里的问题，系统的库函数出问题了 ，那么先看调用堆栈</p><p>如果爆了内存泄露，那么首先搜下项目中的new</p><p>全局 类的静态变量初始化  先于 main函数，所以我们的单例就利用这一点，因为没有多线程问题，不存在其它调用的问题。</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 调试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>code排序篇</title>
      <link href="/2025/05/19/code%E6%8E%92%E5%BA%8F%E7%AF%87/"/>
      <url>/2025/05/19/code%E6%8E%92%E5%BA%8F%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h3 id="力扣912-排序数组"><a href="#力扣912-排序数组" class="headerlink" title="力扣912. 排序数组"></a>力扣912. 排序数组</h3><p>给你一个整数数组 <code>nums</code>，请你将该数组升序排列。</p><p>你必须在 <strong>不使用任何内置函数</strong> 的情况下解决问题，时间复杂度为 <code>O(nlog(n))</code>，并且空间复杂度尽可能小。</p><h4 id="快速排序和归并排序"><a href="#快速排序和归并排序" class="headerlink" title="快速排序和归并排序"></a>快速排序和归并排序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// qsort(nums, 0, nums.size()- 1);</span></span><br><span class="line">        <span class="comment">// merge_sort(nums, 0, nums.size()- 1);</span></span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">qsort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; q, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> x = q[(l + r) &gt;&gt; <span class="number">1</span>], i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">do</span> i ++ ; <span class="keyword">while</span>(q[i] &lt; x);</span><br><span class="line">            <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> t = q[i];</span><br><span class="line">                q[i] = q[j];</span><br><span class="line">                q[j] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">qsort</span>(q, l, j);</span><br><span class="line">        <span class="built_in">qsort</span>(q, j + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; q, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">merge_sort</span>(q, l, mid), <span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tmp</span><span class="params">(r - l + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">            <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">            <span class="keyword">else</span> tmp[k ++ ] = q[j ++ ];</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];</span><br><span class="line">       <span class="comment">// 每次递归，tmp都是从0开始的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = l, j = <span class="number">0</span>; i &lt;= r; i ++ , j ++ ) q[i] = tmp[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="堆排序-大根堆和小根堆"><a href="#堆排序-大根堆和小根堆" class="headerlink" title="堆排序(大根堆和小根堆)"></a>堆排序(大根堆和小根堆)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 为了方便使用 1-based 索引，在前面插入一个无用的数</span></span><br><span class="line">    nums.<span class="built_in">insert</span>(nums.<span class="built_in">begin</span>(), <span class="number">-1</span>);</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建堆（小根堆）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span>; i; i--) <span class="built_in">down</span>(nums, i, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt; <span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(nums[<span class="number">1</span>], nums[i]);</span><br><span class="line">        <span class="built_in">down</span>(nums, <span class="number">1</span>, i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 去掉哨兵元素（还原为 0-based 数组）</span></span><br><span class="line">    nums.<span class="built_in">erase</span>(nums.<span class="built_in">begin</span>());</span><br><span class="line">    <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> u, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> &lt;= size &amp;&amp; nums[u * <span class="number">2</span>] &lt; nums[t]) </span><br><span class="line">        t = u * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> + <span class="number">1</span> &lt;= size  &amp;&amp; nums[u * <span class="number">2</span> + <span class="number">1</span>] &lt; nums[t]) </span><br><span class="line">        t = u * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u != t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(nums[t], nums[u]);</span><br><span class="line">        <span class="built_in">down</span>(nums,t,size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>🧠需要注意一点就是，算法模板是从小到大输出最小的数，但整个的堆并不是有序的，所以需要加上下面的这段代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt; <span class="number">1</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">swap</span>(nums[<span class="number">1</span>], nums[i]);</span><br><span class="line">    <span class="built_in">down</span>(nums, <span class="number">1</span>, i - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>✅最好的方法还是使用大根堆来实现升序排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    nums.<span class="built_in">insert</span>(nums.<span class="built_in">begin</span>(), <span class="number">-1</span>);   <span class="comment">// 下标从1开始</span></span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 建立大根堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span>; i; i -- ) <span class="built_in">down</span>(nums, i, n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt; <span class="number">1</span>; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(nums[<span class="number">1</span>], nums[i]);</span><br><span class="line">        <span class="built_in">up</span>(nums, <span class="number">1</span>, i - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">    num.<span class="built_in">erase</span>(nums.<span class="built_in">begin</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> u, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> &lt;= size &amp;&amp; nums[u * <span class="number">2</span>] &gt; nums[t]) t = u * <span class="number">2</span>;    </span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> + <span class="number">1</span> &lt;= size &amp;&amp; nums[u * <span class="number">2</span> + <span class="number">1</span>] &gt; nums[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (u != t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(nums[u], nums[t]);</span><br><span class="line">        <span class="built_in">down</span>(nums, t, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里忒一些容器的知识</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;数据类型&gt; 变量名;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; s&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(<span class="number">5</span>)</span></span>;  <span class="comment">// 设置了5个大小的容器</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(<span class="number">5</span>,<span class="number">100</span>)</span></span>;  <span class="comment">// 这个容器拥有五个元素，每个元素的初始值为100</span></span><br></pre></td></tr></table></figure><p>容器的几个新用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">s.<span class="built_in">push_back</span>(值);  <span class="comment">//将值添加到容器末尾</span></span><br><span class="line">s.<span class="built_in">pop_back</span>();  <span class="comment">//将末尾的值删除掉</span></span><br><span class="line">s.<span class="built_in">insert</span>(s.<span class="built_in">begin</span>()<span class="number">+2</span>, <span class="number">2</span>); <span class="comment">// 在指定位置插入元素</span></span><br><span class="line">s.<span class="built_in">assign</span>(<span class="number">10</span>,<span class="number">100</span>); <span class="comment">//将s重新初始化为拥有10个元素  每个元素位100的容器</span></span><br><span class="line">s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>() + <span class="number">2</span>);   <span class="comment">// 删除指定位置的元素</span></span><br><span class="line">s.<span class="built_in">clear</span>(); <span class="comment">// 将容器清空</span></span><br><span class="line">s.<span class="built_in">empty</span>(); <span class="comment">//看看是不是空的</span></span><br></pre></td></tr></table></figure><p>容器比数组更灵活，排序的时候可以当做数组来操作！！！</p><h3 id="力扣56-合并区间"><a href="#力扣56-合并区间" class="headerlink" title="力扣56. 合并区间"></a>力扣56. 合并区间</h3><p><strong>ACM模式</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;PII&gt; &amp;segs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;PII&gt; res;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(segs.<span class="built_in">begin</span>(), segs.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> st = <span class="number">-2e9</span>, ed = <span class="number">-2e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> seg : segs)</span><br><span class="line">        <span class="keyword">if</span>(ed &lt; seg.first)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (st!=<span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);</span><br><span class="line">            st = seg.first, ed = seg.second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> ed = <span class="built_in">max</span>(ed, seg.second);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);</span><br><span class="line">    </span><br><span class="line">    segs = res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    </span><br><span class="line">    vector&lt;PII&gt; segs;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        segs.<span class="built_in">push_back</span>(&#123;l, r&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">merge</span>(segs);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; segs.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>核心代码模式</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此题全为非负数，所以st  ed   设置为-1即可</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> st = <span class="number">-1</span>, ed = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; intervals.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            <span class="keyword">if</span>(ed &lt; intervals[i][<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(st != <span class="number">-1</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);</span><br><span class="line">                st = intervals[i][<span class="number">0</span>], ed = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> ed = <span class="built_in">max</span>(ed, intervals[i][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(st != <span class="number">-1</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="力扣148-排序链表"><a href="#力扣148-排序链表" class="headerlink" title="力扣148. 排序链表"></a>力扣148. 排序链表</h3><p>方案一：开一个数组，把链表的值复制到数组里面进行排序，排序完成后再把值复制到链表里面</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> head;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">        <span class="keyword">auto</span> p = head;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            a.<span class="built_in">push_back</span>(p-&gt;val);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">        <span class="comment">// sort(a.begin(), a.end());</span></span><br><span class="line">        <span class="built_in">qsort</span>(a, <span class="number">0</span>, a.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">auto</span> q = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;c : a)&#123;</span><br><span class="line">            q-&gt;val = c;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> q;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">qsort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;a, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = a[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (a[i] &lt; x);</span><br><span class="line">            <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (a[j] &gt; x);</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> t = a[i];</span><br><span class="line">                a[i] = a[j];</span><br><span class="line">                a[j] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">qsort</span>(a, l, j);</span><br><span class="line">        <span class="built_in">qsort</span>(a, j + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 使用自己写的快排，效率提升了 10% 以上</span></span><br></pre></td></tr></table></figure><h3 id="力扣179-最大数（仅仅排序解决不了）"><a href="#力扣179-最大数（仅仅排序解决不了）" class="headerlink" title="力扣179. 最大数（仅仅排序解决不了）"></a>力扣179. 最大数（仅仅排序解决不了）</h3><p>现在能想到的就是 如果最高位不同，那么根据最高位进行排序，如果最高位相同则比较下一位，依次类推</p>]]></content>
      
      
      <categories>
          
          <category> codetop </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>远程桌面控制（二）</title>
      <link href="/2025/05/05/%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E6%8E%A7%E5%88%B6%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2025/05/05/%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E6%8E%A7%E5%88%B6%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h4 id="远程桌面显示功能与数据接收开发"><a href="#远程桌面显示功能与数据接收开发" class="headerlink" title="远程桌面显示功能与数据接收开发"></a>远程桌面显示功能与数据接收开发</h4><p>更新  —  定时器</p><p>数据  —  线程</p><p>显示  —  功能函数</p><ol><li>搞清楚干什么？  </li><li>逐步实现（不断细化）</li></ol><p>显示   m_picture    DC-&gt;CImage</p><p>改bug   从上往下调整   </p><p>设计   实现    日志</p>]]></content>
      
      
      <categories>
          
          <category> 远控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>远程桌面控制（一）精简版</title>
      <link href="/2025/04/07/%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E6%8E%A7%E5%88%B6%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2025/04/07/%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E6%8E%A7%E5%88%B6%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="单例模式是怎么实现的"><a href="#单例模式是怎么实现的" class="headerlink" title="单例模式是怎么实现的"></a>单例模式是怎么实现的</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CServerSocket</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> CServerSocket* m_instance;</span><br><span class="line">    <span class="type">static</span> CHelper m_helper; <span class="comment">// 辅助类，确保构造和析构</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> CServerSocket* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!m_instance) m_instance = <span class="keyword">new</span> <span class="built_in">CServerSocket</span>();</span><br><span class="line">        <span class="keyword">return</span> m_instance;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">CServerSocket</span>() &#123; ... &#125; <span class="comment">// 私有构造</span></span><br><span class="line">    ~<span class="built_in">CServerSocket</span>() &#123; ... &#125; <span class="comment">// 私有析构</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">CHelper</span> &#123; <span class="comment">// RAII 管理单例生命周期</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">CHelper</span>() &#123; CServerSocket::<span class="built_in">getInstance</span>(); &#125;</span><br><span class="line">        ~<span class="built_in">CHelper</span>() &#123; CServerSocket::<span class="built_in">releaseInstance</span>(); &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>设计思想</strong>：</p><ul><li><strong>禁止用户直接构造</strong>，必须通过 <code>getInstance()</code> 获取唯一对象。</li><li><code>CHelper</code> 辅助类：<ul><li>构造时自动创建 <code>CServerSocket</code> 单例。</li><li>析构时自动释放，防止内存泄漏。</li></ul></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th><strong>模块</strong></th><th><strong>核心功能</strong></th></tr></thead><tbody><tr><td><strong><code>CPacket</code></strong></td><td>协议封装，提供 <strong>打包&#x2F;解包</strong> 能力</td></tr><tr><td><strong><code>CServerSocket</code></strong></td><td>服务器核心，<strong>单例管理</strong>、<strong>收发数据</strong></td></tr><tr><td><strong>单例模式</strong></td><td>确保全局唯一服务器实例</td></tr><tr><td><strong>字节对齐 (<code>#pragma pack</code>)</strong></td><td>保证数据包严格对齐，避免解析错误</td></tr></tbody></table><p><strong>适用场景</strong>：</p><ul><li>小型客户端-服务器通信（如文件传输、远程控制等）。</li><li>可扩展性较强，<code>sCmd</code> 可用于扩展不同业务逻辑。</li></ul><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CServerSocket* CServerSocket::m_instance = <span class="literal">NULL</span>;  <span class="comment">// 静态成员初始化</span></span><br><span class="line">CServerSocket::CHelper CServerSocket::m_helper;   <span class="comment">// RAII辅助对象</span></span><br><span class="line">CServerSocket* pserver = CServerSocket::<span class="built_in">getInstance</span>(); <span class="comment">// 全局访问点</span></span><br></pre></td></tr></table></figure><h4 id="设计模式解析"><a href="#设计模式解析" class="headerlink" title="设计模式解析"></a>设计模式解析</h4><ol><li><p><strong>单例控制</strong></p><ul><li><code>m_instance</code> 作为静态指针，保证全进程唯一实例</li><li>通过 <code>getInstance()</code> 获取唯一实例，首次调用时构造对象</li></ul></li><li><p><strong>RAII</strong>助手类 (<code>CHelper</code>)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CHelper</span> &#123;<span class="keyword">public</span>:    <span class="built_in">CHelper</span>() &#123; CServerSocket::<span class="built_in">getInstance</span>(); &#125;  <span class="comment">// 构造时触发单例创建    ~CHelper() &#123; CServerSocket::releaseInstance(); &#125; // 析构时释放单例&#125;;</span></span><br></pre></td></tr></table></figure><ul><li><strong>构造阶段</strong>：程序启动时，全局 <code>m_helper</code> 的构造自动触发单例创建</li><li><strong>析构阶段</strong>：程序退出时，自动调用 <code>releaseInstance()</code> 释放资源</li></ul></li><li><p><strong>全局访问点</strong></p><ul><li><p><code>pserver</code> 提供全局统一访问入口</p></li><li><p>使用示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pserver-&gt;<span class="built_in">InitSocket</span>();  <span class="comment">// 任何地方都可直接使用</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><p><img src="https://bu.dusays.com/2025/04/07/67f3df51097fb.png"></p><h3 id="CPacket-打包构造函数"><a href="#CPacket-打包构造函数" class="headerlink" title="CPacket 打包构造函数"></a><code>CPacket</code> 打包构造函数</h3><h4 id="构造函数原型"><a href="#构造函数原型" class="headerlink" title="构造函数原型"></a>构造函数原型</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CPacket::<span class="built_in">CPacket</span>(WORD nCmd, <span class="type">const</span> BYTE* pData, <span class="type">size_t</span> nSize) </span><br></pre></td></tr></table></figure><h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><table><thead><tr><th>参数</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>nCmd</code></td><td><code>WORD</code></td><td>协议命令字（2字节）</td></tr><tr><td><code>pData</code></td><td><code>const BYTE*</code></td><td>负载数据指针</td></tr><tr><td><code>nSize</code></td><td><code>size_t</code></td><td>负载数据长度</td></tr></tbody></table><h2 id="主程序"><a href="#主程序" class="headerlink" title="主程序"></a>主程序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RemoveCtrl.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;framework.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;RemoveCtrl.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ServerSocket.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;direct.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> new DEBUG_NEW</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">//#pragma comment(linker, &quot;/subsystem:windows /entry:WinMainCRTStartup&quot; )</span></span><br><span class="line"><span class="comment">//#pragma comment(linker, &quot;/subsystem:windows /entry:mainCRTStartup&quot; )</span></span><br><span class="line"><span class="comment">//#pragma comment(linker, &quot;/subsystem:console /entry:WinMainCRTStartup&quot; )</span></span><br><span class="line"><span class="comment">//#pragma comment(linker, &quot;/subsystem:console /entry:mainCRTStartup&quot; )</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 唯一的应用程序对象</span></span><br><span class="line"></span><br><span class="line">CWinApp theApp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将给定的二进制数据以十六进制格式打印出来，并将输出发送到调试器（通过OutputDebugStringA）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dump</span><span class="params">(BYTE* pData, <span class="type">size_t</span> nSize)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    std::string strOut;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; nSize; i++) &#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">8</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; (i % <span class="number">16</span> == <span class="number">0</span>)) strOut += <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="built_in">snprintf</span>(buf, <span class="built_in">sizeof</span>(buf), <span class="string">&quot;%02X &quot;</span>, pData[i] &amp; <span class="number">0xFF</span>);</span><br><span class="line">        strOut += buf;</span><br><span class="line">    &#125;</span><br><span class="line">    strOut += <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="built_in">OutputDebugStringA</span>(strOut.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MakeDriverInfo</span><span class="params">()</span> </span>&#123; <span class="comment">// 1 =&gt; A   2 =&gt; B  3 =&gt; C</span></span><br><span class="line">    std::string result;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">26</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//查看每个驱动器是否存在（通过_chdrive函数）</span></span><br><span class="line">        <span class="keyword">if</span> (_chdrive(i) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//将存在的驱动字母（如A、B、C）拼接成一个字符串，用逗号分隔。</span></span><br><span class="line">            <span class="keyword">if</span> (result.<span class="built_in">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">result += <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">            result += <span class="string">&#x27;A&#x27;</span> + i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后调用 CServerSocket::getInstance()-&gt;Send(CPacket()) 发送数据包。</span></span><br><span class="line">    <span class="comment">//CServerSocket::getInstance()-&gt;Send(CPacket(1,(BYTE*)result.c_str(),result.size()));</span></span><br><span class="line">    <span class="function">CPacket <span class="title">pack</span><span class="params">(<span class="number">1</span>, (BYTE*)result.c_str(), result.size())</span></span>;</span><br><span class="line">    <span class="built_in">Dump</span>((BYTE*)pack.<span class="built_in">Data</span>(), pack.<span class="built_in">Size</span>());</span><br><span class="line"><span class="comment">//CServerSocket::getInstance()-&gt;Send(pack);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;RemoteCtrl.h&quot;</span></span></span><br><span class="line"><span class="comment">/*结构体和类十分相似  区别是结构体默认是public   类默认是private*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">file_info</span>&#123;</span><br><span class="line">    <span class="built_in">file_info</span>() &#123;</span><br><span class="line">        IsInvalid = <span class="number">0</span>;</span><br><span class="line">        IsDirectory = <span class="number">-1</span>;</span><br><span class="line">        HasNext = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">memset</span>(szFileName, <span class="number">0</span>, <span class="built_in">sizeof</span>(szFileName));</span><br><span class="line">    &#125;</span><br><span class="line">    BOOL IsInvalid; <span class="comment">// 是否有效</span></span><br><span class="line">    BOOL HasNext; <span class="comment">// 是否还有后续    0   否  1 是</span></span><br><span class="line">    <span class="type">char</span> szFileName[<span class="number">256</span>]; <span class="comment">// 文件名 </span></span><br><span class="line">    BOOL IsDirectory;  <span class="comment">// 是否为目录  0 否 1  是 </span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;FILEINFO, *PFILEINFO;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> nRetCode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    HMODULE hModule = ::<span class="built_in">GetModuleHandle</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hModule != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 初始化 MFC 并在失败时显示错误  </span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">AfxWinInit</span>(hModule, <span class="literal">nullptr</span>, ::<span class="built_in">GetCommandLine</span>(), <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> 在此处为应用程序的行为编写代码。</span></span><br><span class="line">            <span class="built_in">wprintf</span>(<span class="string">L&quot;错误: MFC 初始化失败\n&quot;</span>);</span><br><span class="line">            nRetCode = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 套接字初始化</span></span><br><span class="line">       </span><br><span class="line">            <span class="comment">// 观察文件</span></span><br><span class="line">            <span class="type">int</span> nCmd = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">switch</span> (nCmd)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// 查看磁盘分区</span></span><br><span class="line">                <span class="built_in">MakeDriverInfo</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="built_in">MakeDirectoryInfo</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 更改错误代码以符合需要</span></span><br><span class="line">        <span class="built_in">wprintf</span>(<span class="string">L&quot;错误: GetModuleHandle 失败\n&quot;</span>);</span><br><span class="line">        nRetCode = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nRetCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 木马远控 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>远程桌面控制（一）</title>
      <link href="/2025/03/15/%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E6%8E%A7%E5%88%B6%EF%BC%88%E4%B8%80%EF%BC%89%E7%B2%BE%E7%AE%80%E7%89%88/"/>
      <url>/2025/03/15/%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E6%8E%A7%E5%88%B6%EF%BC%88%E4%B8%80%EF%BC%89%E7%B2%BE%E7%AE%80%E7%89%88/</url>
      
        <content type="html"><![CDATA[<p>记录的笔记比较杂乱，把自己感觉重要的内容记录在这里了</p><br><br><h3 id="提交和推送"><a href="#提交和推送" class="headerlink" title="提交和推送"></a>提交和推送</h3><p>提交—&gt;存放</p><p>推送   就是把存的东西放到服务器上面</p><h3 id="分支切换"><a href="#分支切换" class="headerlink" title="分支切换"></a>分支切换</h3><p>git一般有很多分支，我们clone到本地的时候一般都是master分支，那么如何切换到其他分支呢？主要命令如下：</p><p><strong>1、查看远程分支</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -a</span></span><br></pre></td></tr></table></figure><p>可以看到，我们现在在什么分支下面。</p><p><strong>2、查看本地分支</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br></pre></td></tr></table></figure><p><strong>3、切换分支</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b v0.9rc1 origin/v0.9rc1</span><br></pre></td></tr></table></figure><p>个人感觉，分支的作用就是保存代码版本，几个版本就创建几个分支，所有的分支都先提交存放，最后，在存放的代码版本中选择最终的代码进行推送，放到服务器上面。</p><br><h3 id="远程网络编程"><a href="#远程网络编程" class="headerlink" title="远程网络编程"></a>远程网络编程</h3><p>使用全局变量，在<code>main</code>函数之前初始化，在<code>main</code>函数之后释放资源</p><p> <strong>单例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">单例模式是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例类的特殊类。通过单例模式可以保证系统中一个类只有一个实例而且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源。如果希望在系统中某个类的对象只能存在一个，单例模式是最好的解决方案。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对于系统中的某些类来说，只有一个实例很重要，例如，一个系统中可以存在多个打印任务，但是只能有一个正在工作的任务；一个系统只能有一个窗口管理器或文件系统；一个系统只能有一个计时工具或ID(序号)生成器。如在Windows中就只能打开一个任务管理器。如果不使用机制对窗口对象进行唯一化，将弹出多个窗口，如果这些窗口显示的内容完全一致，则是重复对象，浪费内存资源；如果这些窗口显示的内容不一致，则意味着在某一瞬间系统有多个状态，与实际不符，也会给用户带来误解，不知道哪一个才是真实的状态。因此有时确保系统中某个对象的唯一性即一个类只能有一个实例非常重要。</span><br><span class="line">如何保证一个类只有一个实例并且这个实例易于被访问呢？定义一个全局变量可以确保对象随时都可以被访问，但不能防止我们实例化多个对象。一个更好的解决办法是让类自身负责保存它的唯一实例。这个类可以保证没有其他实例被创建，并且它可以提供一个访问该实例的方法。这就是单例模式的模式动机。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">【优点】</span><br><span class="line">一、实例控制</span><br><span class="line">单例模式会阻止其他对象实例化其自己的单例对象的副本，从而确保所有对象都访问唯一实例。</span><br><span class="line">二、灵活性</span><br><span class="line">因为类控制了实例化过程，所以类可以灵活更改实例化过程。</span><br><span class="line">【缺点】</span><br><span class="line">一、开销</span><br><span class="line">虽然数量很少，但如果每次对象请求引用时都要检查是否存在类的实例，将仍然需要一些开销。可以通过使用静态初始化解决此问题。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">单例模式的简单理解</span><br><span class="line">1 单例模式 只允许创建一个对象，因此节省内存，加快对象访问速度，因此对象需要被公用的场合适合使用，如多个模块使用同一个数据源连接对象等等</span><br><span class="line">2 单例的缺点 就是不适用于变化的对象，如果同一类型的对象总是要在不同的用例场景发生变化，单例就会引起数据的错误，不能保存彼此的状态。</span><br><span class="line">用单例模式，就是在适用其优点的状态下使用</span><br></pre></td></tr></table></figure><br><br><p>一些设置，免得每次都弹出窗口</p><p>子系统改成窗口Windows</p><p>链接器 入口点  -&gt;mainCRTStarttup</p><p>不会设置那就添加代码，对下面的代码进行排列组合</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#pragma comment(linker, &quot;/subsystem:windows /entry:WinMainCRTStartup&quot; )</span><br><span class="line">#pragma comment(linker, &quot;/subsystem:windows /entry:mainCRTStartup&quot; )</span><br><span class="line">#pragma comment(linker, &quot;/subsystem:console /entry:WinMainCRTStartup&quot; )</span><br><span class="line">#pragma comment(linker, &quot;/subsystem:console /entry:mainCRTStartup&quot; )</span><br></pre></td></tr></table></figure><br><h3 id="包的设计与实现"><a href="#包的设计与实现" class="headerlink" title="包的设计与实现"></a>包的设计与实现</h3><h4 id="包的结构"><a href="#包的结构" class="headerlink" title="包的结构"></a>包的结构</h4><p>本部分结合代码来介绍包的结构，先给出这部分的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CPacket</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">CPacket</span>():<span class="built_in">sHead</span>(<span class="number">0</span>), <span class="built_in">nLength</span>(<span class="number">0</span>), <span class="built_in">sCmd</span>(<span class="number">0</span>), <span class="built_in">sSum</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"><span class="built_in">CPacket</span>(<span class="type">const</span> CPacket&amp; pack) &#123;</span><br><span class="line">sHead = pack.sHead;</span><br><span class="line">nLength = pack.nLength;</span><br><span class="line">sCmd = pack.sCmd;</span><br><span class="line">strData = pack.strData;</span><br><span class="line">sSum = pack.sSum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">CPacket</span>(<span class="type">const</span> BYTE* pData, <span class="type">size_t</span>&amp; nSize) &#123;</span><br><span class="line"><span class="type">size_t</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; i &lt; nSize; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (*(WORD*)(pData + i) == <span class="number">0xFEFF</span>) &#123;</span><br><span class="line">sHead = *(WORD*)(pData + i);</span><br><span class="line">i += <span class="number">2</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i + <span class="number">4</span> + <span class="number">2</span> + <span class="number">2</span> &gt; nSize) &#123; <span class="comment">// 包数据可能不全，或者包头未能全部接收到</span></span><br><span class="line">nSize = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">nLength = *(DWORD*)(pData + i); i += <span class="number">4</span>;</span><br><span class="line"><span class="keyword">if</span> (nLength + i &gt; nSize) &#123;<span class="comment">// 包没有完全接收，就返回，解析失败。</span></span><br><span class="line">nSize = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">sCmd = *(WORD*)(pData + i); i += <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (nLength &gt; <span class="number">4</span>) &#123;</span><br><span class="line">strData.<span class="built_in">resize</span>(nLength - <span class="number">2</span> - <span class="number">2</span>);</span><br><span class="line"><span class="built_in">memcpy</span>((<span class="type">void</span>*)strData.<span class="built_in">c_str</span>(), pData + i, nLength - <span class="number">4</span>);</span><br><span class="line">i += nLength - <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line">sSum = *(WORD*)(pData + i); i += <span class="number">2</span>;</span><br><span class="line">WORD sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; strData.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">sum += <span class="built_in">BYTE</span>(strData[i]) &amp; <span class="number">0xFF</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (sum == sSum) &#123;</span><br><span class="line">nSize = i;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">nSize = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">CPacket</span>()&#123;&#125;</span><br><span class="line">CPacket&amp; <span class="keyword">operator</span>=(<span class="type">const</span> CPacket&amp; pack) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == &amp;pack)&#123;</span><br><span class="line">sHead = pack.sHead;</span><br><span class="line">nLength = pack.nLength;</span><br><span class="line">sCmd = pack.sCmd;</span><br><span class="line">sSum = pack.sSum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">WORD sHead;  <span class="comment">// 固定位FE  FF</span></span><br><span class="line">WORD sCmd;  <span class="comment">// 控制命令</span></span><br><span class="line">DWORD nLength; <span class="comment">// 包长度（从控制命令开始，到和校验结束）</span></span><br><span class="line">std::string strData;  <span class="comment">// 包数据</span></span><br><span class="line">WORD sSum; <span class="comment">// 和校验</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一个<strong>包</strong>含了<strong>包头</strong>、<strong>包长度</strong>、<strong>控制命令</strong>、<strong>包数据</strong>和<strong>校验和</strong>等字段。包中的内容也是按照这个顺序来的。</p><table><thead><tr><th>字段名</th><th>数据类型</th><th>描述</th></tr></thead><tbody><tr><td><code>sHead</code></td><td><code>WORD</code></td><td><strong>包头标识</strong>，固定为<code>0xFEFF</code>，用于标识数据包的开始。</td></tr><tr><td><code>nLength</code></td><td><code>DWORD</code></td><td><strong>包长度</strong>，表示从控制命令（<code>sCmd</code>）开始，到校验和（<code>sSum</code>）结束的总长度。</td></tr><tr><td><code>sCmd</code></td><td><code>WORD</code></td><td><strong>控制命令</strong>，用于标识数据包的类型或操作指令。</td></tr><tr><td><code>strData</code></td><td><code>std::string</code></td><td><strong>包数据</strong>，存储实际的数据内容，长度可变。</td></tr><tr><td><code>sSum</code></td><td><code>WORD</code></td><td><strong>校验和</strong>，用于验证数据包的完整性。</td></tr></tbody></table><h5 id="1、找包头"><a href="#1、找包头" class="headerlink" title="1、找包头"></a>1、找包头</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; i &lt; nSize; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (*(WORD*)(pData + i) == <span class="number">0xFEFF</span>) &#123;</span><br><span class="line">sHead = *(WORD*)(pData + i);</span><br><span class="line">i += <span class="number">2</span>; <span class="comment">// 找到包头后，就跳过包头，然后就是</span></span><br><span class="line"><span class="keyword">break</span>;  <span class="comment">// 跳出循环</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2、找到包头后，判断如果包头后的数据小于8字节，那么就返回了"><a href="#2、找到包头后，判断如果包头后的数据小于8字节，那么就返回了" class="headerlink" title="2、找到包头后，判断如果包头后的数据小于8字节，那么就返回了"></a>2、找到包头后，判断如果包头后的数据小于8字节，那么就返回了</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i + <span class="number">4</span> + <span class="number">2</span> + <span class="number">2</span> &gt; nSize) &#123; <span class="comment">// 包数据可能不全，或者包头未能全部接收到</span></span><br><span class="line">nSize = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个8个字节包括包长度nLength（4字节）、控制命令sCmd（2字节）、包校验和（2字节），这里判断包是不是完整的，不完整那就让nSize清零。</p><h5 id="3、让nLength提取包长度的值（4字节），现在nLength的值就是从控制命令开始到校验和结束，然后加上偏移量跟nSize比较"><a href="#3、让nLength提取包长度的值（4字节），现在nLength的值就是从控制命令开始到校验和结束，然后加上偏移量跟nSize比较" class="headerlink" title="3、让nLength提取包长度的值（4字节），现在nLength的值就是从控制命令开始到校验和结束，然后加上偏移量跟nSize比较"></a>3、让nLength提取包长度的值（4字节），现在nLength的值就是从控制命令开始到校验和结束，然后加上偏移量跟nSize比较</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// * 是解引用操作符，表示从 (DWORD*)(pData + i) 所指向的位置提取 4 字节的值。</span></span><br><span class="line"><span class="comment">// 最终，这 4 字节的值被赋值给 nLength。</span></span><br><span class="line">nLength = *(DWORD*)(pData + i);</span><br><span class="line"><span class="keyword">if</span> (nLength + i &gt; nSize) &#123;<span class="comment">// 包没有完全接收，就返回，解析失败。</span></span><br><span class="line">nSize = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4、读取包长度，然后如果包没有数据部分，那就说明包没有完全接受"><a href="#4、读取包长度，然后如果包没有数据部分，那就说明包没有完全接受" class="headerlink" title="4、读取包长度，然后如果包没有数据部分，那就说明包没有完全接受"></a>4、读取包长度，然后如果包没有数据部分，那就说明包没有完全接受</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nLength = *(DWORD*)(pData + i); i += <span class="number">4</span>;</span><br><span class="line"><span class="keyword">if</span> (nLength + i &gt; nSize) &#123;<span class="comment">// 包没有完全接收，就返回，解析失败。</span></span><br><span class="line">nSize = <span class="number">0</span>; <span class="comment">// 让nSize清零</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5、读取命令控制的内容"><a href="#5、读取命令控制的内容" class="headerlink" title="5、读取命令控制的内容"></a>5、读取命令控制的内容</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sCmd = *(WORD*)(pData + i); i += <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (nLength &gt; <span class="number">4</span>) &#123;</span><br><span class="line"><span class="comment">// 调整数据的大小  让nLength 减去控制命令和检验和的大小</span></span><br><span class="line">strData.<span class="built_in">resize</span>(nLength - <span class="number">2</span> - <span class="number">2</span>);</span><br><span class="line"><span class="built_in">memcpy</span>((<span class="type">void</span>*)strData.<span class="built_in">c_str</span>(), pData + i, nLength - <span class="number">4</span>);</span><br><span class="line">i += nLength - <span class="number">4</span>; <span class="comment">// 这是数据的长度，相当于跳过了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="6、提取校验和（sSum）"><a href="#6、提取校验和（sSum）" class="headerlink" title="6、提取校验和（sSum）"></a>6、提取校验和（sSum）</h5><p>校验和的计算需要遍历数据是因为<strong>校验和通常是根据数据部分的内容计算得出的</strong>，而不仅仅是读取校验和字段本身</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sSum = *(WORD*)(pData + i); i += <span class="number">2</span>;</span><br><span class="line">WORD sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; strData.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">sum += <span class="built_in">BYTE</span>(strData[i]) &amp; <span class="number">0xFF</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (sum == sSum) &#123;</span><br><span class="line">nSize = i;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">nSize = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><strong>成员变量顺序导致包长度和包控制命令位置互换</strong></p><h5 id="1-成员变量的内存布局"><a href="#1-成员变量的内存布局" class="headerlink" title="1. 成员变量的内存布局"></a>1. 成员变量的内存布局</h5><p>C++ 标准规定，类成员变量在内存中的布局顺序与它们在类定义中的声明顺序一致。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CPacket</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:    </span><br><span class="line">    WORD sHead;</span><br><span class="line">    WORD sCmd;</span><br><span class="line">    DWORD nLength;</span><br><span class="line">    std::string strData;</span><br><span class="line">    WORD sSum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在上述类中，成员变量的内存布局顺序是：<code>sHead</code> → <code>sCmd</code> → <code>nLength</code> → <code>strData</code> → <code>sSum</code>。</p><h5 id="2-封包时的内存拷贝"><a href="#2-封包时的内存拷贝" class="headerlink" title="2. 封包时的内存拷贝"></a>2. 封包时的内存拷贝</h5><p>如果你直接将类对象的内存作为数据包发送，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CPacket packet;</span><br><span class="line">send((const char*)&amp;packet, sizeof(packet));</span><br></pre></td></tr></table></figure><p>这种方式会将类的内存布局直接作为数据包发送。如果类的成员变量顺序与数据包的格式要求不一致，会导致数据包的内容错乱。</p><h5 id="3-动态成员变量"><a href="#3-动态成员变量" class="headerlink" title="3. 动态成员变量"></a>3. 动态成员变量</h5><p>如果类中包含动态成员变量（例如 <code>std::string</code> 或指针），不能直接通过内存拷贝的方式发送整个类对象，因为这些变量的实际数据存储在堆上，而不是类对象的连续内存中。</p>]]></content>
      
      
      <categories>
          
          <category> 远控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt09TCP-IP网络通信</title>
      <link href="/2025/03/13/Qt09TCP-IP%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"/>
      <url>/2025/03/13/Qt09TCP-IP%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<p>TCP&#x2F;IP通信（即SOCKET通信）是通过网线将<strong>服务器Server端</strong>和<strong>客户机Client端</strong>进行连接，在遵循ISO&#x2F;OSI模型的四层层级构架的基础上通过TCP&#x2F;IP协议建立的通讯。控制器可以设置为服务器端或客户端。</p><p>关于TCP&#x2F;IP协议可详看：<a href="https://zhuanlan.zhihu.com/p/33889997">TCP&#x2F;IP协议详解 - 知乎 (zhihu.com)</a></p><p> 总的来说，TCP&#x2F;IP通讯有两个部分：</p><ul><li><strong>客户端</strong>和<strong>服务器</strong></li><li><strong>QTcpServer（监听套接字）<strong>和</strong>QTcpSocket（通讯套接字）</strong></li></ul><p>监听套接字，顾名思义，监听关于各种通讯的状态，一旦进行通讯，监听套接字会启动通讯套接字，进行通讯</p><p>客户端使用connectToHost函数主动连接服务器后，服务器会触发newConnectio这个槽函数，并进行取出QTcpServer（监听套接字），将相关内容取出并赋给QTcpSocket（通讯套接字）。<br>客户端向服务器发送数据，触发readyRead（），进行处理，彼此传递时，原理都是这样的。</p><p><strong>对双方来说都起作用的部分：</strong></p><ol><li>一旦建立连接，就会触发connected，服务器特殊一点，触发的是newConnectio</li><li>互传数据也是一样的，一旦接受到，就会触发readyread</li></ol><p>服务器中，需要监听套接字以及通讯套接字，监听套接字用于监听客户端是否给服务器发送请求</p><p>本篇博文做了初步的学习与尝试，编写了一个客户端和服务器基于窗口通信以及文件传输的小例程。</p><h3 id="一，客户端"><a href="#一，客户端" class="headerlink" title="一，客户端"></a><font color="FF0000">一，客户端</font></h3><p>客户端的代码比服务器稍简单，总的来说，使用QT中的<strong>QTcpSocket类</strong>与服务器进行通信只需要以下5步：</p><p><strong>（1）创建QTcpSocket套接字对象</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket = new QTcpSocket(this);</span><br></pre></td></tr></table></figure><p><strong>（2）使用这个对象连接服务器</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QString ip = ui.lineEdit_ip-&gt;text();//获取ip</span><br><span class="line">int port = ui.lineEdit_2-&gt;text().toInt();//获取端口数据</span><br><span class="line">socket-&gt;connectToHost(ip, port);</span><br></pre></td></tr></table></figure><p><strong>（3）使用write函数向服务器发送数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QByteArray data = ui.lineEdit_3-&gt;text().toUtf8();//获取lineEdit控件中的数据并发送给服务器</span><br><span class="line">socket-&gt;write(data);</span><br></pre></td></tr></table></figure><p> <strong>（4）当socket接收缓冲区有新数据到来时，会发出readRead()信号，因此为该信号添加槽函数以读取数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> connect(socket, &amp;QTcpSocket::readyRead, this, &amp;QTcpClinet::ReadData);</span><br><span class="line">void QTcpClinet::ReadData()</span><br><span class="line">&#123;</span><br><span class="line">    QByteArray buf = socket-&gt;readAll();</span><br><span class="line">    ui.textEdit-&gt;append(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（5）断开与服务器的连接（关于close()和disconnectFromHost()的区别，可以按F1看帮助）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket-&gt;disconnectFromHost();</span><br></pre></td></tr></table></figure><p><strong>客户端例程：（新建一个qt项目QTcpClinet（客户机））</strong></p><ul><li><strong>ui界面</strong></li></ul><p><img src="https://bu.dusays.com/2025/03/13/67d2dbe2f1a93.png"></p><p>本地回路ip：127.0.0.1 可以连接到本地ip（电脑内部循环的ip）</p><p>如果要和局域网其他ip连接 -&gt; 在运行（win+R）+cmd+ipconfig -&gt;ipv4地址 查看本机ip</p><ul><li><strong>QTcpClinet.h</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;QtWidgets/QWidget&gt;</span><br><span class="line">#include &quot;ui_QTcpClinet.h&quot;</span><br><span class="line">#include&quot;QTcpSocket.h&quot;</span><br><span class="line">#pragma execution_character_set(&quot;utf-8&quot;)</span><br><span class="line">class QTcpClinet : public QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    QTcpClinet(QWidget *parent = Q_NULLPTR);</span><br><span class="line">    ~QTcpClinet();</span><br><span class="line">public slots:</span><br><span class="line">    void on_btn_connect_clicked();</span><br><span class="line">    void ReadData();</span><br><span class="line">    void on_btn_push_clicked();</span><br><span class="line">private:</span><br><span class="line">    Ui::QTcpClinetClass ui;</span><br><span class="line">    QTcpSocket* socket;//创建socket指针</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>QTcpClinet.cpp</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;QTcpClinet.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">QTcpClinet::<span class="built_in">QTcpClinet</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    ui.<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    socket = <span class="keyword">new</span> <span class="built_in">QTcpSocket</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QTcpClinet::~<span class="built_in">QTcpClinet</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;socket;<span class="comment">//回收内存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTcpClinet::on_btn_connect_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ui.btn_connect-&gt;<span class="built_in">text</span>()==<span class="built_in">tr</span>(<span class="string">&quot;连接服务器&quot;</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    QString ip = ui.lineEdit_ip-&gt;<span class="built_in">text</span>();<span class="comment">//获取ip</span></span><br><span class="line">    <span class="type">int</span> port = ui.lineEdit_2-&gt;<span class="built_in">text</span>().<span class="built_in">toInt</span>();<span class="comment">//获取端口数据</span></span><br><span class="line">    <span class="comment">//取消已有的连接</span></span><br><span class="line">    socket-&gt;<span class="built_in">abort</span>();</span><br><span class="line">    <span class="comment">//连接服务器</span></span><br><span class="line">    socket-&gt;<span class="built_in">connectToHost</span>(ip, port);</span><br><span class="line">    <span class="type">bool</span> isconnect = socket-&gt;<span class="built_in">waitForConnected</span>();<span class="comment">//等待直到连接成功</span></span><br><span class="line">    <span class="comment">//如果连接成功</span></span><br><span class="line">    <span class="keyword">if</span> (isconnect)</span><br><span class="line">    &#123;</span><br><span class="line">        ui.textEdit-&gt;<span class="built_in">append</span>(<span class="string">&quot;The connection was successful!!&quot;</span>);</span><br><span class="line">        ui.btn_push-&gt;<span class="built_in">setEnabled</span>(<span class="literal">true</span>);<span class="comment">//按钮使能</span></span><br><span class="line">        <span class="comment">//修改按键文字</span></span><br><span class="line">        ui.btn_connect-&gt;<span class="built_in">setText</span>(<span class="string">&quot;断开服务器连接&quot;</span>);</span><br><span class="line">        <span class="comment">//接收缓冲区（服务器）信息</span></span><br><span class="line">        <span class="built_in">connect</span>(socket, &amp;QTcpSocket::readyRead, <span class="keyword">this</span>, &amp;QTcpClinet::ReadData);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ui.textEdit-&gt;<span class="built_in">append</span>(<span class="string">&quot;The connection falied!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">//断开连接</span></span><br><span class="line">      socket-&gt;<span class="built_in">disconnectFromHost</span>();</span><br><span class="line">      ui.btn_connect-&gt;<span class="built_in">setText</span>(<span class="string">&quot;连接服务器&quot;</span>);</span><br><span class="line">      ui.btn_push-&gt;<span class="built_in">setEnabled</span>(<span class="literal">false</span>);<span class="comment">//关闭发送按钮使能</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收缓冲区信息函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTcpClinet::ReadData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QByteArray buf = socket-&gt;<span class="built_in">readAll</span>();</span><br><span class="line">    ui.textEdit-&gt;<span class="built_in">append</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//发送按钮事件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTcpClinet::on_btn_push_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QByteArray data = ui.lineEdit_3-&gt;<span class="built_in">text</span>().<span class="built_in">toUtf8</span>();<span class="comment">//获取lineEdit控件中的数据并发送给服务器</span></span><br><span class="line">    socket-&gt;<span class="built_in">write</span>(data);</span><br><span class="line">    <span class="comment">//判断是否写入成功</span></span><br><span class="line">    <span class="type">bool</span> iswrite = socket-&gt;<span class="built_in">waitForBytesWritten</span>();</span><br><span class="line">    <span class="keyword">if</span> (iswrite)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//写入成功</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//没有写入成功</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二，服务器（需要一直运行哦）"><a href="#二，服务器（需要一直运行哦）" class="headerlink" title="二，服务器（需要一直运行哦）"></a><font color="FF0000">二，服务器（需要一直运行哦）</font></h3><p>服务器除了使用到了<strong>QTcpSocket类</strong>，还需要用到<strong>QTcpSever类</strong>。即便如此，也只是比客户端复杂一点点，用到了6个步骤：</p><p><strong>（1）创建QTcpSever对象</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server = new QTcpServer(this);</span><br></pre></td></tr></table></figure><p><strong>（2）侦听一个端口，使得客户端可以使用这个端口访问服务器</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server-&gt;listen(QHostAddress::Any, 6677);//监听所有ip和6677端口</span><br></pre></td></tr></table></figure><p><strong>（3）当服务器被客户端访问时，会发出newConnection()信号，因此为该信号添加槽函数，并用一个QTcpSocket对象接受客户端访问</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">connect(server, &amp;QTcpServer::newConnection, this, &amp;TcpServer::ClientConnect);</span><br><span class="line">void TcpServer::ClientConnect()</span><br><span class="line">&#123;</span><br><span class="line">    //解析所有客户连接</span><br><span class="line">    while (server-&gt;hasPendingConnections())</span><br><span class="line">    &#123;</span><br><span class="line">        //连接上后通过socket（QTcpSocket对象）获取连接信息</span><br><span class="line">        socket = server-&gt;nextPendingConnection();</span><br><span class="line">        QString str = QString(&quot;[ip:%1,port:%2]&quot;).arg(socket-&gt;peerAddress().toString()).arg(socket-&gt;peerPort());//监听客户端是否有消息发送</span><br><span class="line">        connect(socket, &amp;QTcpSocket::readyRead, this, &amp;TcpServer::ReadData1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（4）使用socket的write函数向客户端发送数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket-&gt;write(data);</span><br></pre></td></tr></table></figure><p><strong>（5）当socket接收缓冲区有新数据到来时，会发出readRead()信号，因此为该信号添加槽函数以读取数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//监听客户端是否有消息发送</span><br><span class="line">connect(socket, &amp;QTcpSocket::readyRead, this, &amp;TcpServer::ReadData1);</span><br><span class="line">//获取客户端向服务器发送的信息</span><br><span class="line">void TcpServer::ReadData1()</span><br><span class="line">&#123;</span><br><span class="line">    QByteArray buf = socket-&gt;readAll();//readAll最多接收65532的数据</span><br><span class="line">    QString str = QString(&quot;[ip:%1,port:%2]&quot;).arg(socket-&gt;peerAddress().toString()).arg(socket-&gt;peerPort());</span><br><span class="line">    ui.textEdit_server-&gt;append(str +QString(buf));</span><br><span class="line">    //socket-&gt;write(&quot;ok&quot;);//服务器接收到信息后返回一个ok</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（6）取消侦听</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server-&gt;close();</span><br></pre></td></tr></table></figure><p> <strong>服务器例程：（添加一个新的qt项目TcpServer（服务器））</strong></p><ul><li><strong>ui界面</strong></li></ul><p><img src="https://bu.dusays.com/2025/03/13/67d2dc19a7d8f.png"></p><ul><li><strong>TcpServer.h</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;QtWidgets/QWidget&gt;</span><br><span class="line">#include&quot;ui_TcpServer.h&quot;</span><br><span class="line">#include&quot;qtcpserver.h&quot;</span><br><span class="line">#include&quot;qtcpsocket.h&quot;</span><br><span class="line"></span><br><span class="line">class TcpServer : public QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    TcpServer(QWidget *parent = Q_NULLPTR);</span><br><span class="line">    ~TcpServer();</span><br><span class="line">public slots:</span><br><span class="line">    void on_btn_server_clicked();</span><br><span class="line">    void on_btn_listen_clicked();</span><br><span class="line">private:</span><br><span class="line">    Ui::TcpServerClass ui;</span><br><span class="line">    QTcpServer* server;</span><br><span class="line">    QTcpSocket* socket;//一个客户端对应一个socket</span><br><span class="line">    void ClientConnect();</span><br><span class="line">    void ReadData1();</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>TcpServer.cpp</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;TcpServer.h&quot;</span><br><span class="line">#include&quot;qstring.h&quot;</span><br><span class="line">#include&quot;qdebug.h&quot;</span><br><span class="line">#pragma execution_character_set(&quot;utf-8&quot;)</span><br><span class="line">TcpServer::TcpServer(QWidget *parent)</span><br><span class="line">    : QWidget(parent)</span><br><span class="line">&#123;</span><br><span class="line">    ui.setupUi(this);</span><br><span class="line">    server = new QTcpServer(this);</span><br><span class="line">   //客户机连接信号槽</span><br><span class="line">    connect(server, &amp;QTcpServer::newConnection, this, &amp;TcpServer::ClientConnect);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TcpServer::~TcpServer()</span><br><span class="line">&#123;</span><br><span class="line">    server-&gt;close();</span><br><span class="line">    server-&gt;deleteLater();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TcpServer::on_btn_listen_clicked()</span><br><span class="line">&#123;</span><br><span class="line">    if (ui.btn_listen-&gt;text()==&quot;侦听&quot;)</span><br><span class="line">    &#123;</span><br><span class="line">        //从输入框获取端口号</span><br><span class="line">        int port = ui.lineEdit_port-&gt;text().toInt();</span><br><span class="line">        //侦听指定端口的所有ip</span><br><span class="line">        if (!server-&gt;listen(QHostAddress::Any, port))</span><br><span class="line">        &#123;</span><br><span class="line">            //若出错，则输出错误信息</span><br><span class="line">            qDebug() &lt;&lt; server-&gt;errorString();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //修改按键文字</span><br><span class="line">        ui.btn_listen-&gt;setText(&quot;取消侦听&quot;);    </span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        socket-&gt;abort();</span><br><span class="line">        //取消侦听</span><br><span class="line">        server-&gt;close();</span><br><span class="line">        //修改按键文字</span><br><span class="line">        ui.btn_listen-&gt;setText(&quot;侦听&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TcpServer::ClientConnect()</span><br><span class="line">&#123;</span><br><span class="line">    //解析所有客户连接</span><br><span class="line">    while (server-&gt;hasPendingConnections())</span><br><span class="line">    &#123;</span><br><span class="line">        //连接上后通过socket获取连接信息</span><br><span class="line">        socket = server-&gt;nextPendingConnection();</span><br><span class="line">        QString str = QString(&quot;[ip:%1,port:%2]&quot;).arg(socket-&gt;peerAddress().toString()).arg(socket-&gt;peerPort());</span><br><span class="line">        //提示连接成功</span><br><span class="line">        ui.textEdit_server-&gt;append(str+&quot;Connect to the server&quot;);</span><br><span class="line">        //复选框选项为连接服务器的ip</span><br><span class="line">        ui.comboBox-&gt;addItem(str);</span><br><span class="line">        //将socket地址放入combobox属性内</span><br><span class="line">        //ui.comboBox-&gt;setItemData(ui.comboBox-&gt;count()-1, QVariant((int)socket));</span><br><span class="line">        //监听客户端是否有消息发送</span><br><span class="line">        connect(socket, &amp;QTcpSocket::readyRead, this, &amp;TcpServer::ReadData1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//获取客户端向服务器发送的信息</span><br><span class="line">void TcpServer::ReadData1()</span><br><span class="line">&#123;</span><br><span class="line">    QByteArray buf = socket-&gt;readAll();//readAll最多接收65532的数据</span><br><span class="line">    QString str = QString(&quot;[ip:%1,port:%2]&quot;).arg(socket-&gt;peerAddress().toString()).arg(socket-&gt;peerPort());</span><br><span class="line">    ui.textEdit_server-&gt;append(str +QString(buf));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//服务器向客户端发送信息</span><br><span class="line">void TcpServer::on_btn_server_clicked()</span><br><span class="line">&#123;</span><br><span class="line">  if(ui.comboBox-&gt;count()== 0)return;</span><br><span class="line">  //QTcpSocket* skt=  (QTcpSocket*)ui.comboBox-&gt;itemData(ui.comboBox-&gt;currentIndex()).value&lt;int&gt;();</span><br><span class="line">  socket-&gt;write(ui.lineEdit1-&gt;text().toUtf8());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：write中需要写入char类型的元素或QByteArray类型的元素</p><p><img src="https://bu.dusays.com/2025/03/13/67d2dc2f4307e.png"></p><p><strong>效果展示：</strong></p><p><img src="https://bu.dusays.com/2025/03/13/67d2dc5b93345.gif"></p><h3 id="三，TCP-IP文件传输"><a href="#三，TCP-IP文件传输" class="headerlink" title="三，TCP&#x2F;IP文件传输"></a><font color="FF0000">三，TCP&#x2F;IP文件传输</font></h3><p>上文实现了消息的传输，由于<strong>socket-&gt;readAll();（readAll最多接收65532的数据）</strong>，因此对于大文件的传输用此方法是不可取的。</p><p><strong>TCP&#x2F;IP文件传输的思路：</strong></p><ol><li>客户端和服务器连接</li><li>客户端选择文件，并发送文件给服务器（发送的是文件的帧头，格式：文件名&amp;大小）</li><li>服务器触发readyRead，然后解析文件帧头（获取文件名和大小），并返回客户端一个ok消息</li><li>客户端触发readyRead，然后发送文件数据，通过progressBar显示进度</li><li>服务器再次触发readyRead，接收文件数据，并保存（通过ishead判断接收的是文件帧头还是文件数据）</li></ol><p><strong>代码实现：</strong></p><p>新建服务器项目（TcpServer）</p><ul><li><strong>TcpServer.h</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">#include &lt;QtWidgets/QWidget&gt;</span><br><span class="line">#include &quot;ui_TcpServer.h&quot;</span><br><span class="line">#include&quot;qtcpserver.h&quot;</span><br><span class="line">#include&quot;qtcpsocket.h&quot;</span><br><span class="line">#pragma execution_character_set(&quot;utf-8&quot;)</span><br><span class="line">class TcpServer : public QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    TcpServer(QWidget *parent = Q_NULLPTR);</span><br><span class="line">    void hasConnect();</span><br><span class="line">private:</span><br><span class="line">    Ui::TcpServerClass ui;</span><br><span class="line">    QTcpServer* server;</span><br><span class="line">    QTcpSocket* socket;</span><br><span class="line">    bool ishead;</span><br><span class="line">    QString fileName;</span><br><span class="line">    int fileSize;//接收文件的总大小</span><br><span class="line">    int recvSize;//当前接收文件的大小</span><br><span class="line">    QByteArray filebuf;//当前接收的文件数据</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>TcpServer.cpp</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;TcpServer.h&quot;</span><br><span class="line">#include&quot;qfile.h&quot;</span><br><span class="line">TcpServer::TcpServer(QWidget *parent)</span><br><span class="line">    : QWidget(parent)</span><br><span class="line">&#123;</span><br><span class="line">    ishead = true;</span><br><span class="line">    ui.setupUi(this);</span><br><span class="line">    server = new QTcpServer(this);</span><br><span class="line">    //监听1122端口的ip</span><br><span class="line">    server-&gt;listen(QHostAddress::Any, 1122);</span><br><span class="line">    //如果有用户连接触发槽函数</span><br><span class="line">    connect(server, &amp;QTcpServer::newConnection, this, &amp;TcpServer::hasConnect);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TcpServer::hasConnect()</span><br><span class="line">&#123;</span><br><span class="line">    while (server-&gt;hasPendingConnections()&gt;0)//判断当前连接了多少人</span><br><span class="line">    &#123;</span><br><span class="line">        //用socket和我们的客户端连接，一个客户端对应一个套接字socket</span><br><span class="line">        socket = server-&gt;nextPendingConnection();</span><br><span class="line">        //服务器界面上输出客户端信息</span><br><span class="line">        ui.textEdit-&gt;append(QString(&quot;%1：新用户连接&quot;).arg(socket-&gt;peerPort()));</span><br><span class="line">        //如果客户端发送信息过来了，触发匿名函数</span><br><span class="line">        connect(socket, &amp;QTcpSocket::readyRead, [=]() &#123;</span><br><span class="line">            QByteArray buf = socket-&gt;readAll();</span><br><span class="line">            //用一个标志位ishead判断是头还是数据位</span><br><span class="line">            if (ishead)</span><br><span class="line">            &#123;</span><br><span class="line">                //如果是头，解析头（文件名，文件大小）</span><br><span class="line">                QString str = QString(buf);</span><br><span class="line">                ui.textEdit-&gt;append(str);</span><br><span class="line">                QStringList strlist = str.split(&quot;&amp;&quot;);</span><br><span class="line">                fileName = strlist.at(0);//解析帧头文件名</span><br><span class="line">                fileSize = strlist.at(1).toInt();//解析帧头文件大小</span><br><span class="line">                ishead = false;//下次接收到的文件就是我们的数据</span><br><span class="line">                recvSize = 0;</span><br><span class="line">                filebuf.clear();</span><br><span class="line">                socket-&gt;write(&quot;ok&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                //根据文件名和文件大小接收和保存文件</span><br><span class="line">                filebuf.append(buf);</span><br><span class="line">                recvSize += buf.size();//每接收一次文件，当前文件大小+1</span><br><span class="line">                //当接收文件大小等于总文件大小，即文件数据接收完毕</span><br><span class="line">                if (recvSize&gt;=fileSize)</span><br><span class="line">                &#123;</span><br><span class="line">                    //保存文件</span><br><span class="line">                    QFile file(ui.lineEdit-&gt;text() + fileName);</span><br><span class="line">                    file.open(QIODevice::WriteOnly);</span><br><span class="line">                    file.write(filebuf);</span><br><span class="line">                    file.close();</span><br><span class="line">                    ishead = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建客户端项目（QTcpClient）</p><ul><li><strong>QTcpClient.h</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;QtWidgets/QWidget&gt;</span><br><span class="line">#include&quot;ui_QTcpClient.h&quot;</span><br><span class="line">#include&quot;qtcpsocket.h&quot;</span><br><span class="line">#pragma execution_character_set(&quot;utf-8&quot;)</span><br><span class="line">class QTcpClient : public QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    QTcpClient(QWidget *parent = Q_NULLPTR);</span><br><span class="line">public slots:</span><br><span class="line">    void on_btn_connect_clicked();</span><br><span class="line">    void on_btn_choose_clicked();</span><br><span class="line">    void on_btn_open_clicked();</span><br><span class="line">    </span><br><span class="line">private:</span><br><span class="line">    Ui::QTcpClientClass ui;</span><br><span class="line">    QTcpSocket* socket;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>QTcpClient.cpp</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;QTcpClient.h&quot;</span><br><span class="line">#include&quot;qfiledialog.h&quot;</span><br><span class="line">#include&quot;qfileinfo.h&quot;</span><br><span class="line">QTcpClient::QTcpClient(QWidget *parent)</span><br><span class="line">    : QWidget(parent)</span><br><span class="line">&#123;</span><br><span class="line">    ui.setupUi(this);</span><br><span class="line">    socket = new QTcpSocket(this);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">void QTcpClient::on_btn_connect_clicked()</span><br><span class="line">&#123;</span><br><span class="line">    QString ip = ui.lineEdit_ip-&gt;text();//获取ip</span><br><span class="line">    int port = ui.lineEdit_port-&gt;text().toInt();//获取端口数据</span><br><span class="line">    socket-&gt;connectToHost(ip, port);//连接服务器</span><br><span class="line">    //等待连接成功</span><br><span class="line">    if (socket-&gt;waitForConnected())</span><br><span class="line">    &#123;</span><br><span class="line">        ui.textEdit-&gt;append(&quot;&lt;font color=&#x27;green&#x27;&gt;连接服务器成功！&lt;/font&gt;&quot;);    </span><br><span class="line">        ui.btn_open-&gt;setEnabled(true);</span><br><span class="line">        </span><br><span class="line">        //如果服务器发送信息到客户端，触发匿名函数</span><br><span class="line">        connect(socket, &amp;QTcpSocket::readyRead, [=]() &#123;</span><br><span class="line">            //读取服务器发送的信息（即缓冲区信息）</span><br><span class="line">            QByteArray buf = socket-&gt;readAll();</span><br><span class="line">            if (buf==&quot;ok&quot;)</span><br><span class="line">            &#123;</span><br><span class="line">                QFile file = (ui.label_path-&gt;text());</span><br><span class="line">                if (!file.open(QIODevice::ReadWrite))</span><br><span class="line">                &#123;</span><br><span class="line">                    //读取文件失败</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                qint64 currentlen = 0;//当前已经发送的大小</span><br><span class="line">                qint64 allLength = file.size();//总文件大小</span><br><span class="line">                do</span><br><span class="line">                &#123;</span><br><span class="line">                    char data[1024];</span><br><span class="line">                    qint64 msize = file.read(data, 1024);//读文件放入打他数组中，返回读取到的大小</span><br><span class="line">                    socket-&gt;write(data, msize);//把读取到的data数据发送给服务器</span><br><span class="line">                    currentlen += msize;//实时获取当前发送的文件大小</span><br><span class="line">                    ui.progressBar-&gt;setValue(currentlen *100 / allLength);//更新界面进度条</span><br><span class="line">                &#125; while (currentlen &lt; allLength);//当发送文件等于文件大小时，发送完毕，循环结束</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        ui.textEdit-&gt;append(&quot;&lt;font color=&#x27;red&#x27;&gt;连接服务器失败！&lt;/font&gt;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//选择文件事件</span><br><span class="line">void QTcpClient::on_btn_choose_clicked()</span><br><span class="line">&#123;</span><br><span class="line">    QString path = QFileDialog::getOpenFileName(this, &quot;打开文件&quot;, &quot;&quot;, &quot;(*.*)&quot;);</span><br><span class="line">    ui.label_path-&gt;setText(path);</span><br><span class="line">&#125;</span><br><span class="line">//发送文件事件</span><br><span class="line">void QTcpClient::on_btn_open_clicked()</span><br><span class="line">&#123;</span><br><span class="line">    QFileInfo info(ui.label_path-&gt;text());</span><br><span class="line">    //用QFileInfo：：fileName，size获取文件名和大小 格式：文件名&amp;大小</span><br><span class="line">    //服务器用该格式解析文件名和大小</span><br><span class="line">    QString head = QString(&quot;%1&amp;%2&quot;).arg(info.fileName()).arg(info.size());</span><br><span class="line">    //将该格式发送给服务器 toUtf8：QString转QByteArray或char类型</span><br><span class="line">    socket-&gt;write(head.toUtf8()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果展示：</strong></p><p><img src="https://bu.dusays.com/2025/03/13/67d2dc9a83bfe.gif"></p><br><br><br><p><span style="color: red; font-size: 20px;">转载自：<a href="https://www.cnblogs.com/xyf327">唯有自己强大</a>          如有侵权，在下方评论  立刻删除。</span></p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt学习 </tag>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt08项目打包和发布</title>
      <link href="/2025/03/13/Qt08%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E5%92%8C%E5%8F%91%E5%B8%83/"/>
      <url>/2025/03/13/Qt08%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E5%92%8C%E5%8F%91%E5%B8%83/</url>
      
        <content type="html"><![CDATA[<p>打包整体思路：</p><ul><li>将编译后的exe可执行文件及其各种依赖dll、lib、图标、配置文件等先打包放到一个目录中</li><li>对其进行打包发布（两种方式）：</li></ul><ol><li>利用VS的插件Microsoft Visual Studio Installer Projects安装程序打包插件进行打包</li><li>利用Enigma Virtual Box(单文件封装工具) 进行打包</li></ol><h3 id="一，将编译后的exe可执行文件及其各种依赖dll、lib、图标、配置文件等先打包放到一个目录中"><a href="#一，将编译后的exe可执行文件及其各种依赖dll、lib、图标、配置文件等先打包放到一个目录中" class="headerlink" title="一，将编译后的exe可执行文件及其各种依赖dll、lib、图标、配置文件等先打包放到一个目录中"></a><font color="FF0000">一，将编译后的exe可执行文件及其各种依赖dll、lib、图标、配置文件等先打包放到一个目录中</font></h3><p><strong>（1）dumpbin指令查看可执行文件的dll依赖包</strong></p><p>在VS开发人员命令提示符（vs界面-&gt;工具-&gt;命令行-&gt;开发者命令提示）中执行<strong>dumpbin &#x2F;dependents 程序路径 ：dumpbin&#x2F;dependents C:\Users\WFD\Desktop\GCtest\Debug\GCtest</strong></p><p><img src="https://bu.dusays.com/2025/03/13/67d2d919ca716.png"></p><p><strong>（2）windeployqt.exe指令自动将qt依赖包复制过来</strong></p><p> 1️⃣先打开 Qt 的命令行（用的32位）</p><p><img src="https://bu.dusays.com/2025/03/13/67d2d931dc01c.png"></p><p>2️⃣使用“cd&#x2F;d 路径” 命令进入到包含.exe 文件的文件夹。</p><p>3️⃣ Qt 命令行执行 windeployqt 工具，输入： “windeployqt ***.exe” ，就可以将qt依赖包复制到该文件夹中</p><p><img src="https://bu.dusays.com/2025/03/13/67d2d94c54e1f.png"></p><p><img src="https://bu.dusays.com/2025/03/13/67d2d95753bae.png"></p><p><strong>（3）非Qt依赖库的添加</strong></p><p><strong>要注意release版本与debug版本所需要的依赖是不一样的，需要分别打包！！！</strong></p><ul><li><strong>方法一</strong></li></ul><p>在通过vs的dumpbin指令查询到可执行文件的dll依赖包后，使用eyerything软件根据位置去寻找dll文件。</p><p>下载地址：<a href="http://www.voidtools.com/">http://www.voidtools.com/</a></p><p><img src="https://bu.dusays.com/2025/03/13/67d2d99b229d6.png"></p><ul><li><strong>方法二</strong></li></ul><p>如果动态库有很多那么复制起来很麻烦（比如上面Qtcore.dll查找到很多路径，但是不知道用哪个），可以使用window的批处理：</p><p>通过观察程序运行时Vs输出窗口中加载的dll库：</p><p><img src="https://bu.dusays.com/2025/03/13/67d2d9b78f0fc.png"></p><ul><li><strong>方法三</strong></li></ul><p>使用Dependency Wallker 打开***.exe 查找不存在的.dll，其中黄色的问号标识是不存在的。Dependency Wallker可以递归显示可执行文件（exe）和动态库（dll）调用的动态库。</p><p>打开**.exe文件之后各个节点可能是展开的很乱，可以右击任意节点选择“折叠所有(L)”,然后再单击根节点的加号展开就是如图所示的样式，这样很清晰。</p><p><img src="https://bu.dusays.com/2025/03/13/67d2d9d63494d.png"></p><p>在全部添加完依赖库后，点击exe运行文件就可以本机运行了。或者将该文件夹全部发送给用户也可运行。</p><p>那么如何只使用一个exe文件就完成程序的运行呢？</p><p><strong>🙄这就要用到下面要说的打包和发布了。</strong></p><h3 id="二，利用VS的插件Microsoft-Visual-Studio-Installer-Projects安装程序打包插件进行打包"><a href="#二，利用VS的插件Microsoft-Visual-Studio-Installer-Projects安装程序打包插件进行打包" class="headerlink" title="二，利用VS的插件Microsoft Visual Studio Installer Projects安装程序打包插件进行打包"></a><font color="FF0000">二，利用VS的插件Microsoft Visual Studio Installer Projects安装程序打包插件进行打包</font></h3><p>安装过程不再详述参见：<a href="https://www.cnblogs.com/wuyubing/p/12378014.html">Installer Projects插件的安装</a></p><p> <strong>（1）新建安装项目</strong></p><p>解决方案-&gt;新建项目-&gt;setup project</p><p><img src="https://bu.dusays.com/2025/03/13/67d2d9ff7680d.png"></p><p>进入文件系统：(setup1-&gt;view-&gt;文件系统）</p><p><img src="https://bu.dusays.com/2025/03/13/67d2da14e0621.png"></p><p> <strong>（2）添加文件</strong></p><p>Application Folder-&gt;add-&gt;文件（在此添加相关的依赖资源）</p><p><img src="https://bu.dusays.com/2025/03/13/67d2da26840fa.png"></p><p> 将exe所在目录下的所有文件添加到该处</p><p> <strong>（3）添加项目输出</strong></p><p>Application Folder-&gt;add-&gt;项目输出（主程序入口）</p><p><img src="https://bu.dusays.com/2025/03/13/67d2da3facb0a.png"></p><p>对主输出创建快捷方式，并将其拖动到User‘s Desktop内</p><p><img src="https://bu.dusays.com/2025/03/13/67d2da4f4073b.png"></p><p><strong>（4）打包发布</strong></p><p> 对setup1项目进行重新生成，即生成安装程序</p><p><img src="https://bu.dusays.com/2025/03/13/67d2da5f3f9fd.png"></p><h3 id="三，利用Enigma-Virtual-Box-单文件封装工具-进行打包"><a href="#三，利用Enigma-Virtual-Box-单文件封装工具-进行打包" class="headerlink" title="三，利用Enigma Virtual Box(单文件封装工具) 进行打包"></a><font color="FF0000">三，利用Enigma Virtual Box(单文件封装工具) 进行打包</font></h3><p>Enigma 虚拟文件打包系统可以将程序和配套文件打包成一个可执行文件，而没有任何效率的损失，配套文件也不会被释放至硬盘。（同时支持X86和X64二进制文件）。</p><p>如图：</p><p><img src="https://bu.dusays.com/2025/03/13/67d2da99e4610.png"></p><p><img src="https://bu.dusays.com/2025/03/13/67d2daa7c6d41.png"></p><p>将生成的GCtest_boxed文件复制到要运行的设备上即可（可以单独运行）</p><br><br><br><p><span style="color: red; font-size: 20px;">转载自：<a href="https://www.cnblogs.com/xyf327">唯有自己强大</a>          如有侵权，在下方评论  立刻删除。</span></p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt07鼠标事件</title>
      <link href="/2025/03/13/Qt07%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6/"/>
      <url>/2025/03/13/Qt07%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>个人认为，事件机制是Qt最难以理解且最为精妙的一部分。事件主要分为两种：</p><ol><li><strong>在与用户交互时发生</strong>。比如按下鼠标（mousePressEvent），敲击键盘（keyPressEvent）等。</li><li><strong>系统自动发生</strong>，比如计时器事件（timerEvent）等。</li></ol><p>在发生事件时（比如说上面说的按下鼠标），就会产生一个QEvent对象（这里是QMouseEvent，为QEvent的子类），这个QEvent对象会传给当前组件的event函数。如果当前组件没有安装<strong>事件过滤器</strong>（这个后面会提到），则会被event函数发放到相应的xxxEvent函数中（这里是mousePressEvent函数）。</p><p>需要区分的是：<strong>事件与信号并不相同。</strong></p><p>比如：鼠标单击按钮，鼠标事件（QMouseEvent），而按钮本身发射clicked（）信号。一般而言我们只需要关注单击信号，不用考虑鼠标事件。但是当我们要对该按钮做额外操作，不想通过信号处理，此时事件就是一个很好的选择。关闭事件（QCloseEvent）是一个常用的事件。</p><hr><h3 id="一，事件"><a href="#一，事件" class="headerlink" title="一，事件"></a><font color="FF0000">一，事件</font></h3><p>Qt 中所有事件类都继承于 QEvent。在事件对象创建完毕后，Qt 将这个事件对象传递给 QObject 的 event()函数。event()函数并不直接处理事件，而是按照事件对象的类型分派给特定的事件处理函数（eventhandler）。</p><p><img src="https://bu.dusays.com/2025/03/13/67d29bf3e8d89.png"></p><p>信号是通过connect（）来绑定槽函数处理响应，那么事件是怎么处理的呢？</p><p><strong>处理事件有5种常用的方法：</strong></p><ol><li>重新实现部件的paintEvent（）、mousePressEvent()等事件处理函数。这是最常用的一种方法，不过只能用来处理特定部件的特定事件（即需要新建类去实现）</li><li>重新实现notify（）函数。这个函数的功能强大，提供了完全的控制，可以再事件过滤器得到事件之间就获得他们。但是，它一次只能处理一个事件。</li><li>向QApplication对象上安装事件过滤器。因为一个程序只有一个QApplication对象，实现的功能和notify（）函数相同，优点是可以同时处理多个事件。</li><li>重新实现event（）函数。QObject类的event（）函数可以在事件达到默认事件处理函数之前获得该事件。</li><li>在对象上安装事件过滤器。使用事件过滤器可以再一个界面类中同时处理不同子部件的事件（在本类中实现）</li></ol><p>实际编程中最常用的是方法（1），其次是方法（5）。方法2要继承QApplication类，方法3需要全局的事件过滤器，减缓事件的传递。</p><p><strong>鼠标事件：</strong></p><p>常用的鼠标事件：（本篇处理事件用的是方法一：重写鼠标事件）</p><ul><li>void mousePressEvent(QMouseEvent *event);      &#x2F;&#x2F;单击</li><li>void mouseReleaseEvent(QMouseEvent *event);    &#x2F;&#x2F;释放</li><li>void mouseDoubleClickEvent(QMouseEvent *event); &#x2F;&#x2F;双击</li><li>void mouseMoveEvent(QMouseEvent *event);      &#x2F;&#x2F;移动</li><li>void wheelEvent(QWheelEvent *event);           &#x2F;&#x2F;滑轮</li></ul><p><strong>鼠标事件使用的时候，加头文件： #include <QMouseEvent></strong></p><p><strong>重写事件框架：</strong></p><p><strong>1️⃣鼠标按下事件</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::mousePressEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果是鼠标左键按下   </span></span><br><span class="line">    <span class="keyword">if</span>(event-&gt;<span class="built_in">button</span>() == Qt::LeftButton)&#123;</span><br><span class="line">        ···</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是鼠标右键按下</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(event-&gt;<span class="built_in">button</span>() == Qt::RightButton)&#123;</span><br><span class="line">       ···</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2️⃣鼠标移动事件</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::mouseMoveEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这里必须使用buttons()</span></span><br><span class="line">    <span class="keyword">if</span>(event-&gt;<span class="built_in">buttons</span>() &amp; Qt::LeftButton)&#123;  <span class="comment">//进行的按位与</span></span><br><span class="line">       ···</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下，触发事件需要点击一下，才能触发。可设置为自动触发:<strong>setMouseTracking(true);</strong> </p><p><strong>3️⃣鼠标释放事件</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::mouseReleaseEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4️⃣鼠标双击事件</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::mouseDoubleClickEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果是鼠标左键按下</span></span><br><span class="line">    <span class="keyword">if</span>(event-&gt;<span class="built_in">button</span>() == Qt::LeftButton)&#123;</span><br><span class="line">      </span><br><span class="line">        ···</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5️⃣滚轮事件</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::wheelEvent</span><span class="params">(QWheelEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 当滚轮远离使用者时</span></span><br><span class="line">    <span class="keyword">if</span>(event-&gt;<span class="built_in">delta</span>() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        ···</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//当滚轮向使用者方向旋转时</span></span><br><span class="line">        ···</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实例演示</strong>（在label控件中，移动鼠标获取实时位置，并显示在界面上）</p><ul><li><strong>创建mylabel类，基类设置为QLabel</strong></li></ul><p><img src="https://bu.dusays.com/2025/03/13/67d29c1584eb6.png"></p><p>这里用了类似自定义控件的方法，对Mylabel类进行封装。设置基类QLabel 是为了在ui界面中提升label控件（即将label控件和Mylabel关联，提升时候必须二者基类相同）</p><ul><li>在mylabel.h中声明鼠标事件</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;qlabel.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mylabel</span> : <span class="keyword">public</span> QLabel</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">mylabel</span>(QWidget* parent = <span class="number">0</span>);</span><br><span class="line">    ~<span class="built_in">mylabel</span>();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//鼠标移动事件</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mouseMoveEvent</span><span class="params">(QMouseEvent* event)</span></span>;</span><br><span class="line">    <span class="comment">//鼠标按下事件</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mousePressEvent</span><span class="params">(QMouseEvent* event)</span></span>;</span><br><span class="line">    <span class="comment">//鼠标释放事件</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mouseReleaseEvent</span><span class="params">(QMouseEvent* event)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>在mylabel.cpp中重写事件</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mylabel.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;QMouseEvent&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mylabel::<span class="built_in">mylabel</span>(QWidget* parent) :<span class="built_in">QLabel</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">mylabel::~<span class="built_in">mylabel</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//鼠标移动显示坐标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mylabel::mouseMoveEvent</span><span class="params">(QMouseEvent* event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event-&gt;<span class="built_in">buttons</span>() &amp; Qt::LeftButton)  <span class="comment">//进行的按位与（只有左键点击移动才满足）</span></span><br><span class="line">    &#123; </span><br><span class="line">        QString str = <span class="built_in">QString</span>(<span class="string">&quot;Move:(X:%1,Y:%2)&quot;</span>).<span class="built_in">arg</span>(event-&gt;<span class="built_in">x</span>()).<span class="built_in">arg</span>(event-&gt;<span class="built_in">y</span>());</span><br><span class="line">         <span class="keyword">this</span>-&gt;<span class="built_in">setText</span>(str);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//鼠标按下显示“ok，mouse is press”</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mylabel::mousePressEvent</span><span class="params">(QMouseEvent* event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">setText</span>(<span class="string">&quot;Ok, mouse is press&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//鼠标释放清除显示</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mylabel::mouseReleaseEvent</span><span class="params">(QMouseEvent* event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">setText</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在主函数（QTest.cpp）中声明mylabel的类对象（即声明一个mylabel类的label控件）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qtest.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">QTest::<span class="built_in">QTest</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    ui.<span class="built_in">setupUi</span>(<span class="keyword">this</span>);    <span class="comment">//声明mylabel类的控件</span></span><br><span class="line">    mylabel* label1 = <span class="keyword">new</span> <span class="built_in">mylabel</span>(<span class="keyword">this</span>);</span><br><span class="line">    label1-&gt;<span class="built_in">setGeometry</span>(<span class="built_in">QRect</span>(<span class="number">130</span>, <span class="number">100</span>, <span class="number">271</span>, <span class="number">161</span>));    <span class="comment">//设置边框</span></span><br><span class="line">    label1-&gt;<span class="built_in">setFrameShape</span>(QFrame::Panel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2025/03/13/67d29c2b5a2ed.png"></p><p> 另外，当调用<strong>setMouseTracking(true)</strong>;时（即设置鼠标状态为自动触发），需要将鼠标移动事件的if语句去掉（因为不需要点击触发了）</p><p><strong>修改maylabel.cpp事件：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mylabel.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;QMouseEvent&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mylabel::<span class="built_in">mylabel</span>(QWidget* parent) :<span class="built_in">QLabel</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//设置鼠标状态（自动触发）</span></span><br><span class="line">    <span class="built_in">setMouseTracking</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">mylabel::~<span class="built_in">mylabel</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//鼠标移动显示坐标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mylabel::mouseMoveEvent</span><span class="params">(QMouseEvent* event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   QString str = <span class="built_in">QString</span>(<span class="string">&quot;Move:(X:%1,Y:%2)&quot;</span>).<span class="built_in">arg</span>(event-&gt;<span class="built_in">x</span>()).<span class="built_in">arg</span>(event-&gt;<span class="built_in">y</span>());</span><br><span class="line">   <span class="keyword">this</span>-&gt;<span class="built_in">setText</span>(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//鼠标按下显示“ok，mouse is press”</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mylabel::mousePressEvent</span><span class="params">(QMouseEvent* event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">setText</span>(<span class="string">&quot;Ok, mouse is press&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//鼠标释放清除显示</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mylabel::mouseReleaseEvent</span><span class="params">(QMouseEvent* event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">setText</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果展示：</strong></p><p><img src="https://bu.dusays.com/2025/03/13/67d29c4cbb6f7.gif"></p><p><strong>😒这里用的是代码创建label控件，那么能不能用ui界面编辑然后在对label控件提升呢？</strong></p><p>答案是可以的，但是需要注意的是：<strong>此处不能选择全局包含</strong></p><p><img src="https://bu.dusays.com/2025/03/13/67d29c64cf2e2.png"></p><p> <strong>否则会出现：</strong></p><p><img src="https://bu.dusays.com/2025/03/13/67d29c7542d19.png"></p><p>我想其中的原因主要是因为：</p><p>本实例是新建了一个mylabel类，而不是像<a href="https://www.cnblogs.com/xyf327/p/15097726.html">QT常用控件（三）——自定义控件封装 - 唯有自己强大 - 博客园 (cnblogs.com)</a>这篇博文中直接新添加了一个设计师界面类（即包含ui .h .cpp)。当选择全局包含时，就包含了主类。</p><p>其实也有解决的办法：需要在提升界面的头文件处，将工程目录下自定义控件的地址放于此处</p><p><img src="https://bu.dusays.com/2025/03/13/67d29c8d1fe53.png"></p><h3 id="二，事件的分发：event函数"><a href="#二，事件的分发：event函数" class="headerlink" title=" 二，事件的分发：event函数"></a><font color="FF0000"> 二，事件的分发：event函数</font></h3><p>上面提到的xxxEvent函数，称为事件处理器（event handler）。而event函数的作用就在于事件的分发。如果想在事件的分发之前就进行一些操作，比如监听（<strong>阻塞</strong>）鼠标按下事件。</p><p> 如果希望在事件分发之前做一些操作，就可以重写这个 event()函数了。比如我们希望阻塞鼠标按下事件，那么我们就在新建的Mylabel类中重写event()函数（<strong>该类的父类是QLabel</strong>）</p><ul><li><strong>在Mylabel.h中声明event事件</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;qlabel.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mylabel</span> : <span class="keyword">public</span> QLabel</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Mylabel</span><span class="params">(QWidget* parent = <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//鼠标按下事件</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mousePressEvent</span><span class="params">(QMouseEvent* event)</span></span>; </span><br><span class="line">    <span class="comment">//鼠标释放事件</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mouseReleaseEvent</span><span class="params">(QMouseEvent* event)</span></span>;</span><br><span class="line">    <span class="comment">//声明event事件</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">event</span><span class="params">(QEvent* e)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>在Mylabel.cpp中重写event事件。</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Mylabel.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;QMouseEvent&quot;</span></span></span><br><span class="line"></span><br><span class="line">Mylabel::<span class="built_in">Mylabel</span>(QWidget* parent) :<span class="built_in">QLabel</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重写鼠标按下事件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Mylabel::mousePressEvent</span><span class="params">(QMouseEvent* event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setText</span>(<span class="built_in">QString</span>(<span class="string">&quot;mouse is press x:%1,y:%2&quot;</span>).<span class="built_in">arg</span>(event-&gt;<span class="built_in">x</span>()).<span class="built_in">arg</span>(event-&gt;<span class="built_in">y</span>()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重写鼠标释放事件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Mylabel::mouseReleaseEvent</span><span class="params">(QMouseEvent* event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setText</span>(<span class="string">&quot;mouse is release &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重写event事件</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Mylabel::event</span><span class="params">(QEvent* e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果鼠标按下，再事件分发中做拦截</span></span><br><span class="line">    <span class="keyword">if</span> (e-&gt;<span class="built_in">type</span>()==QEvent::MouseButtonPress)</span><br><span class="line">    &#123;        <span class="comment">//静态转换（将QEvent的对象转换为QMouseEvent对象）</span></span><br><span class="line">        QMouseEvent* event = <span class="built_in">static_cast</span>&lt;QMouseEvent*&gt;(e);</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">setText</span>(<span class="built_in">QString</span>(<span class="string">&quot;event mouse is press x:%1,y:%2&quot;</span>).<span class="built_in">arg</span>(event-&gt;<span class="built_in">x</span>()).<span class="built_in">arg</span>(event-&gt;<span class="built_in">y</span>()));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//返回ture，说明用户自己处理事件，不往下分发（即拦截上面的按下事件）</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> QLabel::<span class="built_in">event</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2025/03/13/67d29cb547ab2.png"></p><p>点击鼠标可以看到，触发的是event的事件（即阻塞了mousePressEvent的事件）。<strong>特别需要注意的是：在将不需要阻塞分发的时候，需要分发给父类的event函数处理。即（return QLable::event(e)；)</strong></p><p>由此可以见，event()是一个集中处理不同类型的事件的地方。如果你不想重写一大堆事件处理器，就可以重写这个 event()函数，通过 QEvent::type()判断不同的事件。鉴于重写 event()函数需要十分小心注意父类的同名函数的调用，一不留神就可能出现问题，所以一般还是建议只重写事件处理器（当然，也必须记得是不是应该调用父类的同名处理器）。</p><h3 id="三，事件过滤器（Even-Filter）"><a href="#三，事件过滤器（Even-Filter）" class="headerlink" title="三，事件过滤器（Even Filter）"></a><strong>三，事件过滤器（Even Filter）</strong></h3><p> 某些应用场景下，需要拦截某个组件发生的事件，让这个事件不再向其他组件进行传播，这时候可以为这个组件或其父组件安装一个事件过滤器，<strong>该过滤器在event分发之前进行拦截。</strong></p><p><strong>事件的过滤有两个步骤：</strong></p><p>1️⃣对QObject组件安装过滤器（<strong>调用installEvenFilter函数</strong>）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QObject::installEventFilter</span> <span class="params">( QObject * filterObj )</span></span>;</span><br></pre></td></tr></table></figure><p>参数filterobj 是指谁为组件安装过滤器（一般是父类）</p><ul><li>这个函数接受一个 QObject *类型的参数。记得刚刚我们说的，eventFilter()函数是 QObject 的一个成员函数，因此，任意 QObject 都可以作为事件过滤器（问题在于，如果你没有重写 eventFilter()函数，这个事件过滤器是没有任何作用的，因为默认什么都不会过滤）。已经存在的过滤器则可以通过**QObject::removeEventFilter()**函数移除。 </li><li>我们可以向一个对象上面安装多个事件处理器 ，只要调用多次installEventFilter()函数。如果一个对象存在多个事件过滤器，那么，最后一个安装的会第一个执行，也就是后进先执行的顺序。</li></ul><p>2️⃣事件过滤器的重写（<strong>evenFilter函数</strong>）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">QObject::eventFilter</span> <span class="params">( QObject * watched, QEvent * event )</span></span>;</span><br></pre></td></tr></table></figure><p>可以看到，函数有两个参数，一个为具体发生事件的组件，一个为发生的事件（产生的QEvent对象）。当事件是我们感兴趣的类型，可以就地进行处理，并令其不再转发给其他组件。函数的返回值也是bool类型，作用跟even函数类似，返回true为不再转发，false则让其继续被处理。</p><p><strong>实例</strong>：通过事件过滤器阻塞上面代码中的鼠标按下事件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qtest.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;qmouseevent&quot;</span></span></span><br><span class="line"></span><br><span class="line">QTest::<span class="built_in">QTest</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    ui.<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//第一步：给label添加过滤器</span></span><br><span class="line">    ui.label-&gt;<span class="built_in">installEventFilter</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二步：重写过滤事件</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QTest::eventFilter</span><span class="params">(QObject* obj, QEvent* e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == ui.label)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果鼠标按下，再事件分发中做拦截</span></span><br><span class="line">        <span class="keyword">if</span> (e-&gt;<span class="built_in">type</span>() == QEvent::MouseButtonPress)</span><br><span class="line">        &#123;</span><br><span class="line">            QMouseEvent* event = <span class="built_in">static_cast</span>&lt;QMouseEvent*&gt;(e);</span><br><span class="line">            ui.label-&gt;<span class="built_in">setText</span>(<span class="built_in">QString</span>(<span class="string">&quot;eventfilter mouse is press x:%1,y:%2&quot;</span>).<span class="built_in">arg</span>(event-&gt;<span class="built_in">x</span>()).<span class="built_in">arg</span>(event-&gt;<span class="built_in">y</span>()));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//返回ture，说明用户自己处理事件，不往下分发（即拦截上面的按下事件）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> QWidget::<span class="built_in">eventFilter</span>(obj, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重写鼠标按下事件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTest::mousePressEvent</span><span class="params">(QMouseEvent* event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ui.label-&gt;<span class="built_in">setText</span>(<span class="built_in">QString</span>(<span class="string">&quot;mouse is press x:%1,y:%2&quot;</span>).<span class="built_in">arg</span>(event-&gt;<span class="built_in">x</span>()).<span class="built_in">arg</span>(event-&gt;<span class="built_in">y</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重写事件分发</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QTest::event</span><span class="params">(QEvent* e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果鼠标按下，再事件分发中做拦截</span></span><br><span class="line">    <span class="keyword">if</span> (e-&gt;<span class="built_in">type</span>() == QEvent::MouseButtonPress)</span><br><span class="line">    &#123;</span><br><span class="line">        QMouseEvent* event = <span class="built_in">static_cast</span>&lt;QMouseEvent*&gt;(e);</span><br><span class="line">        ui.label-&gt;<span class="built_in">setText</span>(<span class="built_in">QString</span>(<span class="string">&quot;event mouse is press x:%1,y:%2&quot;</span>).<span class="built_in">arg</span>(event-&gt;<span class="built_in">x</span>()).<span class="built_in">arg</span>(event-&gt;<span class="built_in">y</span>()));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//返回ture，说明用户自己处理事件，不往下分发（即拦截上面的按下事件）</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> QWidget::<span class="built_in">event</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><p><img src="https://bu.dusays.com/2025/03/13/67d29ccad815a.png"></p><p>可以看到在过滤器事件中就监听了鼠标按压（即阻塞了后面的事件分发和鼠标按压）</p><h3 id="按钮长按事件"><a href="#按钮长按事件" class="headerlink" title="按钮长按事件"></a><font color="FF0000">按钮长按事件</font></h3><p>最近在做qt项目，需要对button按钮添加一个长按事件（比如点击按钮，开始运动。松开按钮，运动停止）。查了些许资料，（差点误把QPushButton的press信号和长按事件混淆）在此记录一下经验。</p><h4 id="setAutoRepeat"><a href="#setAutoRepeat" class="headerlink" title="setAutoRepeat"></a><font color="FF0000">setAutoRepeat</font></h4><p>以前一直以为QPushButton不支持长按，才发现还有这个功能。用起来很简单：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QPushButton *pBtnSub = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="keyword">this</span>);</span><br><span class="line">pBtnSub = <span class="built_in">setAutoRepeat</span>(<span class="literal">true</span>);  <span class="comment">//启动长按</span></span><br><span class="line">pBtnSub = <span class="built_in">setAutoRepeatDelay</span>(<span class="number">400</span>);  <span class="comment">// 触发长按时间</span></span><br><span class="line">pBtnSub = <span class="built_in">setAutoRepeatInterval</span>(<span class="number">50</span>);  <span class="comment">// 长按时click信号间隔</span></span><br><span class="line"><span class="built_in">connect</span>(pBtnSub,&amp;QPushButton::clicked,[&amp;]&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;send&quot;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>MouseEvent中没有repeat这个东西的，所以一个按钮被鼠标点击还能连续触发，那基本就是一个定时器做出来的。</p><p><strong>所以应该说是鼠标按下Delay时间后会启动一个多次触发的TimerEvent（定时器），由timeOut再次触发click槽。</strong></p><h4 id="QPushButton-点击信号分析"><a href="#QPushButton-点击信号分析" class="headerlink" title="QPushButton 点击信号分析"></a><font color="FF0000">QPushButton 点击信号分析</font></h4><p>再来分析一下QPushButton的点击信号。QPushButton有三个很重要的信号跟点击有关：</p><ul><li>pressed</li><li>clicked</li><li>toggled</li></ul><p>表面上看，pressed和clicked都会在点击按钮时触发，它们有什么区别呢？toggled好像有时候触发，有时候不触发，到底怎么回事呢？下面就一起聊一下这三个信号</p><p><strong>😊验证过程就不放了，直接给结论吧！</strong></p><p>首先，这三个信号都是从QAbstractButton继承来的，也就是说，下面情况对QAbstractButton的所有子类都适用</p><p><strong>结论：</strong></p><ol><li>pressed最先执行，相当于按下操作</li><li>按下之后，按钮状态发生变化，触发toggled</li><li>clicked最后执行，相当于弹起操作</li></ol><br><br><br><p><span style="color: red; font-size: 20px;">转载自：<a href="https://www.cnblogs.com/xyf327">唯有自己强大</a>          如有侵权，在下方评论  立刻删除。</span></p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt06定时器</title>
      <link href="/2025/03/13/Qt06%E5%AE%9A%E6%97%B6%E5%99%A8/"/>
      <url>/2025/03/13/Qt06%E5%AE%9A%E6%97%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>Qt中有两种方法来使用定时器，一种是定时器事件，另一种是使用信号和槽。</p><p>常使用信号和槽（代码看起来比较整洁）但是当使用多个定时器的时候最好用定时器事件来处理。 </p><h3 id="定时器方式一：定时器事件"><a href="#定时器方式一：定时器事件" class="headerlink" title="定时器方式一：定时器事件"></a><font color="FF0000">定时器方式一：定时器事件</font></h3><p><strong>需要</strong>： #include <QTimerEvent></p><p><strong>方式</strong>：</p><ul><li>利用对void timerEvent(QTimerEvent* e)事件的重写。</li><li>启动定时器 int QObject::startTimer ( int interval ) ;</li></ul><p>开启一个定时器，返回值为int类型。他的参数interval是毫秒级别。当开启成功后会返回这个定时器的ID, 并且每隔interval 时间后会进入timerEvent 函数。直到定时器被杀死（killTimer）</p><ul><li>timerEvent的返回值是定时器的唯一标识。可以和e-&gt;timerId比较</li><li>void killTimer(int id); &#x2F;&#x2F;停止 ID 为 id 的计时器，ID 由 startTimer()函数返回</li></ul><p><strong>实例</strong>：在两个label中自动计数，一个间隔为1秒，一个为2秒。</p><ul><li><strong>在头文件中先声明void timerEvent(QTimerEvent* e)事件</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtWidgets/QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_Qtcontrol.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Qtcontrol</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Qtcontrol</span>(QWidget *parent = Q_NULLPTR);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//重写定时器事件</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">timerEvent</span><span class="params">(QTimerEvent* e)</span></span>;</span><br><span class="line">    <span class="type">int</span> ID1;</span><br><span class="line">    <span class="type">int</span> ID2;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::QtcontrolClass ui;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>在源文件中实现</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Qtcontrol.h&quot;</span></span></span><br><span class="line">Qtcontrol::<span class="built_in">Qtcontrol</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    ui.<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//启动定时器</span></span><br><span class="line"> ID1=   <span class="built_in">startTimer</span>(<span class="number">1000</span>);<span class="comment">//启动定时器事件,创建一个定时器并返回定时器ID</span></span><br><span class="line"><span class="comment">//参数：单位毫秒---每隔n毫秒时间，就执行一次定时器事件</span></span><br><span class="line"><span class="comment">//返回值：定时器ID号</span></span><br><span class="line"> ID2 = <span class="built_in">startTimer</span>(<span class="number">2000</span>);<span class="comment">//两秒启动一次</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Qtcontrol::timerEvent</span><span class="params">(QTimerEvent* e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e-&gt;<span class="built_in">timerId</span>()==ID1)</span><br><span class="line">    &#123;</span><br><span class="line">   <span class="type">static</span> <span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">    ui.label-&gt;<span class="built_in">setText</span>(QString::<span class="built_in">number</span>(num++));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e-&gt;<span class="built_in">timerId</span>()==ID2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">        ui.label_2 -&gt;<span class="built_in">setText</span>(QString::<span class="built_in">number</span>(num++));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于所有的事件都重写在了timerEvent中，因此当需要多个定时器时，可以用定时器的ID去对应timerEvent中的事件。</p><h3 id="定时器方式二：QTimer类（信号与槽）"><a href="#定时器方式二：QTimer类（信号与槽）" class="headerlink" title="定时器方式二：QTimer类（信号与槽）"></a><font color="FF0000">定时器方式二：QTimer类（信号与槽）</font></h3><p><strong>需要</strong> ： #include <QTimer></p><p><strong>方式：</strong></p><ol><li>利用定时器类QTimer</li><li>创建定时器对象 QTimer *timer&#x3D;new QTimer(this)</li><li>启动定时器timer-&gt;start( 500） &#x2F;&#x2F;参数：每隔n毫秒发送一个信号（timeout）</li><li>用connect连接信号和槽函数（自定义槽）</li><li>暂停 timer-&gt;stop</li></ol><p><strong>实例</strong>：启动label 每隔0.5秒计时</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Qtcontrol.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;qtimer.h&quot;</span></span></span><br><span class="line">Qtcontrol::<span class="built_in">Qtcontrol</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    ui.<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">QTimer* timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//启动定时器</span></span><br><span class="line">timer-&gt;<span class="built_in">start</span>(<span class="number">500</span>);<span class="comment">//每隔0.5秒会发一个信号</span></span><br><span class="line"><span class="built_in">connect</span>(timer, &amp;QTimer::timeout, [=]() &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">    ui.label-&gt;<span class="built_in">setText</span>(QString::<span class="built_in">number</span>(num++));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><br><p><span style="color: red; font-size: 20px;">转载自：<a href="https://www.cnblogs.com/xyf327">唯有自己强大</a>          如有侵权，在下方评论  立刻删除。</span></p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt05多线程和线程池</title>
      <link href="/2025/03/13/Qt05%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2025/03/13/Qt05%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="一，-最简单的多线程QtConcurrent-run"><a href="#一，-最简单的多线程QtConcurrent-run" class="headerlink" title=" 一， 最简单的多线程QtConcurrent::run()"></a><font color="FF0000"> 一， 最简单的多线程QtConcurrent::run()</font></h3><ul><li><strong>其函数原型如下：</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QFuture&lt;T&gt; <span class="title">QtConcurrent::run</span><span class="params">(Function function, ...)</span></span></span><br><span class="line"><span class="function">QFuture&lt;T&gt; <span class="title">QtConcurrent::run</span><span class="params">(QThreadPool *pool, Function function, ...)</span></span></span><br></pre></td></tr></table></figure><p>参数function需要外部函数：（或者lambda函数），后面也可跟外部函数的参数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">func</span><span class="params">(QString str)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>QtConcurrent :: run（）也接受指向成员函数的指针</strong>。第一个参数必须是一个const引用或一个指向该类实例的指针。const成员函数一般传递 常量引用 (const reference)，而非常量成员函数一般传递 指针 (pointer)</p><ul><li><strong>在VS环境中需要引用：</strong> <strong>#include”QtConcurrent&#x2F;qtconcurrentrun.h”</strong></li></ul><p>简单的说，QtConcurrent::run()函数会在一个单独的线程中执行，并且该线程取自全局QThreadPool，该函数的返回值通过QFuture API提供。<br>请注意：该函数可能不会立即运行; 函数只有在线程可用时才会运行。通过QtConcurrent::run()返回的QFuture不支持取消、暂停，返回的QFuture只能用于查询函数的运行&#x2F;完成状态和返回值。</p><ul><li><strong>实例：实现多线程耗时操作（调用成员函数）</strong></li></ul><p>在主程序threadtest.h中声明成员函数（并添加引用）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtWidgets/QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_threadtest.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;workThread.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;qthread.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;QtConcurrent/qtconcurrentrun.h&quot;</span><span class="comment">//QtConcurrent引用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> execution_character_set(<span class="string">&quot;utf-8&quot;</span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Threadtest</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Threadtest</span>(QWidget *parent = Q_NULLPTR);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::ThreadtestClass ui;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span>;<span class="comment">//成员函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在主程序threadtest.cpp中调用成员函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;threadtest.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;qdebug.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Threadtest::<span class="built_in">Threadtest</span>(QWidget* parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    ui.<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">connect</span>(ui.btn_start, &amp;QPushButton::clicked, [=]()</span><br><span class="line">        &#123;        <span class="comment">//将成员函数放入参数中（成员函数需要引用指针）</span></span><br><span class="line">            QtConcurrent::<span class="built_in">run</span>(<span class="keyword">this</span>, &amp;Threadtest::work);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Threadtest::work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;子线程运行：&quot;</span> &lt;&lt; QThread::<span class="built_in">currentThreadId</span>();</span><br><span class="line">    QThread::<span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;子线程结束：&quot;</span> &lt;&lt; QThread::<span class="built_in">currentThreadId</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击按钮即可触发子线程运行。</p><p><img src="https://bu.dusays.com/2025/03/13/67d2d70d1e369.png"></p><ul><li><strong>实例：实现多线程耗时操作（调用外部函数，带参数）</strong></li></ul><p>在主程序threadtest.h中声明外部函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtWidgets/QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_threadtest.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;workThread.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;qthread.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;QtConcurrent/qtconcurrentrun.h&quot;</span><span class="comment">//QtConcurrent引用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> execution_character_set(<span class="string">&quot;utf-8&quot;</span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Threadtest</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Threadtest</span>(QWidget *parent = Q_NULLPTR);  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::ThreadtestClass ui;</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">func</span><span class="params">(QString str)</span></span>;<span class="comment">//外部函数</span></span><br></pre></td></tr></table></figure><p>在主程序threadtest.cpp中调用外部函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;threadtest.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;qdebug.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Threadtest::<span class="built_in">Threadtest</span>(QWidget* parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    ui.<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">connect</span>(ui.btn_start, &amp;QPushButton::clicked, [=]()</span><br><span class="line">        &#123;</span><br><span class="line">            QtConcurrent::<span class="built_in">run</span>(func,<span class="built_in">QString</span>(<span class="string">&quot;extern&quot;</span>));</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(QString str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;子线程运行：&quot;</span> &lt;&lt; QThread::<span class="built_in">currentThreadId</span>()&lt;&lt; str;</span><br><span class="line">    QThread::<span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;子线程结束：&quot;</span> &lt;&lt; QThread::<span class="built_in">currentThreadId</span>()&lt;&lt; str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2025/03/13/67d2d72cb57a3.png"></p><h3 id="二，线程池"><a href="#二，线程池" class="headerlink" title="二，线程池"></a><font color="FF0000">二，线程池</font></h3><h4 id="2-1-线程池原理"><a href="#2-1-线程池原理" class="headerlink" title="2.1 线程池原理"></a><font color="FF0000">2.1 线程池原理</font></h4><p>我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题：如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。</p><p>那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务呢？</p><p><strong>线程池</strong>是一种多线程处理形式，<strong>处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务</strong>。线程池线程都是后台线程。每个线程都使用默认的堆栈大小，以默认的优先级运行，并处于多线程单元中。如果某个线程在托管代码中空闲（如正在等待某个事件）, 则线程池将插入另一个辅助线程来使所有处理器保持繁忙。如果所有线程池线程都始终保持繁忙，但队列中包含挂起的工作，则线程池将在一段时间后创建另一个辅助线程但线程的数目永远不会超过最大值。超过最大值的线程可以排队，但他们要等到其他线程完成后才启动。</p><p><img src="https://bu.dusays.com/2025/03/13/67d2d7749a097.png"></p><h4 id="2-2-QRunnable"><a href="#2-2-QRunnable" class="headerlink" title="2.2 QRunnable"></a><font color="FF0000">2.2 QRunnable</font></h4><p>在 Qt 中使用线程池需要先创建任务，添加到线程池中的每一个任务都需要是一个 QRunnable 类型，因此在程序中需要创建子类继承 QRunnable 这个类，然后重写 run() 方法，在这个函数中编写要在线程池中执行的任务，并将这个子类对象传递给线程池，这样任务就可以被线程池中的某个工作的线程处理掉了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在子类中必须要重写的函数, 里边是任务的处理流程</span></span><br><span class="line">[pure <span class="keyword">virtual</span>] <span class="function"><span class="type">void</span> <span class="title">QRunnable::run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数设置为 true: 这个任务对象在线程池中的线程中处理完毕, 这个任务对象就会自动销毁</span></span><br><span class="line"><span class="comment">// 参数设置为 false: 这个任务对象在线程池中的线程中处理完毕, 对象需要程序猿手动销毁</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QRunnable::setAutoDelete</span><span class="params">(<span class="type">bool</span> autoDelete)</span></span>;</span><br><span class="line"><span class="comment">// 获取当前任务对象的析构方式,返回true-&gt;自动析构, 返回false-&gt;手动析构</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QRunnable::autoDelete</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p>例如：创建一个要添加到线程池中的任务类，处理方式如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyWork</span> : <span class="keyword">public</span> QObject, <span class="keyword">public</span> QRunnable</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyWork</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 任务执行完毕,该对象自动销毁</span></span><br><span class="line">        <span class="built_in">setAutoDelete</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">MyWork</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在上面的示例中 MyWork 类是一个多重继承，如果需要在这个任务中使用 Qt 的信号槽机制进行数据的传递就必须继承 QObject 这个类，如果不使用信号槽传递数据就可以不继承了，只继承 QRunnable 即可。</strong></p><h4 id="2-3-QThreadPool"><a href="#2-3-QThreadPool" class="headerlink" title="2.3 QThreadPool"></a><font color="FF0000">2.3 QThreadPool</font></h4><p>Qt 中的 QThreadPool 类管理了一组 QThreads, 里边还维护了一个任务队列。QThreadPool 管理和回收各个 QThread 对象，以帮助减少使用线程的程序中的线程创建成本。每个Qt应用程序都有一个全局 QThreadPool 对象，可以通过调用 globalInstance() 来访问它。也可以单独创建一个 QThreadPool 对象使用。</p><p>线程池常用的 API 函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取和设置线程中的最大线程个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxThreadCount</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setMaxThreadCount</span><span class="params">(<span class="type">int</span> maxThreadCount)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给线程池添加任务, 任务是一个 QRunnable 类型的对象</span></span><br><span class="line"><span class="comment">// 如果线程池中没有空闲的线程了, 任务会放到任务队列中, 等待线程处理</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QThreadPool::start</span><span class="params">(QRunnable * runnable, <span class="type">int</span> priority = <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="comment">// 如果线程池中没有空闲的线程了, 直接返回值, 任务添加失败, 任务不会添加到任务队列中</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QThreadPool::tryStart</span><span class="params">(QRunnable * runnable)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池中被激活的线程的个数(正在工作的线程个数)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QThreadPool::activeThreadCount</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试性的将某一个任务从线程池的任务队列中删除, 如果任务已经开始执行就无法删除了</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QThreadPool::tryTake</span><span class="params">(QRunnable *runnable)</span></span>;</span><br><span class="line"><span class="comment">// 将线程池中的任务队列里边没有开始处理的所有任务删除, 如果已经开始处理了就无法通过该函数删除了</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QThreadPool::clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在每个Qt应用程序中都有一个全局的线程池对象, 通过这个函数直接访问这个对象</span></span><br><span class="line"><span class="function"><span class="type">static</span> QThreadPool * <span class="title">QThreadPool::globalInstance</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>一般情况下，我们不需要在 Qt 程序中创建线程池对象，直接使用 Qt 为每个应用程序提供的线程池全局对象即可。得到线程池对象之后，调用 start() 方法就可以将一个任务添加到线程池中，这个任务就可以被线程池内部的线程池处理掉了，使用线程池比自己创建线程的这种多种多线程方式更加简单和易于维护。</p><p><strong>具体的使用方式如下：</strong></p><ul><li><strong>mywork.h</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyWork</span> :<span class="keyword">public</span> QRunnable</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyWork</span><span class="params">()</span></span>;</span><br><span class="line">    ~<span class="built_in">MyWork</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>mywork.cpp</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MyWork::<span class="built_in">MyWork</span>() : <span class="built_in">QRunnable</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 任务执行完毕,该对象自动销毁</span></span><br><span class="line">    <span class="built_in">setAutoDelete</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyWork::run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 业务处理代码</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>mainwindow.cpp</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent) :</span><br><span class="line">    <span class="built_in">QMainWindow</span>(parent),</span><br><span class="line">    <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程池初始化，设置最大线程池数</span></span><br><span class="line">    QThreadPool::<span class="built_in">globalInstance</span>()-&gt;<span class="built_in">setMaxThreadCount</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="comment">// 添加任务</span></span><br><span class="line">    MyWork* task = <span class="keyword">new</span> MyWork;</span><br><span class="line">    QThreadPool::<span class="built_in">globalInstance</span>()-&gt;<span class="built_in">start</span>(task);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此看见，线程池的操作和QThread的run重写类似。<strong>使用线程池可以最大限度的利用线程，减少资源的浪费</strong></p><p><strong>比如我们需要同时处理三个事件</strong>：生成随机数，冒泡排序，快速排序（先生成随机数，然后再对其同时进行冒泡排序和快速排序）</p><p>用QThread的run重写的话，需要开启三个线程。</p><p>但是用线程池的话，它可以根据事件的长短，（将生成随机数和冒泡排序放在同一个线程去处理）只需要开启两个线程即可。</p><br><br><br><p><span style="color: red; font-size: 20px;">转载自：<a href="https://www.cnblogs.com/xyf327">唯有自己强大</a>          如有侵权，在下方评论  立刻删除。</span></p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt04多线程</title>
      <link href="/2025/03/13/Qt04%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2025/03/13/Qt04%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="一、知识回顾"><a href="#一、知识回顾" class="headerlink" title="一、知识回顾"></a><font color="FF0000">一、知识回顾</font></h3><p><strong>1，为什么需要多线程？</strong></p><ul><li><font color="FF0000">从计算机底层来说</font>： 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。 </li><li><font color="FF0000">从当代互联网发展趋势来说</font><strong>：</strong> 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</li></ul><p>再深入到计算机底层来探讨：</p><ul><li><font color="FF0000">单核时代</font>：在单核时代多线程主要是为了提高 CPU 和 IO 设备的综合利用率。举个例子：当只有一个线程的时候会导致 CPU 计算时，IO 设备空闲；进行 IO 操作时，CPU 空闲。我们可以简单地说这两者的利用率目前都是 50%左右。但是当有两个线程的时候就不一样了，当一个线程执行 CPU 计算时，另外一个线程可以进行 IO 操作，这样两个的利用率就可以在理想情况下达到 100%了。 </li><li><font color="FF0000">多核时代</font>: 多核时代多线程主要是为了提高 CPU 利用率。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，CPU 只会一个 CPU 核心被利用到，而创建多个线程就可以让多个 CPU 核心被利用到，这样就提高了 CPU 的利用率。</li></ul><p><strong>2，进程和线程的区别：</strong></p><p>进程：一个独立的程序，拥有独立的虚拟地址空间，要和其他进程通信，需要使用进程通信的机制。</p><p>线程：没有自己的资源，都是共享进程的虚拟地址空间，多个线程通信存在隐患。</p><p>PS：在操作系统每一个进程都拥有独立的内存空间，线程的开销远小于进程，一个进程可以拥有多个线程。（因此我们常用多线程并发，而非多进程并发）</p><p>为了更容易理解多线程的作用，先看一个实例：</p><p>在主线程中运行一个10s耗时的操作。（通过按钮来触发）</p><p><img src="https://bu.dusays.com/2025/03/13/67d28d3da16f3.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;threadtest.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;qthread.h&quot;</span></span></span><br><span class="line">Threadtest::<span class="built_in">Threadtest</span>(QWidget* parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    ui.<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">connect</span>(ui.btn_start, &amp;QPushButton::clicked, <span class="keyword">this</span>,  </span><br><span class="line">            &amp;Threadtest::on_pushButton_clicked);</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Threadtest::on_pushButton_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QThread::<span class="built_in">sleep</span>(<span class="number">10</span>);<span class="comment">//主线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到程序运行过程中，整个线程都在响应10秒的耗时操作，对于线程的消息循环exec()函数就未响应了（就是你在这个过程中拖动界面是无反应的）</p><p><img src="https://bu.dusays.com/2025/03/13/67d28db830489.png"></p><h3 id="二、线程类QThread"><a href="#二、线程类QThread" class="headerlink" title="二、线程类QThread"></a><font color="FF0000">二、线程类QThread</font></h3><p>Qt 中提供了一个线程类，通过这个类就可以创建子线程了，Qt 中一共提供了两种创建子线程的方式，后边会依次介绍其使用方式。先来看一下这个类中提供的一些常用 API 函数：</p><ul><li><strong>2.1 常用共用成员函数</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// QThread 类常用 API</span></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">QThread::<span class="built_in">QThread</span>(QObject *parent = Q_NULLPTR);</span><br><span class="line"><span class="comment">// 判断线程中的任务是不是处理完毕了</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QThread::isFinished</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 判断子线程是不是在执行任务</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QThread::isRunning</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Qt中的线程可以设置优先级</span></span><br><span class="line"><span class="comment">// 得到当前线程的优先级</span></span><br><span class="line"><span class="function">Priority <span class="title">QThread::priority</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QThread::setPriority</span><span class="params">(Priority priority)</span></span>;</span><br><span class="line">优先级:</span><br><span class="line">    QThread::IdlePriority        --&gt; 最低的优先级</span><br><span class="line">    QThread::LowestPriority</span><br><span class="line">    QThread::LowPriority</span><br><span class="line">    QThread::NormalPriority</span><br><span class="line">    QThread::HighPriority</span><br><span class="line">    QThread::HighestPriority</span><br><span class="line">    QThread::TimeCriticalPriority</span><br><span class="line">    QThread::InheritPriority    --&gt; 最高的优先级, 默认是这个</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 退出线程, 停止底层的事件循环</span></span><br><span class="line"><span class="comment">// 退出线程的工作函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QThread::exit</span><span class="params">(<span class="type">int</span> returnCode = <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="comment">// 调用线程退出函数之后, 线程不会马上退出因为当前任务有可能还没有完成, 调回用这个函数是</span></span><br><span class="line"><span class="comment">// 等待任务完成, 然后退出线程, 一般情况下会在 exit() 后边调用这个函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QThread::wait</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> time = ULONG_MAX)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><strong>2.2 信号槽</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 和调用 exit() 效果是一样的</span></span><br><span class="line"><span class="comment">// 调用这个函数之后, 再调用 wait() 函数</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QThread::quit</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 启动子线程</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QThread::start</span><span class="params">(Priority priority = InheritPriority)</span></span>;</span><br><span class="line"><span class="comment">// 线程退出, 可能是会马上终止线程, 一般情况下不使用这个函数</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QThread::terminate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程中执行的任务完成了, 发出该信号</span></span><br><span class="line"><span class="comment">// 任务函数中的处理逻辑执行完毕了</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QThread::finished</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 开始工作之前发出这个信号, 一般不使用</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QThread::started</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li><strong>2.3静态函数</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个指向管理当前执行线程的QThread的指针</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QThread *<span class="title">QThread::currentThread</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 返回可以在系统上运行的理想线程数 == 和当前电脑的 CPU 核心数相同</span></span><br><span class="line">[<span class="type">static</span>] <span class="function"><span class="type">int</span> <span class="title">QThread::idealThreadCount</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 线程休眠函数</span></span><br><span class="line">[<span class="type">static</span>] <span class="function"><span class="type">void</span> <span class="title">QThread::msleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> msecs)</span></span>;    <span class="comment">// 单位: 毫秒</span></span><br><span class="line">[<span class="type">static</span>] <span class="function"><span class="type">void</span> <span class="title">QThread::sleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> secs)</span></span>;    <span class="comment">// 单位: 秒</span></span><br><span class="line">[<span class="type">static</span>] <span class="function"><span class="type">void</span> <span class="title">QThread::usleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> usecs)</span></span>;    <span class="comment">// 单位: 微秒</span></span><br></pre></td></tr></table></figure><h3 id="三、Qt中实现多线程的两种方法"><a href="#三、Qt中实现多线程的两种方法" class="headerlink" title="三、Qt中实现多线程的两种方法"></a><font color="FF0000">三、Qt中实现多线程的两种方法</font></h3><p><strong>🧡🧡3.1.派生QThread类对象的方法（重写Run函数）</strong></p><p>首先，以文字形式来说明需要哪几个步骤。</p><ol><li>自定义一个自己的类，使其继承自QThread类；</li><li>在自定义类中覆写QThread类中的虚函数run()。</li></ol><p>这很可能就是C++中多态的使用。补充一点：QThread类继承自QObject类。</p><p>这里要重点说一下run()函数了。它作为线程的入口，也就是线程从run()开始执行，我们打算在线程中完成的工作都要写在run()函数中，个人认为可以把run()函数理解为线程函数。这也就是子类覆写基类的虚函数，基类QThread的run()函数只是简单启动exec()消息循环，关于这个exec()后面有很多东西要讲，请做好准备。<br>那么我们就来尝试用多线程实现10s耗时的操作：（用按钮触发)</p><ul><li><strong>1️⃣在编辑好ui界面后，先创建一个workThread的类。（继承自QThread类)</strong></li></ul><p><img src="https://bu.dusays.com/2025/03/13/67d2986e707f0.png"></p><ul><li>2️⃣<strong>在workThread1的类中重写run函数</strong></li></ul><p>在workThread.h的声明run函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;qthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">workThread</span> : <span class="keyword">public</span> QThread</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在workThread.cpp中重写run函数(并打印子线程的ID)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;workThread.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;qdebug.h&quot;</span></span></span><br><span class="line">workThread::<span class="built_in">workThread</span>(QObject* parent)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重写run函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">workThread::run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;当前子线程ID:&quot;</span> &lt;&lt; QThread::<span class="built_in">currentThreadId</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;开始执行线程&quot;</span>;</span><br><span class="line">    QThread::<span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;线程结束&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>3️⃣在主类中启动线程</strong></li></ul><p>threadtest.h中声明线程和按钮事件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtWidgets/QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_threadtest.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;workThread.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> execution_character_set(<span class="string">&quot;utf-8&quot;</span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Threadtest</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Threadtest</span>(QWidget *parent = Q_NULLPTR);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::ThreadtestClass ui;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">btn_clicked</span><span class="params">()</span></span>;</span><br><span class="line">workThread* thread;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>threadtest.cpp中实现，并启动子线程线程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;threadtest.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qthread.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qdebug.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Threadtest::<span class="built_in">Threadtest</span>(QWidget* parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    ui.<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">connect</span>(ui.btn_start, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;Threadtest::btn_clicked);</span><br><span class="line">   thread = <span class="keyword">new</span> <span class="built_in">workThread</span>(<span class="keyword">this</span>);  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Threadtest::btn_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;主线程id：&quot;</span> &lt;&lt; QThread::<span class="built_in">currentThreadId</span>();</span><br><span class="line">    thread-&gt;<span class="built_in">start</span>();<span class="comment">//启动子线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以实现，在执行耗时操作时也可拖动界面。</p><p><img src="https://bu.dusays.com/2025/03/13/67d28d3da16f3.png"></p><p><img src="https://bu.dusays.com/2025/03/13/67d298c015337.png"></p><p><strong>需要注意的是：</strong></p><p><strong>在主程序中添加workThread类的头文件时，需要将workThread.h放在threadtest.h中（不然会报错！！！！）</strong></p><p><img src="https://bu.dusays.com/2025/03/13/67d298dace251.png"></p><p>使用QThread::currentThreadId()来查看当前线程的ID，无论是子线程还是主线程，不同线程其ID是不同的。注意，这是一个静态函数，因此可以不经过对象来调用。</p><p><strong>创建的workThread1类的执行实际上是在主线程里的，只有run函数内的程序才会在子线程中执行！（即QThread只是线程的管理类，只有run()才是我们的线程函数）</strong></p><p>因此在QThread（即创建的类）中的成员变量属于主线程，在访问前需要判断访问是否安全。run（）中创建的变量属于子线程。</p><p>线程之间共享内存是不安全的（由于多线程争夺资源会影响数据安全问题），解决的办法就是要上锁。</p><p><strong><p align = "center">关于互斥锁</p></strong></p><p>个人认为，exec()这个点太重要了，同时还不太容易理解。</p><p>比如下面的代码中有两个exec()，我们讲“一山不容二虎”，放在这里就是说，一个线程中不能同时运行两个exec()，否则就会造成另一个消息循环得不到消息。像QDialog模态窗口中的exec()就是因为在主线程中同时开了两个exec()，导致主窗口的exec()接收不到用户的消息了。但是！但是！但是！我们这里却没有任何问题，因为它们没有出现在同一个线程中，一个是主线程中的exec()，一个是子线程中的exec()。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QThread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span>:<span class="keyword">public</span> QThread</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;child thread begin&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;child thread&quot;</span>&lt;&lt;QThread::<span class="built_in">currentThreadId</span>()&lt;&lt;endl;</span><br><span class="line">            QThread::<span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">            <span class="built_in">qDebugu</span>()&lt;&lt;<span class="string">&quot;QThread end&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">exec</span>();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> ** argv)</span> <span class="comment">//mian()作为主线程</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc,argv)</span></span>;</span><br><span class="line"> </span><br><span class="line">    MyThread thread; <span class="comment">//创建一个QThread派生类对象就是创建了一个子线程</span></span><br><span class="line">    thread.<span class="built_in">start</span>(); <span class="comment">//启动子线程，然后会自动调用线程函数run()</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;main thread&quot;</span>&lt;&lt;QThread::<span class="built_in">currentThreadId</span>()&lt;&lt;endl;</span><br><span class="line">    QThread::<span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">qDebugu</span>()&lt;&lt;<span class="string">&quot;main thread&quot;</span>&lt;&lt;QThread::<span class="built_in">currentThreadId</span>()&lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">    thread.<span class="built_in">quit</span>(); <span class="comment">//使用quit()或者exit()使得子线程能够退出消息循环，而不至于陷在子线程中</span></span><br><span class="line">    thread.<span class="built_in">wait</span>(); <span class="comment">//等待子线程退出，然后回收资源</span></span><br><span class="line">                   <span class="comment">//thread.wait(5000); //设定等待的时间</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果run()函数中没有执行exec()消息循环函数，那么run()执行完了也就意味着子线程退出了。一般在子线程退出的时候需要主线程去回收资源，可以调用QThread的wait()，使主线程等待子线程退出，然后回收资源。这里wait()是一个阻塞函数，有点像C++11中的join()函数。</p><p>但是！但是！但是！run()函数中调用了exec()函数，exec()是一个消息循环，也可以叫做事件循环，也是会阻塞的，相当于一个死循环使子线程卡在这里永不退出，必须调用QThread的quit()函数或者exit()函数才可以使子线程退出消息循环，并且有时还不是马上就退出，需要等到CPU的控制权交给线程的exec()。</p><p>所以先要thread.quit();使退出子线程的消息循环， 然后thread.wait();在主线程中回收子线程的资源。</p><p><strong>值得注意的有两点</strong>：子线程的exet()消息循环必须在run()函数中调用；如果没有消息循环的话，则没有必要调用quit( )或者exit()，因为调用了也不会起作用。</p><p>第一种创建线程的方式需要在run()中显式调用exec()，但是exec()有什么作用呢，目前还看不出来，需要在第二种创建线程的方式中才能知道。</p><hr><p> <strong>💜💜3.2.使用信号与槽方式来实现多线程</strong></p><p> 刚讲完使用QThread派生类对象的方法创建线程，现在就要来说它一点坏话。这种方法存在一个局限性，只有一个run()函数能够在线程中去运行，但是当有多个函数在同一个线程中运行时，就没办法了，至少实现起来很麻烦。所以，当当当当，下面将介绍第二种创建线程的方式：<strong>使用信号与槽的方式，也就是把在线程中执行的函数（我们可以称之为线程函数）定义为一个槽函数。</strong></p><p>仍然是首先以文字形式说明这种方法的几个步骤。</p><ul><li>创建一个新的类(mywork)，让这个类从 QObject 派生，在这个类中添加一个公共的成员函数(working)，函数体就是我们要子线程中执行的业务逻辑</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyWork</span>:<span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    .......</span><br><span class="line">    <span class="comment">// 函数名自己指定, 叫什么都可以, 参数可以根据实际需求添加</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">working</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在主线程中创建一个 QThread 对象，这就是子线程的对象</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QThread* sub = <span class="keyword">new</span> QThread;</span><br></pre></td></tr></table></figure><ul><li>在主线程中创建工作的类对象（千万不要指定给创建的对象指定父对象）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyWork* work = <span class="keyword">new</span> <span class="built_in">MyWork</span>(<span class="keyword">this</span>);    <span class="comment">// error</span></span><br><span class="line">MyWork* work = <span class="keyword">new</span> MyWork;          <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><ul><li>将 MyWork 对象移动到创建的子线程对象中，需要调用 QObject 类提供的 moveToThread() 方法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// void QObject::moveToThread(QThread *targetThread);</span></span><br><span class="line"><span class="comment">// 如果给work指定了父对象, 这个函数调用就失败了</span></span><br><span class="line"><span class="comment">// 提示： QObject::moveToThread: Cannot move objects with a parent</span></span><br><span class="line">work-&gt;<span class="built_in">moveToThread</span>(sub);    <span class="comment">// 移动到子线程中工作</span></span><br></pre></td></tr></table></figure><ul><li>启动子线程，调用 start(), 这时候线程启动了，但是移动到线程中的对象并没有工作</li><li>调用 MyWork 类对象的工作函数，让这个函数开始执行，这时候是在移动到的那个子线程中运行的</li></ul><p><strong>代码实例：</strong></p><ul><li>1️⃣<strong>创建一个workThread的类。（继承自QThread类）</strong></li></ul><p>定义槽函数（<strong>子线程执行的程序都可以放在槽函数中</strong>）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//workThread.cpp（先在workThread.h中声明槽函数）void workThread:: doWork()</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;当前线程ID:&quot;</span>&lt;&lt;QThread::<span class="built_in">currentThreadId</span>();</span><br><span class="line">      <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;开始执行&quot;</span>;</span><br><span class="line">      QThread::<span class="built_in">sleep</span>(<span class="number">10</span>);    </span><br><span class="line">      <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;结束执行&quot;</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>2️⃣<strong>主线程中分别对workThread类和QTread类实例化</strong></li></ul><p>在threadtest.h中声明</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtWidgets/QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_threadtest.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;workThread.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;qthread.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> execution_character_set(<span class="string">&quot;utf-8&quot;</span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Threadtest</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Threadtest</span>(QWidget *parent = Q_NULLPTR);  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::ThreadtestClass ui;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">btn_clicked</span><span class="params">()</span></span>;</span><br><span class="line">    workThread* thread; <span class="comment">//实例化workThread类</span></span><br><span class="line">    QThread* qthread;   <span class="comment">//实例化QThread类</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在threadtest.cpp中实现<strong>并通过moveToThread将自己放到线程QThread对象中，最后启动线程</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;threadtest.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;qthread.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;qdebug.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Threadtest::<span class="built_in">Threadtest</span>(QWidget* parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    ui.<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//不能指定自定义类的对象的父类为widget，即没有this（很重要！！！！）</span></span><br><span class="line">   thread = <span class="keyword">new</span> <span class="built_in">workThread</span>();  </span><br><span class="line">   qthread1 = <span class="keyword">new</span> <span class="built_in">QThread</span>(<span class="keyword">this</span>);</span><br><span class="line">   thread-&gt;<span class="built_in">moveToThread</span>(qthread1);</span><br><span class="line">   <span class="comment">//线程结束时清理线程内存</span></span><br><span class="line">   <span class="built_in">connect</span>(qthread1, &amp;QThread::finished, qthread1, &amp;QThread::deleteLater);</span><br><span class="line">   <span class="comment">//将按钮事件（信号）绑定槽函数</span></span><br><span class="line">   <span class="built_in">connect</span>(ui.btn_start, &amp;QPushButton::clicked, thread, &amp;workThread::dowork);</span><br><span class="line">   <span class="comment">//打印主线程</span></span><br><span class="line">   <span class="built_in">connect</span>(ui.btn_start, &amp;QPushButton::clicked, [=]() &#123;</span><br><span class="line">       <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;主线程id：&quot;</span> &lt;&lt; QThread::<span class="built_in">currentThreadId</span>();</span><br><span class="line">       &#125;);</span><br><span class="line">   <span class="comment">//线程启动</span></span><br><span class="line">   qthread1-&gt;<span class="built_in">start</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在运行槽函数时，不能在此直接调用（如：thread1-&gt;doWork()）。而是用connect连接信号和槽</p><p>这里将打印主线程和槽函数都绑定在了button按钮的click事件上了。</p><p><img src="https://bu.dusays.com/2025/03/13/67d28d3da16f3.png"></p><p><img src="https://bu.dusays.com/2025/03/13/67d2995e14e1b.png"></p><ul><li><strong>子线程中不能操作UI</strong></li></ul><p>Qt创建的子线程中是不能对UI对象进行任何操作的，即QWidget及其派生类对象，这个是我掉的第一个坑。可能是由于考虑到安全性的问题，所以Qt中子线程不能执行任何关于界面的处理，包括消息框的弹出。正确的操作应该是通过信号槽，将一些参数传递给主线程，让主线程（也就是Controller）去处理。</p><ul><li><strong>自定义的类不能指定父对象</strong></li></ul><p>比如上面程序中的：（不能指定自定义类对象为widget，即不可以加this）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread1=<span class="keyword">new</span> <span class="built_in">workThread1</span>();<span class="comment">//初始化</span></span><br></pre></td></tr></table></figure><ul><li><strong>QThread和connect的关系</strong></li></ul><p>我们使用最多的是QThread于connect的关系，在使用connect函数的时候，我们一般会把最后一个参数忽略掉。这时候我们需要看下函数原型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">static</span>] <span class="function">QMetaObject::Connection <span class="title">QObject::connect</span><span class="params">(<span class="type">const</span> QObject *sender, <span class="type">const</span> <span class="type">char</span> *signal, <span class="type">const</span> QObject *receiver, <span class="type">const</span> <span class="type">char</span> *method, Qt::ConnectionType type = Qt::AutoConnection)</span></span></span><br></pre></td></tr></table></figure><p>可以看到，最后一个参数代表的是连接的方式。我们一般会用到方式是有三种：</p><p><strong>自动连接(AutoConnection)</strong>：默认的连接方式。如果信号与槽，也就是发送者与接受者在同一线程，等同于直接连接；如果发送者与接受者处在不同线程，等同于队列连接。</p><p><strong>直接连接(Direct Connection)</strong>：当信号发射时，槽函数将直接被调用。无论槽函数所属对象在哪个线程，槽函数都在发射者所在线程执行。</p><p><strong>队列连接(Queued Connection)</strong>：当控制权回到接受者所在线程的事件循环式，槽函数被调用。槽函数在接收者所在线程执行。</p><p><strong>因此我们需要注意的是：</strong></p><ol><li>主线程对象发出信号连接QThread子类的槽函数，QThread子类对象在主线程创建的，无论采用哪种连接方式，槽函数都属在主线程调用。（如果在重写的run函数中调用了槽函数，此时槽函数在次线程执行，注意数据安全）。</li><li>次线程run中发出信号，槽函数可以是发出信号对象自身的槽函数，自发自收，都是次线程中行。槽函数是QThread子类的槽函数，或者主线程中对象的槽函数，这里的种情况需要你指明run中connect中的连接方式，直连则该槽函数在次线程中执行（可能发生数据安全问题），列队则在主线程执行。</li></ol><p><strong>🧡🧡总结一下：</strong></p><ul><li>一定要用信号槽机制，别想着直接调用，你会发现并没有在子线程中执行。</li><li>自定义的类不能指定父对象，因为moveToThread函数会将线程对象指定为自定义的类的父对象，当自定义的类对象已经有了父对象，就会报错。</li><li>当一个变量需要在多个线程间进行访问时，最好加上voliate关键字，以免读取到的是旧的值。当然，Qt中提供了线程同步的支持，比如互斥锁之类的玩意，使用这些方式来访问变量会更加安全。</li><li>分析发出信号的对象和接受信号对象所在的线程，再通过连接方式，判断槽函数在哪里执行。（小白在使用中就有在run中创建对象-因为多非槽函数都需要在次线程中执行，通过指针引出来，再connect与其他模块交互，指明连接方式为列队形式，所以相关执行都在次线程中执行）。这里记住moveToThread只能将槽函数移到次线程中。</li></ul><p><strong><p align = "center">启动多线程的操作思路</p></strong></p><p>如果我们需要实现一个排序操作，即首先获取1000个随机数，然后用冒泡排序法对其进行排序。</p><p><strong>方法一：重写run函数</strong></p><p> <strong>思路：（构建两个子线程，一个用于生成随机数，一个用于冒泡排序，主线程负责调用）</strong></p><ul><li>新建myThread类，在该类中重写run函数（即生随机数）。需要先接收主线程发送的要生成随机数的个数（scvnum信号）后再进行生成，生成完成以后发送一个sendArray信号</li><li>新建BubbleSort类，在该类中重写run函数（即冒泡排序算法）。需要先接收已经生成的随机数（rcvArray信号）后再进行排序，排序完成后发送一个finish信号</li><li>主线程通过stating信号告诉myThread线程要生成的个数，然后myThread线程通过scvnum信号接收，进行生成随机数，然后再发送一个sendArray信号（即生成随机数集合）</li><li>BubbleSort子线程通过rcvArray信号接收sendArray信号（即接收随机数）然后进行冒泡排序，再发送finish信号</li><li>主线程接收到finish信号后，将排序后的随机数显示在界面上</li></ul><p><strong>实现代码：</strong></p><ul><li><strong>子线程.h</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;qthread.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;qvector.h&quot;</span></span></span><br><span class="line"><span class="comment">//新建随机数类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myThread</span> :</span><br><span class="line">    <span class="keyword">public</span> QThread</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">myThread</span>(QObject* parent = <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">scvnum</span><span class="params">(<span class="type">int</span> num)</span></span>;<span class="comment">//接收数字</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendArray</span><span class="params">(QVector&lt;<span class="type">int</span>&gt;num)</span></span>;<span class="comment">//发送</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新建冒泡排序类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BubbleSort</span> :</span><br><span class="line">    <span class="keyword">public</span> QThread</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BubbleSort</span>(QObject* parent = <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rcvArray</span><span class="params">(QVector&lt;<span class="type">int</span>&gt;list)</span></span>;<span class="comment">//要接收的是排序的数</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">finish</span><span class="params">(QVector&lt;<span class="type">int</span>&gt;list)</span></span>;<span class="comment">//排序完成后发送一个finish信号</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QVector&lt;<span class="type">int</span>&gt;m_list;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>子线程.cpp</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myThread.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;qelapsedtimer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;qdebug.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">myThread::<span class="built_in">myThread</span>(QObject* parent) :<span class="built_in">QThread</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">BubbleSort::<span class="built_in">BubbleSort</span>(QObject* parent) : <span class="built_in">QThread</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myThread::scvnum</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_num = num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myThread::run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;child thread id&quot;</span> &lt;&lt; QThread::<span class="built_in">currentThreadId</span>();</span><br><span class="line">    QVector&lt;<span class="type">int</span>&gt; list;</span><br><span class="line">    QElapsedTimer time;</span><br><span class="line">    time.<span class="built_in">start</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        list.<span class="built_in">push_back</span>(<span class="built_in">qrand</span>() % <span class="number">100000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> milsec = time.<span class="built_in">elapsed</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;The number of&quot;</span> &lt;&lt; m_num &lt;&lt; <span class="string">&quot;generated&quot;</span>;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;shared&quot;</span> &lt;&lt; milsec &lt;&lt; <span class="string">&quot;second&quot;</span>;</span><br><span class="line">    <span class="function">emit <span class="title">sendArray</span><span class="params">(list)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort::rcvArray</span><span class="params">(QVector&lt;<span class="type">int</span>&gt; list)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_list = list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort::run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;BubbleSort thread id:&quot;</span> &lt;&lt; QThread::<span class="built_in">currentThreadId</span>();</span><br><span class="line">    QElapsedTimer time;</span><br><span class="line">    time.<span class="built_in">start</span>();</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_list.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m_list.<span class="built_in">size</span>()-i<span class="number">-1</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_list[j] &gt; m_list[j + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                temp = m_list[j];</span><br><span class="line">                m_list[j] = m_list[j + <span class="number">1</span>];</span><br><span class="line">                m_list[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> milsec = time.<span class="built_in">elapsed</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;shared&quot;</span> &lt;&lt; milsec &lt;&lt; <span class="string">&quot;second&quot;</span>;</span><br><span class="line">    <span class="function">emit <span class="title">finish</span><span class="params">(m_list)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>主线程.h</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtWidgets/QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;ui_list.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">list</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">list</span>(QWidget *parent = Q_NULLPTR);</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stating</span><span class="params">(<span class="type">int</span> num)</span></span>;<span class="comment">//设置要生成随机数个数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::listClass ui;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>主线程.cpp</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;list.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;myThread.h&quot;</span></span></span><br><span class="line">list::<span class="built_in">list</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    ui.<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//1.创建子线程对象</span></span><br><span class="line">    myThread* thread = <span class="keyword">new</span> <span class="built_in">myThread</span>();</span><br><span class="line">    BubbleSort* bub_thread = <span class="keyword">new</span> <span class="built_in">BubbleSort</span>();</span><br><span class="line">    <span class="comment">//向子线程发送要生成的随机数个数</span></span><br><span class="line">    <span class="built_in">connect</span>(<span class="keyword">this</span>,&amp;list::stating, thread, &amp;myThread::scvnum);</span><br><span class="line">    <span class="comment">//2启动子线程</span></span><br><span class="line">    <span class="built_in">connect</span>(ui.pushButton, &amp;QPushButton::clicked,  [=]() &#123;</span><br><span class="line">        emit <span class="built_in">stating</span>(<span class="number">1000</span>);<span class="comment">//主线程设置子线程随机数的个数</span></span><br><span class="line">        thread-&gt;<span class="built_in">start</span>();</span><br><span class="line">    </span><br><span class="line">        </span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="built_in">connect</span>(thread, &amp;myThread::sendArray, bub_thread, &amp;BubbleSort::rcvArray);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3接收子线程发送的数据</span></span><br><span class="line">    <span class="built_in">connect</span>(thread, &amp;myThread::sendArray,  [=](QVector&lt;<span class="type">int</span>&gt;list) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; list.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ui.randlist-&gt;<span class="built_in">addItem</span>(QString::<span class="built_in">number</span>(list.<span class="built_in">at</span>(i)));</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="built_in">connect</span>(thread, &amp;myThread::sendArray, [=](QVector&lt;<span class="type">int</span>&gt;list)&#123;</span><br><span class="line">        bub_thread-&gt;<span class="built_in">start</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="built_in">connect</span>(bub_thread, &amp;BubbleSort::finish, [=](QVector&lt;<span class="type">int</span>&gt;list) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; list. <span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ui.bubblelist-&gt;<span class="built_in">addItem</span>(QString::<span class="built_in">number</span>(list.<span class="built_in">at</span>(i)));</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2025/03/13/67d299b1220c9.gif"></p><p><strong>方法二：moveToThread()</strong> </p><p><strong>思路：</strong></p><ul><li>新建myThread类，用于生成随机数（working函数），在接受到主线程的信号后开始生成随机数</li><li>新建BubbleSort类，用于排序(working函数），在接受到myThread类生成的随机数后开始排序</li><li>最后显示在界面</li></ul><p><strong>代码实现：</strong></p><ul><li><strong>子线程.h</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;qthread.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;qvector.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;qobject.h&quot;</span></span></span><br><span class="line"><span class="comment">//新建随机数类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myThread</span> :</span><br><span class="line">    <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">myThread</span>(QObject* parent = <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">working</span><span class="params">(<span class="type">int</span> num)</span></span>;<span class="comment">//生成随机数</span></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendArray</span><span class="params">(QVector&lt;<span class="type">int</span>&gt;num)</span></span>;<span class="comment">//发送</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新建冒泡排序类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BubbleSort</span> :</span><br><span class="line">    <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BubbleSort</span>(QObject* parent = <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">working</span><span class="params">(QVector&lt;<span class="type">int</span>&gt;list)</span></span>;<span class="comment">//要接收的是排序的数</span></span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">finish</span><span class="params">(QVector&lt;<span class="type">int</span>&gt;list)</span></span>;<span class="comment">//排序完成后发送一个finish信号</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>子线程.cpp</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myThread.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;qelapsedtimer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;qdebug.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">myThread::<span class="built_in">myThread</span>(QObject* parent) :<span class="built_in">QObject</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">BubbleSort::<span class="built_in">BubbleSort</span>(QObject* parent) : <span class="built_in">QObject</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myThread::working</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;child thread id&quot;</span> &lt;&lt; QThread::<span class="built_in">currentThreadId</span>();</span><br><span class="line">    QVector&lt;<span class="type">int</span>&gt; list;</span><br><span class="line">    QElapsedTimer time;</span><br><span class="line">    time.<span class="built_in">start</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        list.<span class="built_in">push_back</span>(<span class="built_in">qrand</span>() % <span class="number">100000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> milsec = time.<span class="built_in">elapsed</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;The number of&quot;</span> &lt;&lt; m_num &lt;&lt; <span class="string">&quot;generated&quot;</span>;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;shared&quot;</span> &lt;&lt; milsec &lt;&lt; <span class="string">&quot;second&quot;</span>;</span><br><span class="line">    <span class="function">emit <span class="title">sendArray</span><span class="params">(list)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort::working</span><span class="params">(QVector&lt;<span class="type">int</span>&gt;list)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;BubbleSort thread id:&quot;</span> &lt;&lt; QThread::<span class="built_in">currentThreadId</span>();</span><br><span class="line">    QElapsedTimer time;</span><br><span class="line">    time.<span class="built_in">start</span>();</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; list.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; list.<span class="built_in">size</span>()-i<span class="number">-1</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (list[j] &gt; list[j + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                temp = list[j];</span><br><span class="line">                list[j] = list[j + <span class="number">1</span>];</span><br><span class="line">                list[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> milsec = time.<span class="built_in">elapsed</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;shared&quot;</span> &lt;&lt; milsec &lt;&lt; <span class="string">&quot;second&quot;</span>;</span><br><span class="line">    <span class="function">emit <span class="title">finish</span><span class="params">(list)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>主线程.h</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtWidgets/QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;ui_list.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">list</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">list</span>(QWidget *parent = Q_NULLPTR);</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stating</span><span class="params">(<span class="type">int</span> num)</span></span>;<span class="comment">//设置要生成随机数个数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::listClass ui;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>主线程.cpp</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;list.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;myThread.h&quot;</span></span></span><br><span class="line">list::<span class="built_in">list</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    ui.<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//1.创建QThread对象</span></span><br><span class="line">    QThread* thread1 = <span class="keyword">new</span> QThread;</span><br><span class="line">    QThread* thread2 = <span class="keyword">new</span> QThread;</span><br><span class="line">    <span class="comment">//2.创建子线程类对象</span></span><br><span class="line">    myThread* myth = <span class="keyword">new</span> <span class="built_in">myThread</span>();</span><br><span class="line">    BubbleSort* bub = <span class="keyword">new</span> <span class="built_in">BubbleSort</span>();</span><br><span class="line">    <span class="comment">//3通过movetothread将子线程对象移动到QThread对象中</span></span><br><span class="line">    myth-&gt;<span class="built_in">moveToThread</span>(thread1);</span><br><span class="line">    bub-&gt;<span class="built_in">moveToThread</span>(thread2);</span><br><span class="line">    <span class="comment">//4启动子线程</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//先向子线程发送要生成的随机数个数</span></span><br><span class="line">    <span class="built_in">connect</span>(<span class="keyword">this</span>,&amp;list::stating, myth, &amp;myThread::working);</span><br><span class="line">    <span class="comment">//再启动子线程</span></span><br><span class="line">    <span class="built_in">connect</span>(ui.pushButton, &amp;QPushButton::clicked,  [=]() &#123;</span><br><span class="line">        emit <span class="built_in">stating</span>(<span class="number">1000</span>);<span class="comment">//主线程设置子线程随机数的个数</span></span><br><span class="line">        thread1-&gt;<span class="built_in">start</span>();        </span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="comment">//将生成好的随机数发送给BubbleSort类</span></span><br><span class="line">    <span class="built_in">connect</span>(myth, &amp;myThread::sendArray, bub, &amp;BubbleSort::working);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将生成好的随机数显示在界面</span></span><br><span class="line">    <span class="built_in">connect</span>(myth, &amp;myThread::sendArray,  [=](QVector&lt;<span class="type">int</span>&gt;list) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; list.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ui.randlist-&gt;<span class="built_in">addItem</span>(QString::<span class="built_in">number</span>(list.<span class="built_in">at</span>(i)));</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="comment">//发送的同时启动排序算法</span></span><br><span class="line">    <span class="built_in">connect</span>(myth, &amp;myThread::sendArray, [=](QVector&lt;<span class="type">int</span>&gt;list)&#123;</span><br><span class="line">        thread2-&gt;<span class="built_in">start</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="comment">//将排序好的数显示在界面</span></span><br><span class="line">    <span class="built_in">connect</span>(bub, &amp;BubbleSort::finish, [=](QVector&lt;<span class="type">int</span>&gt;list) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; list. <span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ui.bubblelist-&gt;<span class="built_in">addItem</span>(QString::<span class="built_in">number</span>(list.<span class="built_in">at</span>(i)));</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结论</strong></p><p>通过对比，我们可以发现：</p><ul><li>由于第二种方法，我们可以自定义带参的子线程运行函数，因此代码更加简洁。</li><li>在第二种方法中，我们还可以随意修改需要在哪个线程中运行，代码也更加灵活。</li><li>第一种方法适合在线程中处理单一事件，其逻辑简单（只需要新建一个继承自QThread类的对象，重写run函数，然后启动即可），对于需要在一个线程中处理多个事件，还是用第二种方法比较好。</li><li>为什么不能在第二种方法中，给定义的子线程对象添加父类呢？ ：由于添加了父类以后就不能再移动到QThread中去了</li></ul><p><strong>如何进行线程资源的释放？</strong></p><ol><li>在new对象时候，直接用this指定其父类（即放入对象数中）</li><li>在程序最后自行释放资源</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(<span class="keyword">this</span>, &amp;list::destroyed, <span class="keyword">this</span>, [=]() &#123;</span><br><span class="line">    thread1-&gt;<span class="built_in">quit</span>();</span><br><span class="line">    thread1-&gt;<span class="built_in">wait</span>();</span><br><span class="line">    thread1-&gt;<span class="built_in">deleteLater</span>();</span><br><span class="line">    thread2-&gt;<span class="built_in">quit</span>();</span><br><span class="line">    thread2-&gt;<span class="built_in">wait</span>();</span><br><span class="line">    thread2-&gt;<span class="built_in">deleteLater</span>();</span><br><span class="line">    myth-&gt;<span class="built_in">deleteLater</span>();</span><br><span class="line">    bub-&gt;<span class="built_in">deleteLater</span>();</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><br><br><br><p><span style="color: red; font-size: 20px;">转载自：<a href="https://www.cnblogs.com/xyf327">唯有自己强大</a>          如有侵权，在下方评论  立刻删除。</span></p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt03文件读写</title>
      <link href="/2025/03/13/Qt03%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/"/>
      <url>/2025/03/13/Qt03%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/</url>
      
        <content type="html"><![CDATA[<p>Qt 提供了两种读写纯文本文件的基本方法：</p><ol><li>用 <strong>QFile 类</strong>的 IODevice 读写功能直接进行读写</li><li>利用 <strong>QFile</strong> 和 <strong>QTextStream</strong> 结合起来，用流（Stream)的方法进行文件读写。</li></ol><h3 id="一、文件读操作"><a href="#一、文件读操作" class="headerlink" title="一、文件读操作"></a><font color="FF0000">一、文件读操作</font></h3><p><strong>（1）使用QFile类</strong></p><p>Qt封装了QFile类，方便我们对文件进行操作，可以按照如下的步骤进行：</p><ul><li>使用QFile加载文件对象</li><li>打开文件 file.open(打开方式)</li><li>操作文件</li><li>关闭文件 file.close()</li></ul><p><strong>实例：点击读写文件按钮，读取文件内容到textEdit中</strong></p><p>1️⃣设置 ui 界面</p><p><img src="https://bu.dusays.com/2025/03/13/67d284db41c18.png"></p><p>2️⃣在widget.cpp中编辑代码（QFileDialog类是打开文件）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//点击选取文件按钮，弹出文件对话框</span></span><br><span class="line"> <span class="built_in">connect</span>(ui-&gt;pushButton,&amp;QPushButton::clicked,[=]()&#123;</span><br><span class="line"> QString path = QFileDialog::<span class="built_in">getOpenFileName</span>(<span class="keyword">this</span>,<span class="string">&quot;打开文件&quot;</span>,<span class="string">&quot;C:/Users/WFD/Desktop&quot;</span>);</span><br><span class="line"><span class="comment">//将路径显示在lineEdit中</span></span><br><span class="line">ui-&gt;lineEdit-&gt;<span class="built_in">setText</span>(path);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//读取文件内容，放入textEdit中</span></span><br><span class="line">   QFile <span class="built_in">file</span>(path);<span class="comment">//参数就是文件的路径</span></span><br><span class="line">   <span class="comment">//设置打开方式</span></span><br><span class="line">   file.<span class="built_in">open</span>(QIODevice::ReadOnly);</span><br><span class="line">   <span class="comment">//用QByteArray类去接收读取的信息</span></span><br><span class="line">   QByteArray array=file.<span class="built_in">readAll</span>();</span><br><span class="line">   <span class="comment">//将读取到的数据放入textEdit中</span></span><br><span class="line">   ui-&gt;textEdit-&gt;<span class="built_in">setText</span>(array);</span><br><span class="line">   <span class="comment">//关闭文件对象</span></span><br><span class="line">   file.<span class="built_in">close</span>();</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2025/03/13/67d2853788ad5.png"></p><p><strong>注意：在设置打开方式的时候</strong></p><p>QFile::open() 函数打开文件时需要传递 <code>QIODevice::OpenModeFlag</code> 枚举类型的参数，决定文件以什么方式打开，QIODevice::OpenModeFlag 类型的主要取值如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">QIODevice::ReadOnly  <span class="comment">//以只读方式打开文件，用于载入文件。</span></span><br><span class="line">QIODevice::WriteOnly  <span class="comment">//以只写方式打开文件，用于保存文件。</span></span><br><span class="line">QIODevice::ReadWrite <span class="comment">//以读写方式打开。</span></span><br><span class="line">QIODevice::Append  <span class="comment">//以添加模式打开，新写入文件的数据添加到文件尾部。</span></span><br><span class="line">QIODevice::Truncate <span class="comment">//以截取方式打开文件，文件原有的内容全部被删除。</span></span><br><span class="line">QIODevice::Text       <span class="comment">//以文本方式打开文件，读取时“\n”被自动翻译为换行符，写入时字符串结束符会自动翻译为系统平台的编码，如 Windows 平台下是“\r\n”。</span></span><br><span class="line"></span><br><span class="line">这些取值可以组合，例如 QIODevice::ReadOnly | QIODevice::Text 表示以只读和文本方式打开文件。</span><br></pre></td></tr></table></figure><p> <strong>注意：在操作文件时</strong></p><p>用只读方式打开一个文本文件，然后用readAll()方法将文件内容一次全部读取出来，返回值是字节数组QByteArray。QByteArray用来存放二进制数据，如果想要看文字内容需要转换成QString。(有时候系统会自动转换）</p><p>我们也可以使用readLine方法一次读取一行，然后每次对一行文字进行操作：（用file.atEnd判断是否读到最后一行）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QByteArray array;</span><br><span class="line"> <span class="keyword">while</span>(!file.<span class="built_in">atEnd</span>())</span><br><span class="line"> &#123;</span><br><span class="line">      array+=file.<span class="built_in">readLine</span>();<span class="comment">//+=叠加读过的行</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>（2）使用QTextStream类</strong></p><p>如果操作的是文本文件，Qt还专门封装了一个处理文本流的类，我们可以用它来读取文本内容</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//点击选取文件按钮，弹出文件对话框</span></span><br><span class="line"><span class="built_in">connect</span>(ui-&gt;pushButton,&amp;QPushButton::clicked,[=]()&#123;</span><br><span class="line">  QString path=  QFileDialog::<span class="built_in">getOpenFileName</span>(<span class="keyword">this</span>,<span class="string">&quot;打开文件&quot;</span>,<span class="string">&quot;C:/Users/WFD/Desktop&quot;</span>);</span><br><span class="line">  <span class="comment">//将路径放在lineEdit中</span></span><br><span class="line">  ui-&gt;lineEdit-&gt;<span class="built_in">setText</span>(path);</span><br><span class="line">  <span class="comment">//读取文件内容，放入textEdit中</span></span><br><span class="line">  QFile <span class="built_in">file</span>(path);<span class="comment">//参数就是文件的路径</span></span><br><span class="line">  <span class="comment">//设置打开方式</span></span><br><span class="line">  file.<span class="built_in">open</span>(QIODevice::ReadOnly);</span><br><span class="line">  <span class="comment">//用QTextStream类去读取文本信息</span></span><br><span class="line"> QTextStream <span class="built_in">QS</span>(&amp;file);</span><br><span class="line"> <span class="comment">//用QString类去接收读取的信息</span></span><br><span class="line"> QString array=QS.<span class="built_in">readAll</span>();</span><br><span class="line">  <span class="comment">//将读取到的数据放入textEdit中</span></span><br><span class="line">  ui-&gt;textEdit-&gt;<span class="built_in">setText</span>(array);</span><br><span class="line">  <span class="comment">//关闭文件对象</span></span><br><span class="line">  file.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure><h3 id="二、文件写操作"><a href="#二、文件写操作" class="headerlink" title="二、文件写操作"></a><font color="FF0000">二、文件写操作</font></h3><p><strong>（1）使用QFile类</strong></p><p>使用QFile同样可以对文件进行写操作：</p><p><img src="https://bu.dusays.com/2025/03/13/67d28680b7eb2.png"></p><p><strong>2）使用QTextStream类</strong></p><p> QTextStream类对操作符进行了重载，我们可以通过 &lt;&lt; 操作符将字符串流入文本文件：</p><p><img src="https://bu.dusays.com/2025/03/13/67d2869e099cf.png"></p><h3 id="三、文件信息读取"><a href="#三、文件信息读取" class="headerlink" title="三、文件信息读取"></a><font color="FF0000">三、文件信息读取</font></h3><p>除了对文件的读写操作，Qt还封装了QFileInfo类帮助我们获取文件的元数据，比如文件大小、后缀名、创建时间、最后修改时间等等：</p><p><img src="https://bu.dusays.com/2025/03/13/67d286ffb59dc.png"></p><p><strong>拓展：</strong></p><ul><li><strong>各编码转换</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QString -&gt; QByteArray      QString.<span class="built_in">toUtf8</span>();</span><br><span class="line"></span><br><span class="line">QByteArray -&gt; std::string  QByteArray.<span class="built_in">toStdString</span>();</span><br><span class="line"></span><br><span class="line">std::string -&gt; <span class="type">char</span> *        string.<span class="built_in">date</span>();</span><br></pre></td></tr></table></figure><ul><li><strong>常用静态函数</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QFileDialog::<span class="built_in">getOpenFileName</span>()    <span class="comment">//获取指定文件路径名返回QString</span></span><br><span class="line">QFileDialog::<span class="built_in">getExistingDirectory</span>()  <span class="comment">//获取指定路径返回QString</span></span><br><span class="line">QFileDialog::<span class="built_in">getSaveFileName</span>()    <span class="comment">//获取指定保存路径名返回QString</span></span><br></pre></td></tr></table></figure><p><strong><p align = "center">QT配置ini文件的建立，读取，写入操作</p></strong></p><p><strong>1 ini文件介绍</strong></p><p>.ini 文件是Initialization File的缩写，即初始化文件。</p><p>除了windows现在很多其他操作系统下面的应用软件也有.ini文件，用来配置应用软件以实现不同用户的要求。一般不用直接编辑这些.ini文件，应用程序的图形界面即可操作以实现相同的功能。它可以用来存放软件信息,注册表信息等。</p><p><strong>2 ini文件格式</strong></p><p>INI文件由节、键、值组成。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">节</span><br><span class="line"></span><br><span class="line">　　[section] </span><br><span class="line"></span><br><span class="line">参数（键=值）</span><br><span class="line"></span><br><span class="line">name=value</span><br></pre></td></tr></table></figure><p>下面是一个ini文件的例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[Section1 Name] 　　</span><br><span class="line"></span><br><span class="line">KeyName1=value1 　　</span><br><span class="line"></span><br><span class="line">KeyName2=value2 　　</span><br><span class="line"></span><br><span class="line">... 　　</span><br><span class="line"></span><br><span class="line">[Section2 Name] 　　</span><br><span class="line"></span><br><span class="line">KeyName21=value21 　　</span><br><span class="line"></span><br><span class="line">KeyName22=value22 　　</span><br></pre></td></tr></table></figure><p>其中：[Section1 Name]用来表示一个段落。因为INI文件可能是项目中共用的，所以使用[Section Name]段名来区分不同用途的参数区。例如：[Section1 Name]表示传感器灵敏度参数区；[Section2 Name]表示测量通道参数区等等。</p><p>注解：使用分号表示（;）。在分号后面的文字，直到该行结尾都全部为注解。</p><p><strong>3 Qt写ini文件</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSettings&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    <span class="comment">//Qt中使用QSettings类读写ini文件</span></span><br><span class="line">    <span class="comment">//QSettings构造函数的第一个参数是ini文件的路径,第二个参数表示针对ini文件,第三个参数可以缺省</span></span><br><span class="line">    QSettings *configIniWrite = <span class="keyword">new</span> <span class="built_in">QSettings</span>(<span class="string">&quot;hahaya.ini&quot;</span>, QSettings::IniFormat);</span><br><span class="line">    <span class="comment">//向ini文件中写入内容,setValue函数的两个参数是键值对</span></span><br><span class="line">    <span class="comment">//向ini文件的第一个节写入内容,ip节下的第一个参数</span></span><br><span class="line">    configIniWrite-&gt;<span class="built_in">setValue</span>(<span class="string">&quot;/ip/first&quot;</span>, <span class="string">&quot;192.168.0.1&quot;</span>);</span><br><span class="line">    <span class="comment">//向ini文件的第一个节写入内容,ip节下的第二个参数</span></span><br><span class="line">    configIniWrite-&gt;<span class="built_in">setValue</span>(<span class="string">&quot;ip/second&quot;</span>, <span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    <span class="comment">//向ini文件的第二个节写入内容,port节下的第一个参数</span></span><br><span class="line">    configIniWrite-&gt;<span class="built_in">setValue</span>(<span class="string">&quot;port/open&quot;</span>, <span class="string">&quot;2222&quot;</span>);</span><br><span class="line">    <span class="comment">//写入完成后删除指针</span></span><br><span class="line">    <span class="keyword">delete</span> configIniWrite;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序后，打开程序目录下的hahaya.ini文件，结果如下图所示：</p><p><img src="https://bu.dusays.com/2025/03/13/67d287cd1be9a.png"></p><p> <strong>4 Qt读ini文件</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSettings&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">      QSettings *configIniRead = <span class="keyword">new</span> <span class="built_in">QSettings</span>(<span class="string">&quot;hahaya.ini&quot;</span>, QSettings::IniFormat);</span><br><span class="line">      <span class="comment">//将读取到的ini文件保存在QString中，先取值，然后通过toString()函数转换成QString类型</span></span><br><span class="line">      QString ipResult = configIniRead-&gt;<span class="built_in">value</span>(<span class="string">&quot;/ip/second&quot;</span>).<span class="built_in">toString</span>();</span><br><span class="line">      QString portResult = configIniRead-&gt;<span class="built_in">value</span>(<span class="string">&quot;/port/open&quot;</span>).<span class="built_in">toString</span>();</span><br><span class="line">      <span class="comment">//打印得到的结果</span></span><br><span class="line">      <span class="built_in">qDebug</span>() &lt;&lt; ipResult;</span><br><span class="line">      <span class="built_in">qDebug</span>() &lt;&lt; portResult;</span><br><span class="line">      <span class="comment">//读入入完成后删除指针</span></span><br><span class="line">      <span class="keyword">delete</span> configIniRead;</span><br><span class="line">      <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2025/03/13/67d287e4a3dc2.png"></p><br><br><br><p><span style="color: red; font-size: 20px;">转载自：<a href="https://www.cnblogs.com/xyf327">唯有自己强大</a>          如有侵权，在下方评论  立刻删除。</span></p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt02信号和槽</title>
      <link href="/2025/03/13/Qt02%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD/"/>
      <url>/2025/03/13/Qt02%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD/</url>
      
        <content type="html"><![CDATA[<h3 id="一、信号和槽机制分析"><a href="#一、信号和槽机制分析" class="headerlink" title="一、信号和槽机制分析"></a><font color="FF0000">一、信号和槽机制分析</font></h3><p>​<strong>信号</strong>（Signal）就是在特定情况下被发射的事件，例如PushButton 最常见的信号就是鼠标单击时发射的 clicked() 信号，一个 ComboBox 最常见的信号是选择的列表项变化时发射的 CurrentIndexChanged() 信号。</p><p>​GUI 程序设计的主要内容就是对界面上各组件的信号的响应，只需要知道什么情况下发射哪些信号，合理地去响应和处理这些信号就可以了。</p><p>​<strong>槽</strong>（Slot）就是对信号响应的函数。槽就是一个函数，与一般的C++函数是一样的，可以定义在类的任何部分（public、private 或 protected），可以具有任何参数，也可以被直接调用。槽函数与一般的函数不同的是：槽函数可以与一个信号关联，当信号被发射时，关联的槽函数被自动执行。</p><p>​信号与槽关联是用 QObject::connect() 函数实现的，其基本格式是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QObject::<span class="built_in">connect</span>(sender, <span class="built_in">SIGNAL</span>(<span class="built_in">signal</span>()), receiver, <span class="built_in">SLOT</span>(<span class="built_in">slot</span>()));</span><br><span class="line"><span class="built_in">connect</span>(发出信号的对象，发出的信号，接收信号的对象，接收到信号之后需要调用的函数（槽函数））</span><br></pre></td></tr></table></figure><p><strong>connect()函数最常用的一般形式：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(sender, <span class="built_in">signal</span>(信号）, receiver, slot（槽）);</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2025/03/13/67d27c859f78b.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建第一个按钮</span></span><br><span class="line">  QPushButton *btn=<span class="keyword">new</span> QPushButton;</span><br><span class="line">  <span class="comment">//不能用btn-&gt;show();//show是以顶层方式弹出控件</span></span><br><span class="line">  <span class="comment">//让btn在widget窗口显示</span></span><br><span class="line">  btn-&gt;<span class="built_in">setParent</span>(<span class="keyword">this</span>);<span class="comment">//this指向当前对象的指针（即widget的地址）</span></span><br><span class="line">  <span class="comment">//显示文本</span></span><br><span class="line">  btn-&gt;<span class="built_in">setText</span>(<span class="string">&quot;关闭窗口&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//用信号和槽去实现点击按钮关闭窗口</span></span><br><span class="line">  <span class="built_in">connect</span>(btn,&amp;QPushButton::clicked,<span class="keyword">this</span>,&amp;QWidget::close);</span><br></pre></td></tr></table></figure><h3 id="二、自定义信号槽"><a href="#二、自定义信号槽" class="headerlink" title="二、自定义信号槽"></a><font color="FF0000">二、自定义信号槽</font></h3><p>1、定义自定义信号</p><p>在这个的基础上，我们先设定一个需求：屌丝男发向白富美表白，发送表白信号，白富美接收信号，并回应同意。</p><p>这里面有两个对象，一个屌丝男，一个白富美，我们将使用自定义的信号和槽将他们联系起来。</p><p><img src="https://bu.dusays.com/2025/03/13/67d27ebd77f3f.png"></p><p>类名自定义为boy，选择QObject为基类是为了将此类加入qt children中，而 QObject 是最基本的类。以同样的方式创建Girl类。</p><p>2、在boy类中加入自定义信号</p><p><img src="https://bu.dusays.com/2025/03/14/67d3e97f319ca.png"></p><p>3、 在Girl类头文件和源文件添加自定义槽函数的定义和实现</p><p><img src="https://bu.dusays.com/2025/03/14/67d3ea0b48134.png"></p><p><img src="https://bu.dusays.com/2025/03/14/67d3ea110e236.png"></p><p>4、 在widget.h中的widget类中添加两个成员，一个boy对象xgg（小哥哥），girl对象xjj（小姐姐）两个指针。</p><p><img src="https://bu.dusays.com/2025/03/14/67d3ea460c19f.png"></p><p>5、 在widget.cpp中new出对象并添加连接。</p><p><img src="https://bu.dusays.com/2025/03/07/67cad87144911.png"></p><p>6、 运行程序，程序在表白函数中发送示爱信息，接收者收到信息并执行相应的槽函数。</p><p>运行结果：打印出了槽函数中的信息。实现了自定义的信号和槽函数</p><p><img src="https://bu.dusays.com/2025/03/14/67d3ea8da7844.png"></p><p>7、 总结：自定义信号和槽的区别，<strong>信号和槽都为void类型</strong>，信号只需要定义，<strong>不需要实现</strong>，而槽函数<strong>既需要定义，也需要实现</strong>，<strong>信号和槽都可以有参数也都可以重载</strong>。emit是出发信号的标志，可要可不要。</p><h3 id="三、自定义信号和槽发生重载如何解决？"><a href="#三、自定义信号和槽发生重载如何解决？" class="headerlink" title="三、自定义信号和槽发生重载如何解决？"></a><font color="FF0000">三、自定义信号和槽发生重载如何解决？</font></h3><p>自定义的信号和槽<strong>可以带参数</strong>，<strong>可以重载</strong>，但是重载（或者带参数）后如何去用connect关联呢？</p><p>首先看需求，高富帅表白成功后，他们就很有默契了。他们就要约会对不会，男的想说我们去看电影吧，女孩就很听男的话，收到信号后，就同意男孩，我们就去看电影，就是男孩说什么，女孩就同意男孩也说什么，这之间的话，就通过信号的参数来传递。</p><p>好，还是来到我们上节课的项目。</p><p>1、 在boy.h的signals下重载love函数，带一个QString参数，就是这个传过去一句话，女孩也说这句话。</p><p><img src="https://bu.dusays.com/2025/03/14/67d3eb6b3233b.png"></p><p>记住，这个信号只需要定义，不需要实现，只要知道定义了这么一个带一个参数的信号就行了。触发这个信号，还需要一个QString的参数。</p><p>2、 在girl.cpp也重载一个带参数的回应的槽函数</p><p><img src="https://bu.dusays.com/2025/03/14/67d3eafc0227e.png"></p><p><img src="https://bu.dusays.com/2025/03/14/67d3eb4298513.png"></p><p>在实现的函数，将参数输出</p><p>3、 回到widget.cpp中会发现原来写好的没问题的connect函数有错误了。</p><p><img src="https://bu.dusays.com/2025/03/07/67cadb9162646.png"></p><p><img src="https://bu.dusays.com/2025/03/14/67d3ebb51a45e.png"></p><p>编译后发现错误，重载函数有歧义错误。什么意思呢，信号和槽的连接函数中，就是一个函数名，也就是函数地址，有没有发现，我们在重载之后，就有了两个love信号，也有了两个lovetoo槽，那么这个函数指针，到底指的是哪一个呢？这就让编译器为难了。</p><p>4、 我们可以使用带参数的函数指针来指向我们所要指向的那个函数，这个就可以消除歧义。</p><p><img src="https://bu.dusays.com/2025/03/14/67d3ec0d033cf.png"></p><p>这样子就消除错误了。可以编译通过，并运行。</p><p>5、 但是我发现一个问题，这样能运行，但是就什么输出都没了，为什么呢？因为我已经把前面的连接函数注释了，我们连接的带参数的信号，而我们原来的出发信号的函数是没有带参数的，所以不会出发这个带参数的信号，信号是可以多次出发的，我们在表白的函数中出发一个带参数的信号</p><p><img src="https://bu.dusays.com/2025/03/14/67d3ec52acb19.png"></p><p>再运行</p><p><img src="https://bu.dusays.com/2025/03/14/67d3ec6b5ced4.png"></p><p>这就能看到女孩那边回应的也是同样的一句话。说明信号跑通了。</p><p>6、 总结：注意信号重载函数指针指向哪一个函数的问题，对于重载函数的信号连接，要指明到底连接的是哪一个？</p><h3 id="四、信号连接信号"><a href="#四、信号连接信号" class="headerlink" title="四、信号连接信号"></a><font color="FF0000">四、信号连接信号</font></h3><p>这部分不放代码了，自己尝试着实践。</p><ol><li>信号可以连接信号</li><li>一个信号可以连接多个槽（点击按钮，触发信号并关闭窗口）</li><li>多个信号可以连接同一个槽（比如多个按钮都可以关闭窗口）</li><li>自定义槽函数可以写成：<ol><li>类的任意成员函数</li><li>静态函数</li><li>全局函数</li><li>lambda表达式</li></ol></li></ol><p><strong>归根究底：连接的原则就是信号和槽的参数必须一一对应！！</strong></p><h3 id="五、lambad表达式"><a href="#五、lambad表达式" class="headerlink" title="五、lambad表达式"></a><font color="FF0000">五、lambad表达式</font></h3><p>表达式用于定义并创建匿名的函数对象，以简化编程工作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[函数对象参数](操作符重载函数参数)<span class="keyword">mutable</span>或exception-&gt;返回值</span><br><span class="line">&#123;</span><br><span class="line">函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>1️⃣函数对象参数</strong></p><p>[ ]，标识一个 Lambda 的开始，这部分必须存在，不能省略。函数对象参数 是传递给编译器自动生成的函数对象类的构造函数的。函数对象参数只能使 用那些到定义 Lambda 为止时 Lambda 所在作用范围内可见的局部变量（包括 Lambda 所在类的 this）。函数对象参数有以下形式：（常用的就是&#x3D; &amp; this a）</p><ul><li><strong>空</strong>。没有使用任何函数对象参数。</li><li><strong>&#x3D;</strong>。函数体内可以使用 Lambda 所在作用范围内所有可见的局部变量（包 括 Lambda 所在类的 this），并且是<strong>值传递方式</strong>（相当于编译器自动为我 们按值传递了所有局部变量）。</li><li><strong>&amp;</strong>。函数体内可以使用 Lambda 所在作用范围内所有可见的局部变量（包 括 Lambda 所在类的 this），并且是<strong>引用传递方式</strong>（相当于编译器自动为 我们按引用传递了所有局部变量）。</li><li><strong>this</strong>。函数体内可以使用 Lambda 所在类中的成员变量。</li><li><strong>a</strong>。将 a 按值进行传递。按值进行传递时，函数体内不能修改传递进来的 a 的拷贝，因为默认情况下函数是 const 的。要修改传递进来的 a 的拷贝，可以添加 mutable 修饰符。</li><li><strong>&amp;a</strong>。将 a 按引用进行传递。</li><li><strong>a, &amp;b</strong>。将 a 按值进行传递，b 按引用进行传递。</li><li><strong>&#x3D;，&amp;a, &amp;b</strong>。除 a 和 b 按引用进行传递外，其他参数都按值进行传递。</li><li><strong>&amp;, a, b</strong>。除 a 和 b 按值进行传递外，其他参数都按引用进行传递。</li></ul><p><strong>如何用lambda表达式去修改按钮的名称：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数对象参数: =</span></span><br><span class="line">[=]()&#123;</span><br><span class="line">         btn-&gt;<span class="built_in">setText</span>(<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line">     &#125;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数对象参数:a</span></span><br><span class="line">     [btn]()&#123;</span><br><span class="line">          btn-&gt;<span class="built_in">setText</span>(<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line">   <span class="comment">//由于函数对象参数为btn，因此只能对btn操作，引入btn1会报错</span></span><br><span class="line">          <span class="comment">//btn1-&gt;setText(&quot;bbbb&quot;);</span></span><br><span class="line">      &#125;();</span><br></pre></td></tr></table></figure><p><font color="FF0000"><strong>注意：</strong></font>不加( )只是对lambad表达式的声明，加上( )才是对它的调用。（由于btn在创建的时候lambad作用范围内是不可见的，因此需要用&#x3D;让lambad表达式认识btn这个局部变量）</p><p><strong>2️⃣操作符重载函数参数</strong></p><p>标识重载的()操作符的参数，没有参数时，这部分可以省略。参数可以通过 按值（如：(a,b)）和按引用（如：(&amp;a,&amp;b)）两种方式进行传递</p><p><strong>3️⃣可修改标示符</strong></p><p>mutable 声明，这部分可以省略。按值传递函数对象参数时，加上 mutable 修饰符后，可以修改按值传递进来的拷贝（注意是能修改拷贝，而不是值本身）</p><p><strong>4️⃣错误抛出标示符</strong></p><p>exception 声明，这部分也可以省略。exception 声明用于指定函数抛出的异常，如抛出整数类型的异常，可以使用 throw(int）</p><p><strong>5️⃣函数返回值</strong></p><p>-&gt; 返回值类型，标识函数返回值的类型，当返回值为 void，或者函数体中只有一处 return 的地方（此时编译器可以自动推断出返回值类型）时，这部分可以省略。</p><p><strong>如</strong>：int一个ret去接收lanbda表达式返回的结果（注意：要用-&gt;标识返回值的类型）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ret=[]()-&gt;<span class="type">int</span>&#123;<span class="keyword">return</span> <span class="number">1000</span>;&#125;();</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;ret=:&quot;</span>&lt;&lt;ret;　　</span><br></pre></td></tr></table></figure><p><strong>6️⃣函数体</strong></p><p>{ }，标识函数的实现，这部分不能省略，但函数体可以为空</p><p><strong>💛💛💛槽函数也可以使用 Lambda 表达式的方式进行处理：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//创建两个按钮</span></span><br><span class="line"> QPushButton *myBtn = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="keyword">this</span>);</span><br><span class="line"> QPushButton *myBtn1 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="keyword">this</span>);</span><br><span class="line"> <span class="comment">//移动第二个按钮</span></span><br><span class="line"> myBtn1-&gt;<span class="built_in">move</span>(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line"> <span class="type">int</span> m =<span class="number">10</span>;</span><br><span class="line"> <span class="comment">//用槽函数（lambda表达式）改变m的copy值</span></span><br><span class="line"> <span class="built_in">connect</span>(myBtn,&amp;QPushButton::clicked,<span class="keyword">this</span>,[m]()<span class="keyword">mutable</span>&#123;m=<span class="number">100</span> + <span class="number">10</span>;<span class="built_in">qDebug</span>() &lt;&lt; m;&#125;);</span><br><span class="line"> <span class="built_in">connect</span>(myBtn1,&amp;QPushButton::clicked,<span class="keyword">this</span>,[=]() &#123;<span class="built_in">qDebug</span>() &lt;&lt; m;&#125;);</span><br><span class="line"> <span class="built_in">qDebug</span>() &lt;&lt; m;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于第一个connect函数来说：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(myBtn,&amp;QPushButton::clicked,<span class="keyword">this</span>,[m]()<span class="keyword">mutable</span>&#123;m=<span class="number">100</span><span class="number">+10</span>;<span class="built_in">qDebug</span>()&lt;&lt;m;&#125;);</span><br></pre></td></tr></table></figure><p>当函数对象参数为m时候，若要修改该值传递进来的拷贝，需要加上mutable 关键字。（注意只能修改拷贝，而不是值本身）</p><p><strong>一般来说，lambda表达式中很少去加关键字的，除非你有什么特殊的需求。</strong></p><p><strong>总的来说：</strong></p><ul><li>用lambda写槽函数可以在lambda表达式的函数体内写多个函数。（如上面m&#x3D;100+10;和qDebug()&lt;&lt;m;)</li><li>lambda常用表达式：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[=]()&#123;&#125;</span><br></pre></td></tr></table></figure><p>对于嵌套窗口，其坐标是相对于父窗口来说的。</p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt01对象树和窗口坐标体系</title>
      <link href="/2025/03/13/Qt01%E5%AF%B9%E8%B1%A1%E6%A0%91%E5%92%8C%E7%AA%97%E5%8F%A3%E5%9D%90%E6%A0%87%E4%BD%93%E7%B3%BB/"/>
      <url>/2025/03/13/Qt01%E5%AF%B9%E8%B1%A1%E6%A0%91%E5%92%8C%E7%AA%97%E5%8F%A3%E5%9D%90%E6%A0%87%E4%BD%93%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<h3 id="一、QT基本框架"><a href="#一、QT基本框架" class="headerlink" title="一、QT基本框架"></a><font color = "FF0000">一、QT基本框架</font></h3><p>创建一个项目，先看下main.cpp这个文件</p><p><img src="https://bu.dusays.com/2025/03/13/67d2403c08fc9.png"></p><p><strong><font color = "FF0000">注意：</font></strong></p><ol><li>每个Qt程序有且只能有一个QApplication对象，没有会报错。</li><li>Qt里面的头文件和类名是一致的，知道头文件就知道类名，反之亦然</li><li>Qt头文件是没有.h的，基本都是以大写的Q开头</li></ol><p>根据以上的分析，我们可以得出Qt的程序框架代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span>      </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;  </span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">       在这里写你的代码</span></span><br><span class="line"><span class="comment">     */</span>     </span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>widget.h和widget.cpp分析</strong></li></ul><p>打开头文件里面的widget.h,和sources里面的widget.app，可以看到以下代码：</p><p><img src="https://bu.dusays.com/2025/03/13/67d242912f352.png"></p><p><img src="https://bu.dusays.com/2025/03/13/67d242a1e99ab.png"></p><p>最上面的<strong>MyfirstQt.pro</strong>,是管理项目的文件，用来存储项目设置。</p><p>后缀为“.pro”的文件是项目的管理文件，文件名就是项目的名称，如本项目中的 MyfirstQt.pro。（类似与VS工程的.sln文件）</p><p><strong>💛💛实例（用代码创建一个button）：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;widget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_widget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QPushButton&gt;</span><span class="comment">//按钮控件的头文件</span></span></span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::Widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建第一个按钮</span></span><br><span class="line">    QPushButton *btn=<span class="keyword">new</span> QPushButton;</span><br><span class="line">    <span class="comment">//不能用btn-&gt;show();//show是以顶层方式弹出控件</span></span><br><span class="line">    <span class="comment">//让btn在widget窗口显示</span></span><br><span class="line">    btn-&gt;<span class="built_in">setParent</span>(<span class="keyword">this</span>);<span class="comment">//this指向当前对象的指针（即widget的地址）</span></span><br><span class="line">    <span class="comment">//显示文本</span></span><br><span class="line">    btn-&gt;<span class="built_in">setText</span>(<span class="string">&quot;第一个按钮&quot;</span>);</span><br><span class="line">    <span class="comment">//创建第二个按钮</span></span><br><span class="line">    <span class="comment">//注意：这种方法是按照按钮的大小创建窗口</span></span><br><span class="line">    QPushButton *btn2=<span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;第二个按钮&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//移动btn2的位置（由于创建的两个按钮位置重叠了）</span></span><br><span class="line">    btn2-&gt;<span class="built_in">move</span>(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">    <span class="comment">//因此需要重置窗口大小</span></span><br><span class="line">    <span class="built_in">resize</span>(<span class="number">600</span>,<span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置窗口标题</span></span><br><span class="line">    <span class="built_in">setWindowTitle</span>(<span class="string">&quot;唯有自己强大&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、对象树"><a href="#二、对象树" class="headerlink" title="二、对象树"></a><font color = "FF0000">二、对象树</font></h3><p><strong>💚💚什么是对象树？</strong></p><p>我们常常听到 QObject 会用对象树来组织管理自己，那什么是对象树？</p><p>这个概念非常好理解。因为 QObject 类就有一个私有变量 QList&lt;QObject *&gt;，专门存储这个类的子孙后代们。比如创建一个 QObject 对象并指定父对象时，就会把自己加入到父对象的 childre() 列表中，也就是 QList&lt;QObject *&gt; 变量中。</p><p> 父对象析构的时候，这个列表中的所有对象也会被析构。<strong>（注意，这 里的父对象并不是继承意义上的父类！）</strong></p><p>举个例子，有一个窗口 Window，里面有 Label标签、TextEdit文本输入框、Button按钮这三个元素，并且都设置 Window 为它们的父对象。这时候我做了一个关闭窗口的操作，作为程序员的你是不是自然想到将所有和窗口相关的对象析构啊？古老的办法就是一个个手动 delete 呗。是不是很麻烦？Qt 运用对象树模式，当父对象被析构时，子对象自动就 delete 掉了，不用再写一大堆的代码了。</p><p><strong>QWidget 是能够在屏幕上显示的一切组件的父类（QWidget 继承自 QObject，因此也继承了这种对象树关系。）</strong></p><p><strong>💛💛注意构建&#x2F;析构 QObject 的顺序问题</strong></p><p>正常情况下，最后被创建出来的会先被析构掉。就好比我有一个大桌子，上面先摆放一个盘子，再摆放一个碗。当我要把桌子撤掉的时候，会先撤掉碗，再撤掉盘子，最后撤掉桌子。</p><p>用代码演示一下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     QWidget window;</span><br><span class="line">     <span class="function">QPushButton <span class="title">quit</span><span class="params">(<span class="string">&quot;Quit&quot;</span>, &amp;window)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后创建的 quit 对象指定了 window 为其父对象。那么关闭程序时，会先调用它的析构函数，然后调用 window 的析构函数。</p><p><strong><font color="FF0000">这就牵扯到一个特殊情况：</font></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QPushButton <span class="title">quit</span><span class="params">(<span class="string">&quot;Quit&quot;</span>)</span></span>;</span><br><span class="line">    QWidget window;</span><br><span class="line"> </span><br><span class="line">    quit.<span class="built_in">setParent</span>(&amp;window);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果反过来，由于 window 后创建，程序关闭时先调用 window 的析构函数（此时 quit 被第一次析构）。接着调用 quit 的析构函数（此时 quit 被第二次析构），这时由于被两次析构，所以出问题了。</p><p>这种特殊情况在编程中很隐蔽，不容易发现。因为编译的时候不会报错，只有运行时才会产生问题。</p><p><strong>解决办法如下：</strong></p><ol><li><p><strong>栈对象的析构顺序</strong><br> 两个栈对象 <code>window</code>（父）和 <code>quit</code>（子）会在 <code>main</code> 函数结束时按创建<strong>相反的顺序</strong>析构：</p><ul><li>先析构 <code>window</code>（后创建）</li><li>再析构 <code>quit</code>（先创建）</li></ul></li><li><p><strong>Qt 的父子对象机制</strong><br> 当父对象（<code>window</code>）被销毁时，Qt 会自动递归销毁其子对象（<code>quit</code>）。由于 <code>window</code> 是栈对象，其析构过程会<strong>触发 <code>delete &amp;quit</code></strong>，但 <code>quit</code> 同样是个栈对象（未通过 <code>new</code> 在堆上分配）。</p></li><li><p><strong>双重释放错误</strong></p><ul><li>第一次析构（错误）：通过 <code>window</code> 销毁子对象时，对栈地址 <code>&amp;quit</code> 调用 <code>delete</code>，本质是对非堆内存进行释放。</li><li>第二次析构（正常）：<code>quit</code> 离开作用域时，触发栈对象的自然析构，再次调用析构函数。</li></ul><p>❌ 这将引发<strong>双重释放（double free）或内存访问冲突</strong>，导致程序崩溃。</p></li></ol><p>我们最好从开始就养成良好习惯，在 Qt 中，尽量在构造的时候就指定 parent 对象，并且大胆在堆上创建。</p><h3 id="三、Qt窗口坐标体系"><a href="#三、Qt窗口坐标体系" class="headerlink" title="三、Qt窗口坐标体系"></a><font color = "FF0000">三、Qt窗口坐标体系</font></h3><p>Qt的窗口坐标系以左上角为原点，X 向右增加，Y 向下增加。</p><p><img src="https://bu.dusays.com/2025/03/13/67d277561fcbf.png"></p><p>对于嵌套窗口，其坐标是相对于父窗口来说的。</p><br><br><br><p><span style="color: red; font-size: 20px;">转载自：<a href="https://www.cnblogs.com/xyf327">唯有自己强大</a>          如有侵权，在下方评论  立刻删除。</span></p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt几个面试问题</title>
      <link href="/2025/03/07/Qt%E5%87%A0%E4%B8%AA%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/"/>
      <url>/2025/03/07/Qt%E5%87%A0%E4%B8%AA%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h4 id="QT多线程"><a href="#QT多线程" class="headerlink" title="QT多线程"></a>QT多线程</h4><h4 id="QML"><a href="#QML" class="headerlink" title="QML"></a>QML</h4><p><strong>QML（Qt Meta-Object Language）</strong> 是 <strong>Qt框架</strong> 中用于构建用户界面（UI）的声明式编程语言。它专注于界面设计与用户交互，与C++后端逻辑结合，适用于开发跨平台、动态且现代化的应用程序（如桌面、移动及嵌入式应用）。以下是其核心特性与作用：</p><ul><li>ECMAScript</li><li>Qt 对象系统</li><li>Qt Quick 标准库</li></ul><p>用于定义和创建动态可视化界面</p><p>Qt Quick 是一种基于 Qt 的用户界面设计技术。它允许开发人员使用 QML（Qt Meta-Object Language）语言和 JavaScript 以声明式的方式创建动态的、高效的、流畅的用户界面。Qt Quick 技术不同于传统的基于部件（widget-based）的用户界面设计，其设计哲学是将界面的各个元素抽象出来，然后通过组合这些元素来实现各种不同的界面和交互效果。</p><h4 id="多线程的实现：信号和槽"><a href="#多线程的实现：信号和槽" class="headerlink" title="多线程的实现：信号和槽"></a>多线程的实现：信号和槽</h4><p>api函数   成员函数、<strong>2.2 信号槽</strong>  <strong>2.3静态函数</strong></p><p><strong>派生QThread类对象的方法（重写Run函数）</strong></p><p>启动事件循环：当一个程序调用 exec()（3456例如 QApplication::exec()）后，当前线程会进入一个阻塞状态，并开始无限循环地监听和分发事件（如鼠标点击、键盘输入、定时器触达、网络响应等）。</p><p><strong>使用信号与槽方式来实现多线程</strong></p><p>种方法存在一个局限性，只有一个run()函数能够在线程中去运行，但是当有多个函数在同一个线程中运行时，就没办法了，至少实现起来很麻烦</p><p>从 QObject 派生，在这个类中添加一个公共的成员函数(working)，函数体就是我们要子线程中执行的业务逻辑</p><ul><li>在主线程中创建一个 QThread 对象，这就是子线程的对象</li><li>在主线程中创建工作的类对象（千万不要指定给创建的对象指定父对象）</li><li>将 MyWork 对象移动到创建的子线程对象中，需要调用 QObject 类提供的 moveToThread() 方法</li><li>启动子线程，调用 start(), 这时候线程启动了，但是移动到线程中的对象并没有工作</li><li>调用 MyWork 类对象的工作函数，让这个函数开始执行，这时候是在移动到的那个子线程中运行的</li></ul><h3 id="共享内存-队列"><a href="#共享内存-队列" class="headerlink" title="共享内存  队列"></a>共享内存  队列</h3><p>在Qt中，<strong>共享内存（Shared Memory）</strong> 是一种允许不同进程访问同一块内存区域的机制。这是实现进程间通信（IPC）的一种高效方式，尤其适用于需要<strong>高频数据交换</strong>的场景（如实时数据传输）。Qt提供了 <strong><code>QSharedMemory</code></strong> 类来简化共享内存的操作。Qt提供了 <strong><code>QSharedMemory</code></strong> 类来简化共享内存的操作</p><h3 id="QT-事件过滤器"><a href="#QT-事件过滤器" class="headerlink" title="QT 事件过滤器"></a>QT 事件过滤器</h3><p>在Qt中，<strong>事件过滤器（Event Filter）</strong> 是一种强大的机制，允许一个对象监视或拦截另一个对象的事件处理流程。通过事件过滤器，可以在事件到达目标对象前进行预处理或完全拦截，这在需要自定义事件行为或跨组件交互时非常实用。</p><p>继承 <code>QObject</code> 并重写 <code>eventFilter()</code> 方法。该方法在目标对象的事件被处理前调用。</p><h4 id="安装过滤器到目标对象"><a href="#安装过滤器到目标对象" class="headerlink" title="安装过滤器到目标对象"></a><strong>安装过滤器到目标对象</strong></h4><p>目标对象通过 <code>installEventFilter()</code> 注册过滤器，使其事件被监控。</p><h3 id="QT定时器"><a href="#QT定时器" class="headerlink" title="QT定时器"></a>QT定时器</h3><p>Qt中有两种方法来使用定时器，一种是定时器事件，另一种是使用信号和槽。</p><ul><li>利用对void timerEvent(QTimerEvent* e)事件的重写。</li><li>启动定时器 int QObject::startTimer ( int interval ) ;</li></ul><p>开启一个定时器，返回值为int类型。他的参数interval是毫秒级别。当开启成功后会返回这个定时器的ID, 并且每隔interval 时间后会进入timerEvent 函数。直到定时器被杀死（killTimer）</p><ul><li>timerEvent的返回值是定时器的唯一标识。可以和e-&gt;timerId比较</li><li>void killTimer(int id); &#x2F;&#x2F;停止 ID 为 id 的计时器，ID 由 startTimer()函数返回</li></ul><p><strong>方式：</strong></p><ol><li>利用定时器类QTimer</li><li>创建定时器对象 QTimer *timer&#x3D;new QTimer(this)</li><li>启动定时器timer-&gt;start( 500） &#x2F;&#x2F;参数：每隔n毫秒发送一个信号（timeout）</li><li>用connect连接信号和槽函数（自定义槽）</li><li>暂停 timer-&gt;stop</li></ol><p>**实例：**启动label 每隔0.5秒计时</p><h3 id="QT和MFC底层机制"><a href="#QT和MFC底层机制" class="headerlink" title="QT和MFC底层机制"></a>QT和MFC底层机制</h3><p>QT</p><p><strong>事件驱动模型</strong>：</p><ul><li><p><strong>事件循环</strong>：每个 Qt 应用程序有一个全局事件队列（<code>QEventLoop</code>），管理用户输入、定时器、网络事件等。</p></li><li><p>事件分发</p><p>：</p><ul><li>Qt 将操作系统的原生事件（如鼠标点击、按键）封装为 <code>QEvent</code> 对象（如 <code>QMouseEvent</code>）。</li><li>通过 <code>QObject::event()</code> 和 <code>QWidget::eventFilter()</code> 分发事件。</li></ul></li><li><p>信号槽机制</p><p>：</p><ul><li>通过元对象系统（Meta-Object System，由 <code>moc</code> 生成）实现松耦合通信。</li><li>类型安全，支持跨线程通信。</li></ul></li></ul><p>MFC</p><p>核心：基于 Win32 API，依赖 Windows 的 HWND（窗口句柄）和消息队列。<br>消息传递：<br>Windows 消息（如 WM_PAINT、WM_CLOSE）通过 消息循环（PeekMessage&#x2F;GetMessage）分发给窗口过程（WndProc）。<br>MFC 封装了消息处理流程，通过 消息映射宏（如 ON_WM_PAINT()）将消息与成员函数绑定。</p><p><strong>QJSON</strong></p><p>Json 是一种轻量级的数据交换格式。它使得人们很容易进行阅读和编写。</p><p>QJson 是 Json的一种扩展，也就是一种简单的数据结构。</p><p>JSON 基于两种结构：1️⃣名称：值       2️⃣值的有序列表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QJsonDocument&gt;</span>  <span class="comment">// 读取和写入Json类</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QJsonValue&gt;</span>   <span class="comment">// Json值有下面几种形式：空、布尔值、浮点数、字符串、数组、对象（可以是另一个Json）、未定义</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QJsonObject&gt;</span><span class="comment">// JSON对象是键值对的列表中，其中键是唯一的字符串，值由QJsonValue表示。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QJsonArray&gt;</span>  <span class="comment">// JSON 数组是一个值列表。可通过从数组中插入和删除QJsonValue 来操作列表。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QJsonParseError&gt;</span> <span class="comment">// 报告Json解析过程中的错误。</span></span></span><br></pre></td></tr></table></figure><h4 id="QT图表功能"><a href="#QT图表功能" class="headerlink" title="QT图表功能"></a>QT图表功能</h4><p>Qt Charts是基于Qt Graphics View实现的一个图表的组件，可以用来在QT GUI程序中添加现在风格的、可交互的、以数据为中心的图表，可以用作QWidget或者 QGraphicsWidget，也可用在QML中。支持的图标类型有：折线图跟曲线图、面积图、饼图、柱状图等。</p><h4 id="QT-QSS"><a href="#QT-QSS" class="headerlink" title="QT QSS"></a>QT QSS</h4><p>​    QT样式表，用来实现对控件外观的自定义。</p><h4 id="QT-信号只声明没有定义"><a href="#QT-信号只声明没有定义" class="headerlink" title="QT  信号只声明没有定义"></a>QT  信号只声明没有定义</h4><p>​<strong>在 Qt 中，自定义信号（Signal）只需要在头文件中声明，无需手动在源文件中实现（定义）。</strong> 这是因为 Qt 的元对象系统（Meta-Object System，由 <code>Q_OBJECT</code> 宏和元对象编译器 <code>moc</code> 实现）<strong>会自动生成信号的底层代码</strong>，负责信号的触发与槽的连接机制。</p><p><strong>Qt元对象系统MOC的责任</strong></p><p>信号的“实现”由 moc 完成<br>信号本质是一个“标记”，当你在代码中使用 <code>emit mySignal();</code> 时：<code>emit</code> 关键字向 moc 生成的代码下发触发指令。moc 负责管理信号与槽的连接关系，并将参数传递给槽函数。</p><p><strong>信号的本质</strong>：信号是接口而非功能函数   信号的目的是触发事件通知，而非具体实现逻辑。用户只需要声明信号的格式（名称、参数类型），告知元对象系统如何传递数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">signals:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">healthChanged</span><span class="params">(<span class="type">int</span> newHealth)</span></span>;  <span class="comment">// 声明信号</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">positionUpdated</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span></span>; <span class="comment">// 血量</span></span><br></pre></td></tr></table></figure><p><strong>发射信号</strong> <code>emit</code>：在需要的位置调用<code>emit</code>，时间的逻辑处理由接收该信号的槽函数实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Aladdin::takeDamage</span><span class="params">(<span class="type">int</span> damage)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_health -= damage;</span><br><span class="line">    <span class="function">emit <span class="title">healthChanged</span><span class="params">(m_health)</span></span>; <span class="comment">// 触发信号，通知外部当前的血量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比槽函数（需要手动实现）</p><h4 id="信号为何必须是-void-类型？"><a href="#信号为何必须是-void-类型？" class="headerlink" title="信号为何必须是 void 类型？"></a>信号为何必须是 <code>void</code> 类型？</h4><p>信号的作用是触发事件通知，而不是返回值。若想传递数据，应通过参数传递，而非返回值。</p><h4 id="信号是否可重载？"><a href="#信号是否可重载？" class="headerlink" title="信号是否可重载？"></a><strong>信号是否可重载？</strong></h4><p>是的，允许通过参数类型或数量重载信号。连接时需使用 <code>QOverload</code> 或 <code>static_cast</code> 明确指定重载版本。</p><h4 id="为何有时无法触发信号？"><a href="#为何有时无法触发信号？" class="headerlink" title="为何有时无法触发信号？"></a><strong>为何有时无法触发信号？</strong></h4><ul><li>未正确连接信号与槽（<code>connect</code> 错误）。</li><li>未添加 <code>Q_OBJECT</code> 宏或未重新生成 moc。</li><li>发射信号的对象被提前销毁。</li></ul><h4 id="QT自定义控件的使用流程"><a href="#QT自定义控件的使用流程" class="headerlink" title="QT自定义控件的使用流程"></a>QT自定义控件的使用流程</h4><p>备注下</p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试问题 </tag>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用满血版deepseek</title>
      <link href="/2025/02/18/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%BB%A1%E8%A1%80%E7%89%88deepseek/"/>
      <url>/2025/02/18/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%BB%A1%E8%A1%80%E7%89%88deepseek/</url>
      
        <content type="html"><![CDATA[<p>本教程是在硅基流动获取API，并在Cherry Studio上面使用</p><h3 id="一、注册硅基流动"><a href="#一、注册硅基流动" class="headerlink" title="一、注册硅基流动"></a>一、注册硅基流动</h3><p>SiliconCloud 基于华为云昇腾云服务，首发推出了 DeepSeek R1 &amp; V3 模型推理服务。注册即赠送 14 元余额，邀请注册还可再获得 14 元余额（2000 万 Tokens）。</p><ul><li><strong>邀请链接：</strong> <a href="https://cloud.siliconflow.cn/i/ePZNK3HT">硅基流动统一登录</a></li><li><strong>邀请码：</strong> ePZNK3HT</li></ul><p>注册完成后，可在模型广场上找到 deepseek-ai&#x2F;DeepSeek-R1 模型，显示 671B 的满血版。</p><p><img src="https://bu.dusays.com/2025/02/18/67b3659255843.png"></p><p>但这个页面不必理会，点击左侧API密钥，如下图所示，点击新建API密钥（注意保护隐私），密钥描述随便填。</p><p><img src="https://bu.dusays.com/2025/02/18/67b366658f7b3.png"></p><p>建完API密钥后就来到第二步了。</p><h3 id="二、下载Cherry-Studio"><a href="#二、下载Cherry-Studio" class="headerlink" title="二、下载Cherry Studio"></a>二、下载Cherry Studio</h3><p>用户可以选择需要的软件来调用接口。推荐使用「CherryStudio」软件，支持 Windows、Mac 和 Linux 客户端。</p><p><strong>Cherry Studio 官网下载链接：</strong> <a href="https://docs.cherry-ai.com/cherrystudio/download?login=from_csdn">https://docs.cherry-ai.com/cherrystudio/download?login=from_csdn</a></p><p>安装完成之后，运行「CherryStudio」软件，点击左下角的设置按钮，选择 <strong>硅基流动</strong>，复制第一步创建的API密钥，输入刚刚复制的密钥粘贴进去即可。点击检查，软件将会自动对密钥进行验证，通过即可进行使用。</p><p><img src="https://bu.dusays.com/2025/02/18/67b3677c3ff7b.png"></p><p>通过下面的管理功能，可以添加硅基流动平台所有的模型，需要什么点击添加即可。</p><p><img src="https://bu.dusays.com/2025/02/18/67b368c449509.png"></p><p>点击助手即可进入对话页面，上方点击即可选择对话的模型</p><p><img src="https://bu.dusays.com/2025/02/18/67b3690603033.png"></p><p>以上是完整的使用教程！！！如果可以的话，请使用我的邀请码：ePZNK3HT</p>]]></content>
      
      
      <categories>
          
          <category> 分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统编程05I/O复用</title>
      <link href="/2025/01/12/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B05I-O%E5%A4%8D%E7%94%A8/"/>
      <url>/2025/01/12/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B05I-O%E5%A4%8D%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="Linux系统调用accept原理"><a href="#Linux系统调用accept原理" class="headerlink" title="Linux系统调用accept原理"></a>Linux系统调用accept原理</h3><p>​<code>accept</code> 函数是网络编程中用于接受客户端连接请求的关键系统调用。当一个 socket 被设置为监听模式后，它会在其对应的队列中积累来自客户端的连接请求。<code>accept</code> 函数的作用是从这个队列中取出一个已经建立的连接，并返回一个新的 socket 文件描述符，该描述符与客户端的连接相关联。</p><p>​当没有连接请求时，<code>accept</code> 会阻塞调用它的进程或线程，直到有新的连接请求到达。这个过程涉及到操作系统内核中的网络协议栈，具体来说，是 TCP 协议栈的处理机制。当 <code>accept</code> 被调用时，内核会检查监听 socket 的完全连接队列，如果队列为空，则进程或线程进入阻塞状态；如果队列中有待处理的连接，则 <code>accept</code> 返回一个新的 socket，进程或线程继续执行。</p><h3 id="非阻塞IO模式"><a href="#非阻塞IO模式" class="headerlink" title="非阻塞IO模式"></a>非阻塞IO模式</h3><p>在非阻塞 I&#x2F;O 模式下，当 <code>accept</code> 函数没有准备好返回时（即没有连接请求可以接受），它不会阻塞调用它的进程或线程，而是立即返回一个错误。这种模式允许程序在等待连接时继续执行其他任务，从而提高程序的响应性和效率。</p><h3 id="设置socket为非阻塞模式"><a href="#设置socket为非阻塞模式" class="headerlink" title="设置socket为非阻塞模式"></a>设置socket为非阻塞模式</h3><p>要将 socket 设置为非阻塞模式，可以使用 <code>fcntl</code> 函数来修改 socket 的属性。</p><h3 id="IO复用的概念"><a href="#IO复用的概念" class="headerlink" title="IO复用的概念"></a>IO复用的概念</h3><p>在网络编程中，IO 复用（I&#x2F;O Multiplexing）是一种让程序可以同时监视多个文件描述符（在网络编程里通常是套接字描述符）的技术，以此来判断这些文件描述符上是否有读写等事件发生，从而实现高效的 I&#x2F;O 操作。</p><p><strong>一个应用场景</strong>：在传统的单线程网络编程中，当调用 <code>accept</code> 函数时，如果没有新的连接请求到达，程序会被阻塞，这意味着在等待新连接的过程中，程序无法处理其他已经建立的连接上的读写操作。</p><h3 id="理解select函数并实现服务端："><a href="#理解select函数并实现服务端：" class="headerlink" title="理解select函数并实现服务端："></a>理解select函数并实现服务端：</h3><p><strong>1、是否存在套接字接收数据？</strong></p><p>​要判断是否存在套接字接收数据，可以使用 IO 复用技术（如 <code>select</code>、<code>poll</code>、<code>epoll</code>）。这些技术允许程序同时监视多个套接字的状态，当某个套接字有数据可读时，就能得知该套接字正在接收数据。</p><p><strong>2、无需阻塞传输数据的套接字有哪些？</strong></p><p>​在网络编程中，实现非阻塞传输数据通常可以通过将套接字设置为非阻塞模式，或者使用异步 I&#x2F;O 技术。</p><p><strong>3、哪些套接字发生了异常？</strong></p><p>​同样可以使用 IO 复用技术来检测套接字是否发生异常。在 <code>select</code>、<code>poll</code>、<code>epoll</code> 等函数中，都有相应的机制来处理异常事件。</p><h3 id="select模型以及实战案例"><a href="#select模型以及实战案例" class="headerlink" title="select模型以及实战案例"></a>select模型以及实战案例</h3><p>最早出现的IO复用系统调用，几乎所有的操作系统都支持。</p><p>程序创建一个文件描述符集合，将需要监视的文件描述符添加到该集合中，然后调用 <code>select</code> 函数。<code>select</code> 函数会阻塞，直到有文件描述符发生指定的事件或超时。返回时，<code>select</code> 会修改文件描述符集合，只保留那些发生了事件的文件描述符，程序可以通过遍历集合来处理这些事件。</p><p><strong>多进程服务器的缺点和解决办法</strong></p><p>多进程服务器：1、需要大量的运算        2、大量的内存空间</p><p><strong>理解select函数并实现服务端</strong></p><p>1、是否存在套接字接收数据？</p><p>2、无需阻塞传输数据的套接字有哪些？</p><p>3、哪些套接字发生了异常？</p><p><strong>Select模型具体步骤</strong></p><p>1、设置文件描述符：select函数监视多个（不超过1024个）文件描述符</p><p><img src="https://bu.dusays.com/2025/01/13/67847ba4af4fe.png"></p><h3 id="EPOLL-模型"><a href="#EPOLL-模型" class="headerlink" title="EPOLL 模型"></a><code>EPOLL</code> 模型</h3><p><code>eventpoll</code>是 linux 内核实现IO多路转接&#x2F;复用（IO multiplexing）的一个实现。IO多路转接的意思是在一个操作里同时监听多个输入输出源，在其中一个或多个输入输出源可用的时候返回，然后对其的进行读写操作。epoll是select和poll的升级版，相较于这两个前辈，epoll改进了工作方式，因此它更加高效。</p><p>·对于待检测集合select和poll是基于线性方式处理的，epoll是基于红黑树来管理待检测集合的。</p><p>select和poll每次都会线性扫描整个待检测集合，集合越大速度越慢，epoll使用的是回调机制，效率高，处理效率也不会随着检测集合的变大而下降<br>select和poll工作过程中存在内核&#x2F;用户空间数据的频繁拷贝问题，在epoll中内核和用户区使用的是共享内存（基于mmap内存映射区实现），省去了不必要的内存拷贝。<br>程序猿需要对select和poll返回的集合进行判断才能知道哪些文件描述符是就绪的，通过epoll可以直接得到已就绪的文件描述符集合，无需再次检测<br>使用epoll没有最大文件描述符的限制，仅受系统中进程能打开的最大文件数目限制<br>当多路复用的文件数量庞大、IO流量频繁的时候，一般不太适合使用select()和poll()，这种情况下select()和poll()表现较差，推荐使用epoll()。</p><p><code>**Epoll</code>的三大函数：<code>epoll_create</code>，<code>epoll_wait</code>， <code>epoll_ct</code>**</p><p><strong>int <code>epoll_create</code>(int size);</strong>    size必须要大于0      这个函数返回文件描述符</p><p> <strong><code>epoll_ctl</code></strong></p><h3 id="EPOOL-模型和-select-模型的对比"><a href="#EPOOL-模型和-select-模型的对比" class="headerlink" title="EPOOL 模型和 select 模型的对比"></a><code>EPOOL</code> 模型和 <code>select</code> 模型的对比</h3><ol><li><strong>性能方面</strong><ul><li>系统调用开销：<ul><li>在<code>select</code>模型中，每次调用<code>select</code>函数时，都需要将用户空间的文件描述符集合拷贝到内核空间。当文件描述符数量较多时，这种拷贝操作会带来较大的开销。例如，在一个有大量并发连接的服务器场景中，如果有 1000 个文件描述符，每次<code>select</code>调用都要拷贝这 1000 个文件描述符相关的信息。</li><li>而<code>epoll</code>使用了内核与用户空间共享的数据结构。<code>epoll_create</code>创建<code>epoll</code>实例后，<code>epoll_ctl</code>函数用于在内核维护的红黑树中添加、删除或修改文件描述符及其对应的事件。在<code>epoll_wait</code>调用时，不需要像<code>select</code>那样频繁地拷贝大量文件描述符集合，减少了系统调用的开销。</li></ul></li><li>事件触发方式的效率：<ul><li><code>select</code>模型采用的是水平触发（Level - Triggered）方式。这意味着只要文件描述符对应的缓冲区中有数据可读或者可写，<code>select</code>就会一直通知应用程序该文件描述符可读或可写。例如，在处理网络套接字时，如果应用程序没有及时处理完缓冲区中的数据，<code>select</code>在下一次调用时仍然会通知该套接字可读，这可能导致一些不必要的重复处理。</li><li><code>epoll</code>可以采用边缘触发（Edge - Triggered）方式（如代码中设置<code>EPOLLET</code>）。边缘触发是在文件描述符状态发生变化（如从不可读到可读，或者从不可写到可写）的瞬间触发事件通知。这样，只有当有新的数据到来或者连接状态真正改变时才会触发事件，避免了像<code>select</code>那样因为缓冲区数据未处理完而导致的重复通知，从而提高了处理效率。</li></ul></li></ul></li><li><strong>可扩展性方面</strong><ul><li>文件描述符数量限制：<ul><li><code>select</code>模型对文件描述符数量有比较严格的限制。在不同的操作系统中，这个限制可能不同，但通常是一个较小的固定值。例如，在一些旧版本的 Unix 系统中，<code>select</code>最多能处理 1024 个文件描述符。这在处理大量并发连接的现代网络应用场景中是远远不够的。</li><li><code>epoll</code>没有这种固定的、较小的文件描述符数量限制。它可以处理的文件描述符数量主要取决于系统的资源（如内存大小等）。这使得<code>epoll</code>能够更好地适应高并发场景，如大型的 Web 服务器或者消息队列服务器，这些服务器可能需要同时处理成千上万个客户端连接。</li></ul></li></ul></li><li><strong>代码复杂度方面</strong><ul><li>事件处理的代码逻辑：<ul><li>在<code>select</code>模型中，应用程序需要遍历所有的文件描述符来检查哪些文件描述符产生了事件。例如，每次<code>select</code>返回后，需要在一个循环中逐个检查文件描述符集合中的每个文件描述符是否在可读或可写集合中。如果文件描述符数量较多，这种遍历检查的代码会比较复杂且效率低下。</li><li><code>epoll</code>返回的是已经发生事件的文件描述符集合，应用程序只需要直接处理这些发生事件的文件描述符即可。在代码逻辑上，<code>epoll</code>更加简洁明了，不需要像<code>select</code>那样进行大量的遍历和判断操作，降低了代码的复杂度和出错的概率。</li></ul></li></ul></li></ol><h3 id="边缘触发和条件触发"><a href="#边缘触发和条件触发" class="headerlink" title="边缘触发和条件触发"></a>边缘触发和条件触发</h3><p><strong>条件触发(level-triggered，也被称为水平触发)LT:</strong> </p><p>只要满足条件，就触发一个事件(只要有数据没有被获取，内核就不断通知你)</p><p> <strong>边缘触发(edge-triggered)ET:</strong> </p><p>每当状态变化时，触发一个事件<br> “举个读socket的例子，假定经过长时间的沉默后，现在来了100个字节，这时无论边缘触发和条件触发都会产生一个通知应用程序可读。应用程序读了50个字节，然后重新调用<code>api</code>等待<code>io</code>事件。</p><p>这时水平触发的<code>api</code>会因为还有50个字节可读从而立即返回用户一个read ready notification。</p><p>而边缘触发的<code>api</code>会因为可读这个状态没有发生变化而陷入长期等待。 因此在使用边缘触发的<code>api</code>时，要注意每次都要读到socket返回<code>EWOULDBLOCK</code>为止，否则这个socket就算废了。而使用条件触发的<code>api</code> 时，如果应用程序不需要写就不要关注socket可写的事件，否则就会无限次的立即返回一个write ready notification。</p><p>select属于典型的条件触发。</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统编程04线程与多线程</title>
      <link href="/2025/01/12/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B04%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2025/01/12/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B04%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="线程的概念"><a href="#线程的概念" class="headerlink" title="线程的概念"></a>线程的概念</h3><p>线程是在进程中产生的一个执行单元，是CPU调度和分配的最小单元，其在同一个进程中与其他线程并行运行，他们可以共享进程内的资源，比如内存、地址空间、打开的文件等等。</p><p>   <strong>线程</strong>是CPU调度和分派的基本单位</p><p>   <strong>进程</strong>是分配资源的基本单位</p><p><img src="https://bu.dusays.com/2025/01/13/67841d43278bb.png"></p><p>进程：正在运行的程序（狭义）</p><p>是处于执行期的程序以及它所管理的资源（如打开的文件、挂起的信号、进程状态、地址空间等等）的总称，从操作系统核心角度来说，进程是操作系统调度除CPU时间片外进行的资源分配和保护的基本单位，它有一个独立的虚拟地址空间，用来容纳进程映像(如与进程关联的程序与数据)，并以进程为单位对各种资源实施保护，如受保护地访问处理器、文件、外部设备及其他进程(进程间通信) </p><h4 id="为什么使用多线程？"><a href="#为什么使用多线程？" class="headerlink" title="为什么使用多线程？"></a>为什么使用多线程？</h4><p>1️⃣ <strong>避免阻塞</strong>：单个进程只有一个主线程，当主线程阻塞的时候，整个进程也就阻塞了，无法再去做其它的一些功能了。</p><p>2️⃣ <strong>避免CPU空转</strong>：应用程序经常会涉及到 <code>RPC</code>，数据库访问，磁盘IO等操作，这些操作的速度比CPU慢很多，而在等待这些响应时，CPU却不能去处理新的请求，导致这种单线程的应用程序性能很差。</p><p>3️⃣ <strong>提升效率</strong>：一个进程要独立拥有 4 GB的虚拟地址空间，而多个线程可以共享同一地址空间，线程的切换比进程的切换要快得多。</p><p><img src="https://bu.dusays.com/2025/01/13/67841d4328da3.png"></p><p>补充：RPC：分为两部分，用户调用接口 + 具体网络协议。后者由框架来实现。</p><p>具体网络协议是框架来实现的，把开发者要发出和接收的内容以某种应用层协议打包进行网络收发。</p><p>·HTTP也是一种网络协议，但包的内容是固定的，必须是：请求行 + 请求头 + 请求体</p><p>·RPC是一种自定义网络协议，由具体框架来定，比如SRPC里支持的RPC协议有：SRPC&#x2F;thrift&#x2F;BRPC&#x2F;tRPC</p><p>简单介绍到这里，后面具体学习了再谈！！！</p><h3 id="线程的创建与运行"><a href="#线程的创建与运行" class="headerlink" title="线程的创建与运行"></a>线程的创建与运行</h3><p><strong><code>pthread_create</code>函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">// 线程的创建</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_create</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">pthread_t</span>*restrict thread, </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> <span class="type">pthread_attr_t</span> * restrict attr,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">void</span> *(* start_routine)(<span class="type">void</span> *),</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">void</span>*restrict arg</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line">thread</span><br><span class="line"><span class="comment">// 保存新创建线程ID的变量地址值。线程与进程相同，也需要用于区分不同线程的ID。</span></span><br><span class="line">attr</span><br><span class="line"><span class="comment">// 用于传递线程属性的参数，传递NULL时，创建默认属性的线程。</span></span><br><span class="line"></span><br><span class="line">start_routine</span><br><span class="line"><span class="comment">// 相当于线程main函数的、在单独执行流中执行的函数地址值（函数指针）。</span></span><br><span class="line"></span><br><span class="line">arg</span><br><span class="line"><span class="comment">// 通过第三个参数传递调用函数时包含传递参数信息的变量地址值。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>pthread_join</code>函数<br>调用<code>pthread_join</code>函数的进程（或线程）将进入等待状态，直到第一个参数为ID的线程终止为止。而且可以得到线程的main函数返回值，所以该函数比较有用。下面通过示例了解该函数的功能。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> ** status)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">threadEntry</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* msg = <span class="string">&quot;i am from thread&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s thread begin: %s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (<span class="type">void</span>*)msg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lession94</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">pthread_t</span> tid;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* pInfo = <span class="string">&quot;hello world&quot;</span>; <span class="comment">// 全局的</span></span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, threadEntry,(<span class="type">void</span>*)pInfo);</span><br><span class="line"><span class="keyword">if</span> (ret != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">void</span>* result = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">pthread_join</span>(tid, &amp;result);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s from thread: %s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, result);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不要使用局部变量</p><h3 id="线程同步：互斥量"><a href="#线程同步：互斥量" class="headerlink" title="线程同步：互斥量"></a>线程同步：互斥量</h3><p>两个线程直接访问一个全局变量并进行对应的运算，结果是不确定的</p><p><strong>线程同步</strong>用于解决线程访问顺序引发的问题。需要同步的情况可以从如下两方面考虑。</p><p><strong>1</strong>、同时访问同一内存空间时发生的情况。</p><p><strong>2</strong>、需要指定访问同一内存空间的线程执行顺序的情况。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">thread_inc</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 实时性高，但抢占差</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">num++;</span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">10000</span>) <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s num is: %d\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">thread_dec</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 实时性差，但抢占高</span></span><br><span class="line"><span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">num--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//互斥量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lession95</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">pthread_mutex_init</span>(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_t</span> thread_id[<span class="number">50</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">2</span>) <span class="built_in">pthread_create</span>(thread_id + i, <span class="literal">NULL</span>, thread_inc, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">pthread_create</span>(thread_id + i, <span class="literal">NULL</span>, thread_dec, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">pthread_join</span>(thread_id[i], <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s num is: %d\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, num);</span><br><span class="line"><span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程同步：信号量"><a href="#线程同步：信号量" class="headerlink" title="线程同步：信号量"></a>线程同步：信号量</h3><p>信号量与互斥量极为相似，在互斥量的基础上很容易理解信号量</p><p>初始值为 1 的信号量，可以用作互斥锁（把信号值始终控制为1）</p><p>信号量创建及销毁方法如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="comment">// 参数一  创建信号量时传递保存信号量的变量地址值，销毁时传递需要销毁的信号量变量地址值。</span></span><br><span class="line"><span class="comment">// 参数二  决定几个线程</span></span><br><span class="line"><span class="comment">// 参数三  指定初始值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_init</span><span class="params">(<span class="type">sem_t</span>* sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_destroy</span><span class="params">(<span class="type">sem_t</span>* sem)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_post</span><span class="params">(<span class="type">sem_t</span>*sem)</span></span>;  <span class="comment">// V 操作</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_wait</span><span class="params">(<span class="type">sem_t</span> * sem)</span></span>;  <span class="comment">// P操作</span></span><br></pre></td></tr></table></figure><h3 id="线程的销毁"><a href="#线程的销毁" class="headerlink" title="线程的销毁"></a>线程的销毁</h3><p><strong>销毁线程的2种方法</strong></p><p>Linux线程并不是在首次调用的线程main函数返回时自动销毁，所以用如下2种方法之一加以明确。否则由线程创建的内存空间将一直存在。</p><p>1、调用pthread_join函数。</p><p>2、调用pthread_detach函数。</p><p>之前调用过pthread_join函数。调用该函数时，不仅会等待线程终止，还会引导线程销毁。但该函数的问题是，线程终止前，调用该函数的线程将进入阻塞状态。因此，通常通过如下函数调用引导线程销毁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span></span>;</span><br></pre></td></tr></table></figure><p>调用 <strong>pthread_detach</strong>函数不会引起线程终止或进入阻塞状态，可以通过该函数引导销毁线程创建的内存空间。</p><p><code>pthread_detach(pthread_self());</code> </p><p><code>pthread_exit(0) ;</code></p><p>调用以上线程函数来进行自动销毁无需外部的操作</p><h3 id="多线程并发服务器的实现"><a href="#多线程并发服务器的实现" class="headerlink" title="多线程并发服务器的实现"></a>多线程并发服务器的实现</h3><p><strong>聊天室项目：网络编程 + 多线程 + 线程同步实现的 聊天服务器和客户端</strong></p><p>以前进程是，每有客户端连接，fork一次，现在是开一个线程来和客户端进行沟通，主的在等待</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> clnt_socks[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">int</span> clnt_cnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向所有已连接的客户端发送消息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">send_msg</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg, <span class="type">ssize_t</span> str_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">pthread_mutex_lock</span>(&amp;mutex1);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; clnt_cnt; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (clnt_socks[i] &gt;= <span class="number">0</span>)</span><br><span class="line"><span class="built_in">write</span>(clnt_socks[i], msg, str_len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>(&amp;mutex1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">handle_clnt</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">pthread_detach</span>(<span class="built_in">pthread_self</span>());</span><br><span class="line"><span class="type">int</span> clnt_sock = *(<span class="type">int</span>*)arg;</span><br><span class="line"><span class="type">char</span> msg[<span class="number">1024</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> str_len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((str_len = <span class="built_in">read</span>(clnt_sock, msg, <span class="built_in">sizeof</span>(msg))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//<span class="doctag">TODO:</span>过滤敏感词</span></span><br><span class="line"><span class="built_in">send_msg</span>(msg, str_len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pthread_mutex_lock</span>(&amp;mutex1);</span><br><span class="line"><span class="comment">//for (int i = 0; i &lt; clnt_cnt; i++) &#123;//TDDO:优化逻辑</span></span><br><span class="line"><span class="comment">//if (clnt_sock == clnt_socks[i]) &#123;</span></span><br><span class="line"><span class="comment">//clnt_socks[i] = -1;</span></span><br><span class="line"><span class="comment">//break;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">*(<span class="type">int</span>*)arg = <span class="number">-1</span>;</span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>(&amp;mutex1);</span><br><span class="line"><span class="built_in">close</span>(clnt_sock);</span><br><span class="line"><span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">server98</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> serv_sock, clnt_sock;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_adr, clnt_adr;</span><br><span class="line"><span class="type">socklen_t</span> clnt_adr_sz = <span class="built_in">sizeof</span>(clnt_adr);</span><br><span class="line">serv_sock = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_adr));</span><br><span class="line">serv_adr.sin_family = AF_INET;</span><br><span class="line">serv_adr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">serv_adr.sin_port = <span class="built_in">htons</span>(<span class="number">9527</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化一个互斥锁，保护共享资源。NULL表示默认属性</span></span><br><span class="line"><span class="built_in">pthread_mutex_init</span>(&amp;mutex1, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">bind</span>(serv_sock, (<span class="keyword">struct</span> sockaddr*)&amp;serv_adr, <span class="built_in">sizeof</span>(serv_adr)) == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;bind error %d %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">listen</span>(serv_sock, <span class="number">5</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;listen error %d %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;<span class="comment">//while(1)等价</span></span><br><span class="line">        <span class="comment">//accept函数会阻塞，直到有客户端连接。如果成功，返回一个新的套接字描述符clnt_sock</span></span><br><span class="line">clnt_sock = <span class="built_in">accept</span>(serv_sock, (<span class="keyword">struct</span> sockaddr*)&amp;clnt_adr, &amp;clnt_adr_sz);</span><br><span class="line"><span class="keyword">if</span> (clnt_sock == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;accept error %d %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 锁定互斥锁mutex1，以防止多个线程同时访问共享资源clnt_socks和clnt_cnt。</span></span><br><span class="line"><span class="built_in">pthread_mutex_lock</span>(&amp;mutex1);</span><br><span class="line">clnt_socks[clnt_cnt++] = clnt_sock;</span><br><span class="line">        <span class="comment">// 解锁互斥锁mutex1。</span></span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>(&amp;mutex1);</span><br><span class="line"><span class="type">pthread_t</span> thread;</span><br><span class="line">        <span class="comment">// 创建一个新的线程，执行handle_clnt函数</span></span><br><span class="line"><span class="comment">// 并将新接受的客户端套接字描述符的地址作为参数传递给handle_clnt函数。NULL表示使用默认的线程属性。</span></span><br><span class="line"><span class="built_in">pthread_create</span>(&amp;thread, <span class="literal">NULL</span>, handle_clnt, &amp;clnt_socks[clnt_cnt - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(serv_sock);</span><br><span class="line">    <span class="comment">// 销毁互斥锁mutex1。</span></span><br><span class="line"><span class="built_in">pthread_mutex_destroy</span>(&amp;mutex1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">sem_t</span> semid;</span><br><span class="line"><span class="type">char</span> name[<span class="number">64</span>] = <span class="string">&quot;[DEFAULT]&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">client_send_msg</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line"><span class="built_in">pthread_detach</span>(<span class="built_in">pthread_self</span>());</span><br><span class="line">    <span class="comment">// 从传入的参数中获取客户端套接字描述符</span></span><br><span class="line"><span class="type">int</span> sock = *(<span class="type">int</span>*)arg;</span><br><span class="line"><span class="type">char</span> msg[<span class="number">256</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line"><span class="built_in">fgets</span>(msg, <span class="built_in">sizeof</span>(msg), stdin);</span><br><span class="line"><span class="keyword">if</span> ((<span class="built_in">strcmp</span>(msg, <span class="string">&quot;q\n&quot;</span>) == <span class="number">0</span>) || (<span class="built_in">strcmp</span>(msg, <span class="string">&quot;Q\n&quot;</span>) == <span class="number">0</span>)) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">snprintf</span>(buffer, <span class="built_in">sizeof</span>(msg), <span class="string">&quot;%s %s&quot;</span>, name, msg);</span><br><span class="line"><span class="built_in">write</span>(sock, buffer, <span class="built_in">strlen</span>(buffer));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sem_post</span>(&amp;semid);  <span class="comment">// V操作</span></span><br><span class="line"><span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">client_recv_msg</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line"><span class="built_in">pthread_detach</span>(<span class="built_in">pthread_self</span>());</span><br><span class="line"><span class="type">int</span> sock = *(<span class="type">int</span>*)arg;</span><br><span class="line"><span class="type">char</span> msg[<span class="number">256</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 套接字sock读取数据，存储到msg中，str_len为读取的字节数。</span></span><br><span class="line"><span class="type">ssize_t</span> str_len = <span class="built_in">read</span>(sock, msg, <span class="built_in">sizeof</span>(msg));</span><br><span class="line"><span class="keyword">if</span> (str_len &lt;= <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line"><span class="built_in">fputs</span>(msg, stdout);</span><br><span class="line"><span class="built_in">memset</span>(msg, <span class="number">0</span>, str_len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sem_post</span>(&amp;semid);  <span class="comment">// V 操作</span></span><br><span class="line"><span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>); <span class="comment">// 线程结束</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">client98</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> sock = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr;</span><br><span class="line"><span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">serv_addr.sin_family = AF_INET;</span><br><span class="line">serv_addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">serv_addr.sin_port = <span class="built_in">htons</span>(<span class="number">9527</span>);</span><br><span class="line"><span class="built_in">fputs</span>(<span class="string">&quot;input your name:&quot;</span>, stdout);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, name);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">connect</span>(sock, (<span class="keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr)) == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;connect error %d %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 定义两个线程标识符thsend和threcv，分别用于发送和接收消息的线程。</span></span><br><span class="line"><span class="type">pthread_t</span> thsend, threcv;</span><br><span class="line">    <span class="comment">// 初始化信号量semid。0表示信号量是进程内共享的，-1是信号量的初始值。</span></span><br><span class="line"><span class="built_in">sem_init</span>(&amp;semid, <span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 给线程绑定主函数</span></span><br><span class="line">    <span class="comment">// (void*)&amp;sock  参数</span></span><br><span class="line"><span class="built_in">pthread_create</span>(&amp;thsend, <span class="literal">NULL</span>, client_send_msg, (<span class="type">void</span>*)&amp;sock);</span><br><span class="line"><span class="built_in">pthread_create</span>(&amp;threcv, <span class="literal">NULL</span>, client_recv_msg, (<span class="type">void</span>*)&amp;sock);</span><br><span class="line"><span class="built_in">sem_wait</span>(&amp;semid);  <span class="comment">// P操作</span></span><br><span class="line"><span class="built_in">close</span>(sock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lession98</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">&quot;s&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">server98</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">client98</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统编程03进程通信</title>
      <link href="/2025/01/12/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B03%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
      <url>/2025/01/12/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B03%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="进程的概念以及应用"><a href="#进程的概念以及应用" class="headerlink" title="进程的概念以及应用"></a>进程的概念以及应用</h3><p>​占用内存空间的正在运行的程序即为进程</p><p>​从操作系统的角度看，进程是程序流的基本单位，若创建多个进程，则操作系统将同时运行。有时一个程序运行过程中也会产生多个进程。</p><p>CPU核的个数与进程数   ：一个CPU中可能包含多个运算设备（核）。核的个数与可同时运行的进程数相同。</p><p>若进程数超过了核数，进程将分时使用CPU资源。</p><p>进程ID：1 要分配给操作系统启动后的（用于协助操作系统）首个进程，因此用户进程无法得到ID值1</p><p><strong>创建进程</strong></p><p>通过调用fork函数创建进程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> pid = fork();</span><br></pre></td></tr></table></figure><p>fork函数将创建调用的进程副本，也就是说，是复制正在运行的、调用fork函数的进程。另外两个进程都将执行fork调用后的语句（fork函数返回后）。同一个进程、复制相同的内存空间，之后的程序要根据fork函数的返回值加以区分。即利用fork函数的如下特点区分程序执行流程。</p><p>​父进程：fork函数返回子进程ID.</p><p>​子进程：fork函数返回0</p><p><strong>僵尸进程</strong></p><p>产生僵尸进程的原因：</p><p>​调用fork函数产生子进程的终止方式。</p><ol><li><p>传递参数并调用exit函数。</p></li><li><p>main函数中执行return语句并返回值。</p><p>向exit函数传递的参数值和main函数的return语句返回值都是会传递给操作系统。而操作系统不会销毁子进程，直到这些值传递给产生改子进程的父进程。处在这种状态下的进程就是僵尸进程。将子进程变成僵尸进程的正是操作系统。</p></li></ol><p>僵尸进程怎么销毁呢？     应该向创建子进程的父进程传递子进程的exit参数值或return语句的返回值。</p><p>​操作系统不会主动把这些值传递给父进程。只有父进程主动发起请求（函数调用）时，操作系统才会传递该值。如果父进程未主动要求获得子进程的结束状态值，操作系统将一直保存，并让子进程长时间处于僵尸进程状态。也就是说，父母要负责收回自己生的孩子。我们来创建一个僵尸进程。</p><h5 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a><strong>信号处理</strong></h5><p>我们已经知道了进程创建及销毁方法，但还有一个问题没解决。</p><p>“子进程究竟何时终止?调用waitpid函数后要无休止地等待吗?”</p><p>父进程往往与子进程一样繁忙，因此不能只调用waitpid函数以等待子进程终止。</p><p>方法：</p><p><em><strong>*向操作系统求助*</strong></em></p><p>子进程终止的识别主体是操作系统，因此，若操作系统能把如下信息告诉正忙于工作的父进程，将有助于构建高效的程序。</p><p>“嘿，父进程!你创建的子进程终止了!”</p><p>此时父进程将暂时放下工作，处理子进程终止相关事宜。这就是信号处理（Signal Handling）机制。此处的”信号”是在<strong>特定事件</strong>发生时由<strong>操作系统</strong>向进程发送的消息。另外，为了响应该消息，执行与消息相关的自定义操作的过程称为”信号处理”。</p><p><img src="https://bu.dusays.com/2025/03/05/67c8037a2462e.png"></p><p>防止僵尸进程的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理SIGCHLD 信号函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_childproc</span><span class="params">(<span class="type">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="comment">// 回收僵尸进程</span></span><br><span class="line">    pid = <span class="built_in">waitpid</span>(<span class="number">-1</span>,&amp;status,WNOHANG);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Removed proc id: %d \n&quot;</span>, pid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// main函数中防止僵尸进程的代码</span></span><br><span class="line"><span class="type">pid_t</span> pid;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sigaction</span> act;</span><br><span class="line"><span class="type">socklen_t</span> adr_sz;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数名字就是一个指针，这里就是指针的赋值</span></span><br><span class="line"><span class="comment">// act.sa_handler是一个函数指针</span></span><br><span class="line">act.sa_handler = read_childproc;</span><br><span class="line"><span class="built_in">sigemptyset</span>(&amp;act.sa_mask);</span><br><span class="line">act.sa_flags = <span class="number">0</span>;</span><br><span class="line">state = <span class="built_in">sigaction</span>(SIGCHLD,&amp;act,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (state == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">error_handling</span>(<span class="string">&quot;sigaction() error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>R SIGALRM∶已到通过调用alarm函数注册的时间。</p><p>R SIGINT∶输入CTRL+C。  </p><p>R SIGCHLD∶子进程终止。（英文为child）</p><p>1、”子进程终止则调用mychild函数。”</p><p>代码：signal(SIGCHLD, mychild);</p><p>此时mychild函数的参数应为int，返回值类型应为void。对应signal函数的第二个参数。另外，常数SIGCHLD表示子进程终止的情况，应成为signal函数的第一个参数。</p><p>2、”已到通过alarm函数注册的时间，请调用timeout函数。”</p><p>3、”输入CTRL+C时调用keycontrol函数。”</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">lession82</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// 父进程睡眠30秒  给子进程足够的时间来执行。</span></span><br><span class="line"><span class="built_in">sleep</span>(<span class="number">30</span>);</span><br><span class="line"><span class="type">int</span> status;</span><br><span class="line"><span class="built_in">waitpid</span>(pid, &amp;status, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>信号处理函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">signal_func</span><span class="params">(<span class="type">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (sig)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> SIGALRM:  <span class="comment">// 闹钟信号</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;tid %d pid %d\n&quot;</span>, <span class="built_in">pthread_self</span>(), <span class="built_in">getpid</span>());</span><br><span class="line">        <span class="built_in">alarm</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SIGINT:   <span class="comment">// 通常由用户按下 Ctrl + C 产生</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Ctrl + C press...&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lession83</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 打印当前的线程id和  进程id</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;=====tid %d pid %d\n&quot;</span>, <span class="built_in">pthread_self</span>(), <span class="built_in">getpid</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 把signal_func函数分别注册为SIGALRM信号、SIGINT信号的处理函数</span></span><br><span class="line">    <span class="built_in">signal</span>(SIGALRM, signal_func);</span><br><span class="line">    <span class="built_in">signal</span>(SIGINT, signal_func);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用 alarm(1) 设置一个 1 秒的闹钟，1 秒后会触发 SIGALRM 信号。</span></span><br><span class="line">    <span class="built_in">alarm</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;=====tid %d pid %d\n&quot;</span>, <span class="built_in">pthread_self</span>(), <span class="built_in">getpid</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>利用Sigaction函数 进行信号处理</strong></p><p>​singnal在UNIX系列的不同操作系统中可能存在区别，但sigaction完全相同。</p><p><strong>进程通信：为了方便进程交换信息，在内核提供缓冲区进行数据交换的机制。</strong></p><p>操作系统提供了两个进程可以同时访问的内存空间。</p><p>交换数据时基于开发 &#x2F; 权限 的</p><p>缓冲区两边像是有俩齿轮一样，如果是比作商店的话，一边是放进去东西，一边是拿出去东西，形成了消息处理的流水线。</p><h4 id="进程间通信：管道"><a href="#进程间通信：管道" class="headerlink" title="进程间通信：管道"></a>进程间通信：管道</h4><p><strong>单管道</strong></p><p><img src="https://bu.dusays.com/2025/01/12/6783c9daa4ad9.png"></p><p>为了完成进程间通信，需要创建管道。管道并非属于进程的资源，而是和套接字一样，属于操作系统（也就不是fork函数的复制对象）。所以，两个进程通过操作系统提供的内存空间进行通信。</p><p>父进程调用该函数时将<strong>创建管道</strong>，同时获取对应于出入口的文件描述符号</p><p><code>Filedes[0]</code> 通过管道接收数据时使用的文件描述符，即管道出口。</p><p><code>Filedes[1]</code> 通过管道传输数据时使用的文件描述符，即管道入口。</p><p>父进程创建子进程的时候，自己的资源镜像复制到子进程里面，所以父进程创建了管道子进程是有这个信息的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">singlePipe</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 两个文件描述符</span></span><br><span class="line"><span class="type">int</span> fds[<span class="number">2</span>] = &#123; <span class="number">-1</span>,<span class="number">-1</span> &#125;;</span><br><span class="line"><span class="type">char</span> str[<span class="number">128</span>] = <span class="string">&quot;send by sub process!!!\n&quot;</span>;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">128</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="built_in">pipe</span>(fds);</span><br><span class="line"><span class="type">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">write</span>(fds[<span class="number">1</span>], str, <span class="built_in">sizeof</span>(str));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">read</span>(fds[<span class="number">0</span>], buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s(%d): %s server: %s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>双管道</strong></p><p>1个管道无法完成双向通信任务，有时候需要创建2个管道，各自负责不同的数据流动即可。</p><p><img src="https://bu.dusays.com/2025/01/12/6783d16c0a2b6.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">doublePipe</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 两个方向各有俩文件描述符</span></span><br><span class="line"><span class="type">int</span> s2c[<span class="number">2</span>], c2s[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">pipe</span>(s2c);</span><br><span class="line"><span class="built_in">pipe</span>(c2s);</span><br><span class="line"><span class="type">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> buffer[<span class="number">256</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="built_in">write</span>(c2s[<span class="number">1</span>], <span class="string">&quot;hello,i am subprocess!\n&quot;</span>, <span class="number">23</span>);</span><br><span class="line"><span class="built_in">read</span>(s2c[<span class="number">0</span>], buffer, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s(%d): %s server: %s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, buffer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">char</span> buffer[<span class="number">256</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span>(c2s[<span class="number">0</span>], buffer, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line"><span class="built_in">write</span>(s2c[<span class="number">1</span>], <span class="string">&quot;hello,i am mainprocess\n&quot;</span>, <span class="number">23</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s(%d): %s server: %s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, buffer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s(%d): %s server: %d\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, <span class="built_in">getpid</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="进程间通信：FIFO"><a href="#进程间通信：FIFO" class="headerlink" title="进程间通信：FIFO"></a>进程间通信：FIFO</h4><p>​对比pipe管道，他已经可以完成在两个进程之间通信的任务，不过它似乎完成的不够好，也可以说是不够彻底。它只能在两个有<strong>亲戚关系</strong>的进程之间进行通信，这就大大限制了pipe管道的应用范围。</p><p>​<code>fifo</code>管道的本质是操作系统中的命名文件，当然Linux的理念就是万物皆文件，它在操作系统中以命名文件的形式存在，我们可以在操作系统中看见<code>fifo</code>管道，在你有权限的情况下，甚至可以读写他们。</p><p>内核会针对<code>fifo</code>文件开辟一个缓冲区，操作FIFO文件，可以操作缓冲区，实现进程通信。一旦使用<code>mkfifo</code>创建了一个FIFO，就可以使用open打开它，常见的文件IO函数都可以用于<code>FIFO</code>。如：<code>close</code>、<code>read</code>、<code>write</code>、<code>unlink</code>等 .</p><p>这样的话  一个进程对应一个管道，大大减少了管道的数量。</p><p><strong>打开FIFO文件的时候，read端会阻塞等待write端打开open，write端同理，也会阻塞等待另外一端打开。</strong></p><p>大概就是下图所示</p><p><img src="https://bu.dusays.com/2025/03/05/67c85594c01ab.png"></p><h4 id="进程间通信：共享内存"><a href="#进程间通信：共享内存" class="headerlink" title="进程间通信：共享内存"></a>进程间通信：共享内存</h4><p>​共享内存允许不同进程之间<strong>共享同一段逻辑内存</strong>，对于这段内存，它们都能访问，或者修改它，没有任何限制。所以它是<strong>进程间传递大量数据</strong>的一种非常有效的方式。“共享内存允许不同进程之间共享同一段逻辑内存”，这里是逻辑内存。也就是说共享内存的进程访问的可以不是同一段物理内存，这个没有明确的规定，但是大多数的系统实现都将进程之间的共享内存安排为同一段物理内存。</p><p><strong>使用共享内存的步骤通常是：</strong></p><p>1）创建或获取一段共享内存；</p><p>2）将上一步创建的共享内存映射到该进程的地址空间；</p><p>3）访问共享内存；</p><p>4）将共享内存从当前的进程地址空间分离；</p><p>5）删除这段共享内存；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">lession90</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// . 表明当前的路径 </span></span><br><span class="line"><span class="comment">//  ftok(&quot;.&quot;,1)文件目录不一样   后面的数字也不一样 </span></span><br><span class="line">        <span class="comment">// 用于创建或获取一个共享内存段。如果IPC_CREAT标志被设置，且指定的内存段不存在，则创建一个新的共享内存段。</span></span><br><span class="line"><span class="type">int</span> shm_id = <span class="built_in">shmget</span>(<span class="built_in">ftok</span>(<span class="string">&quot;.&quot;</span>,<span class="number">1</span>), <span class="built_in">sizeof</span>(STUDENT), IPC_CREAT | <span class="number">0666</span>);</span><br><span class="line"><span class="keyword">if</span> (shm_id == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s(%d): %s create share memeory failed!\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用函数shmat()来映射共享内存</span></span><br><span class="line">PSTUDENT pStu = (PSTUDENT)<span class="built_in">shmat</span>(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">pStu-&gt;id = <span class="number">666666</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(pStu-&gt;name, <span class="string">&quot;买买提&quot;</span>);</span><br><span class="line">pStu-&gt;age = <span class="number">18</span>;</span><br><span class="line">pStu-&gt;sex = <span class="literal">true</span>;</span><br><span class="line">pStu-&gt;sig = <span class="number">99</span>;</span><br><span class="line"><span class="comment">// 两边需要同步   不同步直接删除映射就拿不到数据</span></span><br><span class="line"><span class="keyword">while</span> (pStu-&gt;sig == <span class="number">99</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">usleep</span>(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 删除映射</span></span><br><span class="line"><span class="built_in">shmdt</span>(pStu);</span><br><span class="line"><span class="built_in">shmctl</span>(shm_id, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123; <span class="comment">// 子进程</span></span><br><span class="line"><span class="built_in">usleep</span>(<span class="number">500000</span>); <span class="comment">// 等待父进程写入</span></span><br><span class="line"><span class="type">int</span> shm_id = <span class="built_in">shmget</span>(<span class="built_in">ftok</span>(<span class="string">&quot;.&quot;</span>, <span class="number">1</span>), <span class="built_in">sizeof</span>(STUDENT), IPC_CREAT | <span class="number">0666</span>);</span><br><span class="line"><span class="keyword">if</span> (shm_id == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s(%d): %s create share memeory failed!\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用函数shmat()来映射共享内存</span></span><br><span class="line">PSTUDENT pStu = (PSTUDENT)<span class="built_in">shmat</span>(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span> (pStu-&gt;sig != <span class="number">99</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">usleep</span>(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d, %s,%d,%s\n&quot;</span>, pStu-&gt;id, pStu-&gt;name, pStu-&gt;age, pStu-&gt;sex ? <span class="string">&quot;男&quot;</span> : <span class="string">&quot;女&quot;</span>);</span><br><span class="line">pStu-&gt;sig = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">shmdt</span>(pStu);</span><br><span class="line"><span class="built_in">shmctl</span>(shm_id, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="进程间通信：信号量"><a href="#进程间通信：信号量" class="headerlink" title="进程间通信：信号量"></a>进程间通信：信号量</h4><ul><li>假设没有信号量，父子进程可能会同时访问共享内存，导致数据不一致。例如，父进程可能正在写入数据，而子进程同时尝试读取尚未完全写入的数据。通过信号量的 P 操作（<code>semop</code>函数，<code>sem_op</code>为 - 1）和 V 操作（<code>semop</code>函数，<code>sem_op</code>为 1），可以确保在某一时刻只有一个进程能够访问共享内存中的关键区域。比如，子进程在读取共享内存中的学生信息之前，先对信号量进行 P 操作，等待父进程完成写入并执行 V 操作释放资源后，子进程才能读取，从而避免了数据竞争和不一致性。</li></ul><p>原来共享内存有很严重的时间差，降低了效率。</p><p>为了防止出现因多个程序同时访问一个共享资源而引发的一系列问题，我们需要一种方法，它可以通过生成并使用令牌来授权，在任一时刻只能有一个执行线程访问代码的临界区域。临界区域是指执行数据更新的代码需要独占式地执行。而信号量就可以提供这样的一种访问机制，让一个临界区同一时间只有一个线程在访问它，也就是说信号量是用来调协进程对共享资源的访问的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">lession91</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;<span class="comment">//父进程</span></span><br><span class="line"><span class="comment">// 使用ftok函数生成一个唯一的键值key，用于创建信号量。</span></span><br><span class="line"><span class="type">key_t</span> key = <span class="built_in">ftok</span>(<span class="string">&quot;.&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// semget函数创建一个信号量集，包含 2 个信号量，权限为0666。</span></span><br><span class="line"><span class="type">int</span> sem_id = <span class="built_in">semget</span>(key, <span class="number">2</span>, IPC_CREAT | <span class="number">0666</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用semctl函数初始化两个信号量的值为 0。</span></span><br><span class="line"><span class="built_in">semctl</span>(sem_id, <span class="number">0</span>, SETVAL, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">semctl</span>(sem_id, <span class="number">1</span>, SETVAL, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//调用shmget函数创建一个共享内存段，大小为sizeof(STUDENT)，权限为0666。</span></span><br><span class="line"><span class="type">int</span> shm_id = <span class="built_in">shmget</span>(<span class="built_in">ftok</span>(<span class="string">&quot;.&quot;</span>, <span class="number">1</span>), <span class="built_in">sizeof</span>(STUDENT), IPC_CREAT | <span class="number">0666</span>);</span><br><span class="line"><span class="keyword">if</span> (shm_id == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s create share memeory failed!\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将共享内存段附加到进程的地址空间，返回一个指向共享内存的指针pStu。</span></span><br><span class="line"><span class="comment">//映射</span></span><br><span class="line">PSTUDENT pStu = (PSTUDENT)<span class="built_in">shmat</span>(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">pStu-&gt;id = <span class="number">666666</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(pStu-&gt;name, <span class="string">&quot;abcdefghijklmn&quot;</span>);</span><br><span class="line">pStu-&gt;age = <span class="number">18</span>;</span><br><span class="line">pStu-&gt;sex = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//信号量</span></span><br><span class="line">sembuf sop = &#123;</span><br><span class="line">.sem_num = <span class="number">0</span>,</span><br><span class="line">.sem_op = <span class="number">1</span>  <span class="comment">// 为正数，semop就是V操作</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取信号量的值，</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s %d\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, <span class="built_in">semctl</span>(sem_id, <span class="number">0</span>, GETVAL));</span><br><span class="line"><span class="built_in">semop</span>(sem_id, &amp;sop, <span class="number">1</span>);<span class="comment">//V操作</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s %d\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, <span class="built_in">semctl</span>(sem_id, <span class="number">0</span>, GETVAL));</span><br><span class="line">sop.sem_num = <span class="number">1</span>;</span><br><span class="line">sop.sem_op = <span class="number">-1</span>;  <span class="comment">// 为负数，semop为P操作</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s %d\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, <span class="built_in">semctl</span>(sem_id, <span class="number">1</span>, GETVAL));</span><br><span class="line"><span class="built_in">semop</span>(sem_id, &amp;sop, <span class="number">1</span>);<span class="comment">//P操作</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s %d\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, <span class="built_in">semctl</span>(sem_id, <span class="number">1</span>, GETVAL));</span><br><span class="line"></span><br><span class="line"><span class="comment">//将共享内存段从进程的地址空间分离</span></span><br><span class="line"><span class="built_in">shmdt</span>(pStu);</span><br><span class="line"><span class="comment">//删除共享内存段。</span></span><br><span class="line"><span class="built_in">shmctl</span>(shm_id, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//删除信号量</span></span><br><span class="line"><span class="built_in">semctl</span>(sem_id, <span class="number">0</span>, IPC_RMID);</span><br><span class="line"><span class="built_in">semctl</span>(sem_id, <span class="number">1</span>, IPC_RMID);</span><br><span class="line"><span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//子进程</span></span><br><span class="line"><span class="type">key_t</span> key = <span class="built_in">ftok</span>(<span class="string">&quot;.&quot;</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">//semget和shmget函数获取已存在的信号量和共享内存段。</span></span><br><span class="line"><span class="type">int</span> sem_id = <span class="built_in">semget</span>(key, <span class="number">2</span>, IPC_CREAT);</span><br><span class="line"><span class="type">int</span> shm_id = <span class="built_in">shmget</span>(<span class="built_in">ftok</span>(<span class="string">&quot;.&quot;</span>, <span class="number">1</span>), <span class="built_in">sizeof</span>(STUDENT), IPC_CREAT | <span class="number">0666</span>);</span><br><span class="line"><span class="keyword">if</span> (shm_id == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s create share memeory failed!\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sembuf sop = &#123;</span><br><span class="line">.sem_num = <span class="number">0</span>,</span><br><span class="line">.sem_op = <span class="number">-1</span><span class="comment">//P操作</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s %d\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, <span class="built_in">semctl</span>(sem_id, <span class="number">0</span>, GETVAL));</span><br><span class="line"><span class="built_in">semop</span>(sem_id, &amp;sop, <span class="number">1</span>);<span class="comment">//P操作</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s %d\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, <span class="built_in">semctl</span>(sem_id, <span class="number">0</span>, GETVAL));</span><br><span class="line">PSTUDENT pStu = (PSTUDENT)<span class="built_in">shmat</span>(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//信号量</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d ,%s,%d,%s\n&quot;</span>, pStu-&gt;id, pStu-&gt;name, pStu-&gt;age, pStu-&gt;sex ? <span class="string">&quot;male&quot;</span> : <span class="string">&quot;female&quot;</span>);</span><br><span class="line">sop.sem_num = <span class="number">1</span>;</span><br><span class="line">sop.sem_op = <span class="number">1</span>;<span class="comment">//V操作</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s %d\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, <span class="built_in">semctl</span>(sem_id, <span class="number">1</span>, GETVAL));</span><br><span class="line"><span class="built_in">semop</span>(sem_id, &amp;sop, <span class="number">1</span>);<span class="comment">//V操作</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s %d\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, <span class="built_in">semctl</span>(sem_id, <span class="number">1</span>, GETVAL));</span><br><span class="line"><span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//共享内存段分离</span></span><br><span class="line"><span class="built_in">shmdt</span>(pStu);</span><br><span class="line"><span class="built_in">shmctl</span>(shm_id, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="进程间通信：消息队列"><a href="#进程间通信：消息队列" class="headerlink" title="进程间通信：消息队列"></a>进程间通信：消息队列</h4><p><strong>消息队列</strong>提供了一种从一个进程向另一个进程发送一个数据块的方法。 每个数据块都被认为含有一个类型，接收进程可以独立地接收含有不同类型的数据结构。我们可以通过发送消息来避免命名管道的同步和阻塞问题。但是消息队列与命名管道FIFO一样，每个数据块都有一个最大长度的限制。</p><p>1️⃣ <code>msgget</code>函数  创建和访问一个消息队列   在示例中，子进程和父进程都有</p><p>2️⃣ <code>msgsnd</code>函数  用来把消息添加到队列。</p><p>3️⃣ <code>msgrcv</code>函数  用来从一个消息队列获取消息。</p><p>4️⃣ <code>msgctl</code> 函数 用来控制消息队列，它与共享内存的<code>shmctl</code>函数类似，删除消息队列。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">lession92</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// msg 的接受</span></span><br><span class="line"><span class="comment">// 有的linux系统无法实现</span></span><br><span class="line"><span class="type">int</span> msg_id = <span class="built_in">msgget</span>(<span class="built_in">ftok</span>(<span class="string">&quot;.&quot;</span>, <span class="number">3</span>), IPC_CREAT | <span class="number">0666</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s %d %d\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, msg_id, errno);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line"><span class="keyword">if</span> (msg_id == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">MSG msg;</span><br><span class="line"><span class="built_in">memset</span>(&amp;msg, <span class="number">0</span>, <span class="built_in">sizeof</span>(msg));</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//msgrcv 函数的参数依次为：消息队列 ID、接收消息的缓冲区、消息数据部分的大小、期望接收的消息类型（这里为 1）、接收标志（这里为 0）。</span></span><br><span class="line"><span class="type">ssize_t</span> ret = <span class="built_in">msgrcv</span>(msg_id, &amp;msg, <span class="built_in">sizeof</span>(msg.data), <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">usleep</span>(<span class="number">1000</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d name: %s age: %d msg: %s\n&quot;</span>,</span><br><span class="line">msg.data.id, msg.data.name, msg.data.age, msg.data.message);</span><br><span class="line"><span class="built_in">getchar</span>();</span><br><span class="line"><span class="built_in">msgctl</span>(msg_id, IPC_RMID, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">int</span> msg_id = <span class="built_in">msgget</span>(<span class="built_in">ftok</span>(<span class="string">&quot;.&quot;</span>, <span class="number">3</span>), IPC_CREAT | <span class="number">0666</span>);</span><br><span class="line">MSG msg;</span><br><span class="line"><span class="built_in">memset</span>(&amp;msg, <span class="number">0</span>, <span class="built_in">sizeof</span>(msg));</span><br><span class="line">msg.type = <span class="number">1</span>;</span><br><span class="line">msg.data.id = <span class="number">6666</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(msg.data.name, <span class="string">&quot;Bingo&quot;</span>);</span><br><span class="line">msg.data.age = <span class="number">18</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(msg.data.message, <span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;***%d name: %s age: %d msg: %s\n&quot;</span>,</span><br><span class="line">msg.data.id, msg.data.name, msg.data.age, msg.data.message);</span><br><span class="line"><span class="comment">//msgsnd 函数将消息发送到消息队列</span></span><br><span class="line"><span class="built_in">msgsnd</span>(msg_id, &amp;msg, <span class="built_in">sizeof</span>(msg.data), <span class="number">0</span>);</span><br><span class="line"><span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//使用 msgctl 函数删除消息队列。</span></span><br><span class="line"><span class="built_in">msgctl</span>(msg_id, IPC_RMID, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>待续。。。。</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统编程02客户端服务器端模型</title>
      <link href="/2025/01/12/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B02%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%A8%A1%E5%9E%8B/"/>
      <url>/2025/01/12/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B02%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="简单的TCP-客户端-服务器模型"><a href="#简单的TCP-客户端-服务器模型" class="headerlink" title="简单的TCP 客户端 - 服务器模型"></a>简单的TCP 客户端 - 服务器模型</h3><h4 id="run-client函数"><a href="#run-client函数" class="headerlink" title="run_client函数"></a><code>run_client</code>函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">run_client</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个TCP套接字</span></span><br><span class="line">    <span class="type">int</span> client = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    PF_INET 指定协议族为 IPv4</span></span><br><span class="line"><span class="comment">    SOCK_STREAM：指定套接字类型为流套接字</span></span><br><span class="line"><span class="comment">    0：指定协议类型，这里使用默认协议</span></span><br><span class="line"><span class="comment">    如果socket函数成功创建套接字，会返回一个非负整数作为套接字描述符；如果失败，返回-1。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 定义一个struct sockaddr_in类型的变量addr，用于存储地址信息。</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> servaddr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化服务器地址结构体</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="built_in">sizeof</span>(servaddr));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//指定地址族为 IPv4，AF代表 “Address Family”，AF_INET和前面的PF_INET相对应。</span></span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    <span class="comment">// 设置服务器IP地址为本地回环地址127.0.0.1</span></span><br><span class="line">    servaddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    <span class="comment">// 设置服务器端口号为9527</span></span><br><span class="line">    servaddr.sin_port = <span class="built_in">htons</span>(<span class="number">9527</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接到服务器</span></span><br><span class="line">    <span class="comment">// 将客户端套接字（client）连接到指定的服务器地址（servaddr）。</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">connect</span>(client, (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="built_in">sizeof</span>(servaddr));</span><br><span class="line">    <span class="comment">// 连接成功，ret的值为 0；如果连接失败，ret的值为 -1，并且会设置相应的错误码。</span></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 输出当前文件、行号和函数名，表示连接成功</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">256</span>] = <span class="string">&quot;hello,hello\n&quot;</span>;</span><br><span class="line">        <span class="comment">// 向服务器发送消息</span></span><br><span class="line">        <span class="comment">// client是套接字描述符，buffer是要发送的数据缓冲区，sizeof(buffer)表示要发送的数据长度。</span></span><br><span class="line">        <span class="built_in">write</span>(client, buffer, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">        <span class="comment">// 清空缓冲区</span></span><br><span class="line">        <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">        <span class="comment">// 从服务器读取响应</span></span><br><span class="line">        <span class="built_in">read</span>(client, buffer, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">        <span class="comment">// 输出服务器的响应</span></span><br><span class="line">        std::cout &lt;&lt; buffer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 输出连接失败的错误信息</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s %d\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭套接字</span></span><br><span class="line">    <span class="built_in">close</span>(client);</span><br><span class="line">    <span class="comment">// 输出客户端完成信息</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;client done!!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="run-server-函数"><a href="#run-server-函数" class="headerlink" title="run_server()函数"></a><code>run_server()</code>函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">lession63_</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> server, client;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> seraddr, clientaddr;</span><br><span class="line">    <span class="type">socklen_t</span> cliaddrlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个TCP套接字</span></span><br><span class="line">    server = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (server &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 输出错误信息并返回</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;error！！\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化服务器地址结构体</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;seraddr, <span class="number">0</span>, <span class="built_in">sizeof</span>(seraddr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置地址族为IPv4</span></span><br><span class="line">    seraddr.sin_family = AF_INET;</span><br><span class="line">    <span class="comment">// 服务器绑定到所有网络接口上</span></span><br><span class="line">    seraddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;0.0.0.0&quot;</span>);</span><br><span class="line">    <span class="comment">// 设置服务器端口号为9527</span></span><br><span class="line">    seraddr.sin_port = <span class="built_in">htons</span>(<span class="number">9527</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将套接字绑定到指定地址和端口</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(server, (<span class="keyword">struct</span> sockaddr*)&amp;seraddr, <span class="built_in">sizeof</span>(seraddr));</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 输出绑定失败信息并关闭套接字</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;bind failed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">close</span>(server);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始监听连接，最大连接数为3</span></span><br><span class="line">    <span class="comment">// 使用listen函数使服务器套接字server开始监听传入的连接请求，最大允许连接数为 3。</span></span><br><span class="line">    <span class="comment">// listen函数返回 0 表示成功，返回 -1 表示失败。</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(server, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 输出监听失败信息并关闭套接字</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;listen failed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">close</span>(server);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 清空缓冲区</span></span><br><span class="line">        <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">        <span class="comment">// 输出当前文件、行号和函数名</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">        <span class="comment">// 接受客户端连接</span></span><br><span class="line">        client = <span class="built_in">accept</span>(server, (<span class="keyword">struct</span> sockaddr*)&amp;clientaddr, &amp;cliaddrlen);</span><br><span class="line">        <span class="keyword">if</span> (client == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 输出接受客户端连接失败信息并关闭服务器</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;client failed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">close</span>(server);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输出当前文件、行号和函数名</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">        <span class="comment">// 从客户端读取消息</span></span><br><span class="line">        <span class="built_in">read</span>(client, buffer, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">        <span class="comment">// 将接收到的消息回显给客户端</span></span><br><span class="line">        <span class="type">ssize_t</span> len = <span class="built_in">write</span>(client, buffer, <span class="built_in">strlen</span>(buffer));</span><br><span class="line">        <span class="keyword">if</span> (len!= (<span class="type">ssize_t</span>)<span class="built_in">strlen</span>(buffer))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 输出写回显失败信息并关闭服务器</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;write failed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">close</span>(server);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输出当前文件、行号和函数名</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">        <span class="comment">// 关闭与客户端的连接</span></span><br><span class="line">        <span class="built_in">close</span>(client);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭服务器套接字</span></span><br><span class="line">    <span class="built_in">close</span>(server);</span><br><span class="line">    <span class="comment">// 输出当前文件、行号和函数名</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="lession63-函数"><a href="#lession63-函数" class="headerlink" title="lession63()函数"></a><code>lession63()</code>函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">lession63</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 子进程，作为客户端运行</span></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 运行客户端函数两次</span></span><br><span class="line">        <span class="built_in">run_client</span>();</span><br><span class="line">        <span class="built_in">run_client</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 父进程，作为服务器端运行</span></span><br><span class="line">        <span class="built_in">lession63_</span>();</span><br><span class="line">        <span class="type">int</span> status = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 等待子进程结束</span></span><br><span class="line">        <span class="built_in">wait</span>(&amp;status);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 输出fork失败信息</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;fork failed!&quot;</span> &lt;&lt; pid &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>TCP连接客户端的流程</strong></p><p>1️⃣创建套接字</p><p>2️⃣初始化服务器地址</p><p>3️⃣连接服务器。connect 成功返回0，失败返回-1</p><p>4️⃣通信   write read</p><p>5️⃣关闭套接字 （close关闭）</p><p><strong>TCP连接服务器的流程</strong></p><p>1️⃣创建套接字</p><p>2️⃣初始化服务器地址</p><p>3️⃣绑定套接字，<code>bind</code> 函数将服务器套接字 <code>server</code> 绑定到指定的地址和端口。</p><p>4️⃣监听连接，<code>listen</code>函数使得服务器套接字开始监听传入的连接请求</p><p>5️⃣<code>accept</code>接受并处理客户端连接，返回一个新的套接字描述符用于与客户端通信。   <code>read</code>、<code>write</code> 进行通信。</p><p>6️⃣关闭服务器套接字，<code>close(server)</code></p><h4 id="回声服务器"><a href="#回声服务器" class="headerlink" title="回声服务器"></a>回声服务器</h4><p><strong>回声服务器</strong>：将从客户端收到的数据原样返回给客户端，即“回声”。</p><p>客户端部分 分为 发送  和 接受两部分</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">run_client64</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个TCP套接字，使用IPV4地址族</span></span><br><span class="line"><span class="type">int</span> client = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 定义一个存储服务器地址信息的结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> servaddr;</span><br><span class="line"><span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="built_in">sizeof</span>(servaddr));</span><br><span class="line">    <span class="comment">// 设置地址族为IPV4</span></span><br><span class="line">servaddr.sin_family = AF_INET;</span><br><span class="line">    <span class="comment">// 将点分十进制的IP地址  转换为二进制形式并存储到结构体中</span></span><br><span class="line">servaddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"><span class="comment">// 将端口号从主机字节序转换为网络字节序</span></span><br><span class="line">    servaddr.sin_port = <span class="built_in">htons</span>(<span class="number">9527</span>);</span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">connect</span>(client, (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="built_in">sizeof</span>(servaddr));</span><br><span class="line"><span class="keyword">while</span> (ret == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line"><span class="comment">// 定义一个缓冲区用于存储用户输入的消息</span></span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">256</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="built_in">fputs</span>(<span class="string">&quot;Input message(Q to quit):&quot;</span>, stdout);</span><br><span class="line">        <span class="comment">// 从标准输入读取一行消息到缓冲区</span></span><br><span class="line"><span class="built_in">fgets</span>(buffer, <span class="built_in">sizeof</span>(buffer), stdin);</span><br><span class="line"><span class="keyword">if</span> ((<span class="built_in">strcmp</span>(buffer, <span class="string">&quot;q\n&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(buffer, <span class="string">&quot;Q\n&quot;</span>) == <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 获取用户输入消息的长度</span></span><br><span class="line"><span class="type">size_t</span> len = <span class="built_in">strlen</span>(buffer);</span><br><span class="line">        <span class="comment">// 获取用户输入消息的长度</span></span><br><span class="line"><span class="type">size_t</span> send_len = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">while</span> (send_len &lt; len)</span><br><span class="line">&#123;</span><br><span class="line">            <span class="comment">// 向服务器发送消息，从缓冲区的未发送部分开始发送</span></span><br><span class="line"><span class="type">ssize_t</span> ret = <span class="built_in">write</span>(client, buffer + send_len, len -send_len);</span><br><span class="line"><span class="comment">// 如果发送失败</span></span><br><span class="line">            <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fputs</span>(<span class="string">&quot;write failed!\n&quot;</span>, stdout);</span><br><span class="line"><span class="built_in">close</span>(client);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;client done!!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">// 更新已发送的字节数</span></span><br><span class="line">send_len += (<span class="type">size_t</span>)ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">        <span class="comment">// 已接收的字节数</span></span><br><span class="line"><span class="type">size_t</span> read_len = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 循环接收服务器的响应，直到接收的字节数达到发送的消息长度</span></span><br><span class="line"><span class="keyword">while</span> (read_len &lt; len)</span><br><span class="line">&#123;</span><br><span class="line">            <span class="comment">// 从服务器读取响应消息</span></span><br><span class="line"><span class="type">ssize_t</span> ret = <span class="built_in">read</span>(client, buffer + read_len, len - read_len);</span><br><span class="line"><span class="comment">// 读取失败</span></span><br><span class="line">            <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fputs</span>(<span class="string">&quot;read failed!\n&quot;</span>, stdout);</span><br><span class="line"><span class="built_in">close</span>(client);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;client done!!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">// 更新已经接收的字节数</span></span><br><span class="line">read_len += (<span class="type">size_t</span>)ret;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;from server &quot;</span> &lt;&lt; buffer;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 关闭套接字</span></span><br><span class="line"><span class="built_in">close</span>(client);</span><br><span class="line">    <span class="comment">// 输出客户端结束信息</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;client done!!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器端</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">server64</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 定义服务器和客户端的套接字描述符</span></span><br><span class="line"><span class="type">int</span> server, client;</span><br><span class="line">    <span class="comment">// 定义存储服务器和客户端地址信息的结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> seraddr, clientaddr;</span><br><span class="line">    <span class="comment">// 定义客户端地址结构体的长度</span></span><br><span class="line"><span class="type">socklen_t</span> cliaddrlen;</span><br><span class="line"><span class="comment">// 创建一个 TCP 套接字，使用 IPv4 地址族</span></span><br><span class="line">server = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (server &lt; <span class="number">0</span>) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;create socket failed！！\n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(&amp;seraddr, <span class="number">0</span>, <span class="built_in">sizeof</span>(seraddr));</span><br><span class="line">seraddr.sin_family = AF_INET;</span><br><span class="line">seraddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;0.0.0.0&quot;</span>);</span><br><span class="line">seraddr.sin_port = <span class="built_in">htons</span>(<span class="number">9527</span>);</span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">bind</span>(server, (<span class="keyword">struct</span> sockaddr*)&amp;seraddr, <span class="built_in">sizeof</span>(seraddr));</span><br><span class="line"><span class="comment">// 如果绑定失败</span></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// 输出错误信息</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;bind failed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 关闭套接字</span></span><br><span class="line"><span class="built_in">close</span>(server);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 开始监听客户端连接  在最大允许3个连接的请求排队</span></span><br><span class="line">ret = <span class="built_in">listen</span>(server, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;listen failed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">close</span>(server);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">// 处理2个客户端连接</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i ++ )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">         <span class="comment">// 接受客户端连接请求，返回一个新的套接字描述符</span></span><br><span class="line">client = <span class="built_in">accept</span>(server, (<span class="keyword">struct</span> sockaddr*)&amp;clientaddr, &amp;cliaddrlen);</span><br><span class="line"><span class="keyword">if</span> (client == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;client failed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">close</span>(server);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line"><span class="comment">// 已读取的字节数</span></span><br><span class="line">        <span class="type">ssize_t</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 循环读取客户端发送的消息</span></span><br><span class="line"><span class="keyword">while</span> (( len = <span class="built_in">read</span>(client, buffer, <span class="built_in">sizeof</span>(buffer)) ) &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">            <span class="comment">// 将接收到的消息原样返回给客户端</span></span><br><span class="line">len = <span class="built_in">write</span>(client, buffer, len);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (len != (<span class="type">ssize_t</span>)<span class="built_in">strlen</span>(buffer))</span><br><span class="line"><span class="comment">//if (len != write(client, buffer, len))</span></span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;write failed! len: &quot;</span> &lt;&lt;</span><br><span class="line">                    len &lt;&lt; <span class="string">&quot;buffer: &quot;</span> &lt;&lt; buffer &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">close</span>(server);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(buffer, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (len &lt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">            <span class="comment">// 输出错误信息</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;read failed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">// 关闭服务器套接字</span></span><br><span class="line"><span class="built_in">close</span>(server);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line"><span class="built_in">close</span>(client);  <span class="comment">// 可以注释</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(server);  <span class="comment">// 服务关闭的时候，客户端自动关闭</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主函数：启动服务器和客户端</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回声服务器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lession64</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个子进程</span></span><br><span class="line"><span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="comment">// 如果是子进程</span></span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">server64</span>();</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) <span class="comment">// 如果是父进程</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// 启动两次客户端程序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i ++)</span><br><span class="line"><span class="comment">//sleep(1);</span></span><br><span class="line"><span class="built_in">run_client64</span>();</span><br><span class="line">        <span class="comment">// 用于存储子进程的退出状态</span></span><br><span class="line"><span class="type">int</span> status = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 等待子进程结束</span></span><br><span class="line"><span class="built_in">wait</span>(&amp;status);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;fork failed!&quot;</span> &lt;&lt; pid &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>回声服务器存在的问题</strong></p><p>（上述代码已经更正了）代码有个错误的假设，每次调用read、write函数时都会以<font color="FF0000">字符串为单位执行实际的I&#x2F;O操作。</font>每次调用write函数都会传递一个字符串，这种假设也算合理。但是，多次调用write函数传递的字符串有可能一次性传递到服务器端。此时客户端有可能从服务器端收到多个字符串，这不是我们希望看到的结果。</p><p>需要考虑下面的情况：<font color="FF0000">字符串太长，需要分2个数据包发送！</font></p><h4 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h4><p><strong>客户端设置服务器地址</strong></p><p>客户端设置服务器地址是为了明确要连接的目标服务器位置。它通过<code>struct sockaddr_in</code>结构体来存储服务器的网络地址信息，包括 <code>IP</code> 地址和端口号。</p><p><strong>服务器端设置服务器地址</strong></p><p>服务器端设置自己的地址主要是为了将服务器套接字绑定到一个特定的网络接口和端口上，以便接收来自客户端的连接请求。</p><p><strong><code>connect()</code>函数  和  <code>bind()</code>函数   的区别</strong></p><ul><li><p><code>connect</code>函数主要用于客户端套接字与服务器端套接字建立连接。它尝试将客户端的网络端点（由 IP 地址和端口号标识）与服务器的网络端点进行关联，从而建立起一条通信链路，使得客户端和服务器可以互相发送和接收数据。</p><p>返回0：客户端与服务器之间的连接已经建立，可以开始进行数据读写操作了。</p><p>返回-1：执行 失败的时候会返回-1，errno变量来指示具体错误原因。</p></li><li><p><code>bind</code>函数主要用于服务器端将套接字绑定到一个特定的本地网络端点（包括 IP 地址和端口号）。它的作用是让服务器在特定的网络地址和端口上监听客户端的连接请求，使得客户端能够准确地找到服务器并与之建立连接。</p></li></ul><p><strong><code>write</code>函数</strong></p><ul><li><code>fd</code>：文件描述符，它可以代表一个打开的文件、套接字等。在网络编程中，通常是通过 <code>socket</code> 函数创建并连接好的套接字描述符。</li><li><code>buf</code>：指向要写入数据的缓冲区的指针。</li><li><code>count</code>：要写入的字节数。</li></ul><p>返回值大于0：当 <code>write</code> 函数成功写入部分或全部数据时，它会返回实际写入的字节数。这个返回值可能小于、等于 <code>count</code> 参数指定的字节数。</p><ul><li><strong>等于 <code>count</code></strong>：表示成功写入了请求的所有字节。例如，你希望写入 10 个字节的数据，<code>write</code> 函数返回 10，说明这 10 个字节都成功写入到了文件描述符所关联的目标中。</li><li><strong>小于 <code>count</code></strong>：可能是因为某些原因（如磁盘空间不足、网络缓冲区已满等），无法一次性写入所有请求的字节。在这种情况下，你可能需要再次调用 <code>write</code> 函数，从上次写入结束的位置继续写入剩余的数据。</li></ul><p>返回值等于0：通常出现了一些异常情况</p><p>返回值为-1 ：<code>write</code>函数执行失败时，它会返回-1，并且会设置<code>errno</code>变量来指示具体的错误原因。</p><p><strong>这俩部分设置是否一样？</strong></p><ul><li><strong>客户端角度</strong><ul><li>客户端设置的服务器 IP 地址必须是服务器实际绑定并监听的 IP 地址之一。如果服务器绑定了特定的 IP 地址（例如<code>192.168.1.100</code>），客户端就需要使用这个 IP 地址来连接服务器。不过，如果服务器绑定的是<code>0.0.0.0</code>（表示监听所有本地网络接口），客户端可以使用服务器所在主机的任何一个有效本地 IP 地址来连接。</li></ul></li><li><strong>服务器角度</strong><ul><li>服务器绑定的 IP 地址决定了它在哪些网络接口上监听客户端连接。如果服务器有多个网络接口（例如有多个网卡，每个网卡有不同的 IP 地址），绑定<code>0.0.0.0</code>意味着在所有接口上监听；而绑定特定的 IP 地址则只在该接口监听。</li></ul></li></ul><p><strong>主机字节序和网络字节序</strong></p><p>大端字节序也成为网络字节序，数据的高位字节存于低地址，低位字节存于高地址。</p><p>小端字节序：数据低位字节存于低地址，高位字节存于高地址。</p><h3 id="简单的-UDP-客户端-服务器模型"><a href="#简单的-UDP-客户端-服务器模型" class="headerlink" title="简单的 UDP 客户端 - 服务器模型"></a>简单的 <code>UDP</code> 客户端 - 服务器模型</h3><h4 id="server-函数"><a href="#server-函数" class="headerlink" title="server()函数"></a><code>server</code>()函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">server</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> ser_sock = <span class="number">-1</span>;</span><br><span class="line"><span class="type">char</span> message[<span class="number">512</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> servaddr, clientaddr;</span><br><span class="line"><span class="type">socklen_t</span> clientlen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查命令行参数</span></span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;usage:%s  &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">handle_error</span>(<span class="string">&quot;argement is error!:&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建UDP套接字</span></span><br><span class="line">ser_sock = <span class="built_in">socket</span>(PF_INET, SOCK_DGRAM, <span class="number">0</span>); <span class="comment">// UDP</span></span><br><span class="line"><span class="keyword">if</span> (ser_sock == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">handle_error</span>(<span class="string">&quot;create socket failed:&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="built_in">sizeof</span>(servaddr));</span><br><span class="line">    <span class="comment">// 初始化服务器地址</span></span><br><span class="line">servaddr.sin_family = AF_INET;</span><br><span class="line">servaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY); <span class="comment">// 0.0.0.0  全网段监听</span></span><br><span class="line">    <span class="comment">// 设置servaddr的端口号为从命令行参数argv[1]中获取的端口号</span></span><br><span class="line">    <span class="comment">// 通过htons函数将其转换为网络字节序。</span></span><br><span class="line">servaddr.sin_port = <span class="built_in">htons</span>((<span class="type">short</span>)<span class="built_in">atoi</span>(argv[<span class="number">1</span>]));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 绑定套接字到地址</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">bind</span>(ser_sock, (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="built_in">sizeof</span>(servaddr)) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">handle_error</span>(<span class="string">&quot;bind failed:&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 消息处理循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">clientlen = <span class="built_in">sizeof</span>(clientaddr);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用recvfrom函数从客户端接收数据</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        ser_sock：服务器套接字描述符。</span></span><br><span class="line"><span class="comment">        0：表示默认的标志位。</span></span><br><span class="line"><span class="comment">        (struct sockaddr*)&amp;clientaddr：用于存储客户端地址的结构体指针。</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        recvfrom 函数返回接收到的数据长度。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"><span class="type">ssize_t</span> len = <span class="built_in">recvfrom</span>(ser_sock, message, <span class="built_in">sizeof</span>(message), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用sendto函数将接收到的数据回显给客户端</span></span><br><span class="line"><span class="built_in">sendto</span>(ser_sock, message, len, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;clientaddr, clientlen);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 关闭套接字</span></span><br><span class="line"><span class="built_in">close</span>(ser_sock);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="client-函数"><a href="#client-函数" class="headerlink" title="client()函数"></a><code>client()</code>函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">client</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 变量声明</span></span><br><span class="line"><span class="type">int</span> client_sock;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr;</span><br><span class="line"><span class="type">socklen_t</span> serv_len = <span class="built_in">sizeof</span>(serv_addr);</span><br><span class="line"><span class="type">char</span> message[<span class="number">512</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;usage:%s is port\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">handle_error</span>(<span class="string">&quot;argement error:&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 创建 UDP 套接字</span></span><br><span class="line">    <span class="comment">// UDP 套接字是无连接的，通过SOCK_DGRAM参数来指定创建 UDP 类型的套接字。</span></span><br><span class="line">client_sock = <span class="built_in">socket</span>(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (client_sock == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">handle_error</span>(<span class="string">&quot;socket create failed！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    <span class="comment">// 初始化服务器地址</span></span><br><span class="line">serv_addr.sin_family = AF_INET;</span><br><span class="line">serv_addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(argv[<span class="number">1</span>]);</span><br><span class="line">serv_addr.sin_port = <span class="built_in">htons</span>((<span class="type">short</span>)<span class="built_in">atoi</span>(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息处理循环</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Input message(q to quit):&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, message);</span><br><span class="line"><span class="keyword">if</span> ((<span class="built_in">strcmp</span>(message, <span class="string">&quot;q&quot;</span>) == <span class="number">0</span>) || (<span class="built_in">strcmp</span>(message, <span class="string">&quot;Q&quot;</span>) == <span class="number">0</span>)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 分配了地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line"><span class="type">ssize_t</span> len = <span class="built_in">sendto</span>(client_sock, message, <span class="built_in">strlen</span>(message), <span class="number">0</span>, (sockaddr*)&amp;serv_addr, serv_len);</span><br><span class="line"><span class="built_in">memset</span>(message, <span class="number">0</span>, len);</span><br><span class="line"><span class="built_in">recvfrom</span>(client_sock, message, <span class="built_in">sizeof</span>(message), <span class="number">0</span>, (sockaddr*)&amp;serv_addr, &amp;serv_len);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;recv:%s\n&quot;</span>, message);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 关闭套接字并返回</span></span><br><span class="line"><span class="built_in">close</span>(client_sock);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p><strong><code>UDP</code>客户端的流程</strong></p><p>1️⃣ 创建套接字</p><p>2️⃣ 设置服务器地址端口</p><p>3️⃣ 使用<code>sendto</code>函数发送数据、<code>recvfrom</code>函数来接收数据。</p><p>4️⃣ 关闭套接字</p><p><strong><code>UDP</code>服务器端的流程</strong></p><p>1️⃣ 创建套接字</p><p>2️⃣ 绑定地址和端口</p><p>3️⃣ 接受、处理数据</p><p>4️⃣ 关闭套接字</p><h4 id="问题汇总-1"><a href="#问题汇总-1" class="headerlink" title="问题汇总"></a>问题汇总</h4><p><code>UDP</code>服务器端&#x2F;客户端的实现方法。但如果仔细观察<code>UDP</code>客户端会发现，它缺少把<code>IP</code>和端口分配给套接字的过程。</p><p><code>TCP</code>客户端调用connect函数自动完成此过程，<code>UDP</code>调用<code>sendto</code>函数时自动分配<code>IP</code>和端口号</p><p><strong>套接字类型只能在创建时决定，以后不能再更改。</strong></p><p><strong><code>SO_SNDBUF &amp;SO_RCVBUF</code></strong></p><p><code>SO_RCVBUF</code>是输入缓冲大小相关可选项，<code>SO_SNDBUF</code>是输出缓冲大小相关可选项。用这2 个可选项既可以读取当前I&#x2F;O缓冲大小，也可以进行更改。通过下列示例读取创建套接字时默认的I&#x2F;O缓冲大小。</p><p><strong>如何使用<code>socket</code>、<code>getsockopt</code>和<code>setsockopt</code>函数来获取和设置套接字的属性</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">lession76</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 声明了两个整数变量，分别用于存储 TCP 套接字描述符和 UDP 套接字描述符。</span></span><br><span class="line"><span class="type">int</span> tcp_sock, udp_sock;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 声明并初始化一个整数变量optval，用于存储套接字选项的值。</span></span><br><span class="line"><span class="type">int</span> optval = <span class="number">0</span>;</span><br><span class="line"><span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(optval);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分别创建TCP/UDP 套接字</span></span><br><span class="line">tcp_sock = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">udp_sock = <span class="built_in">socket</span>(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;SOCK_STREAM:%d\n&quot;</span>, SOCK_STREAM);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;SOCK_DGRAM:%d\n&quot;</span>, SOCK_DGRAM);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取套接字类型</span></span><br><span class="line">    <span class="comment">// 使用getsockopt函数获取 TCP 套接字的类型。</span></span><br><span class="line">    <span class="comment">// SOL_SOCKET表示通用套接字选项级别，SO_TYPE表示要获取的选项是套接字类型。</span></span><br><span class="line">    <span class="comment">// 获取到的值存储在optval中。</span></span><br><span class="line"><span class="built_in">getsockopt</span>(tcp_sock, SOL_SOCKET, SO_TYPE, (<span class="type">void</span>*)&amp;optval, &amp;len);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;tcp_sock type is :%d\n&quot;</span>, optval);</span><br><span class="line">optval = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">getsockopt</span>(udp_sock, SOL_SOCKET, SO_TYPE, (<span class="type">void</span>*)&amp;optval, &amp;len);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;udp_sock type is :%d\n&quot;</span>, optval);</span><br><span class="line">optval = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 获取和设置 TCP 套接字发送缓冲区大小</span></span><br><span class="line"><span class="built_in">getsockopt</span>(tcp_sock, SOL_SOCKET, SO_SNDBUF, (<span class="type">void</span>*)&amp;optval, &amp;len);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;tcp_sock send buffer size is :%d\n&quot;</span>, optval);</span><br><span class="line">optval = <span class="number">1024</span> * <span class="number">16</span>;</span><br><span class="line"><span class="built_in">setsockopt</span>(tcp_sock, SOL_SOCKET, SO_SNDBUF, (<span class="type">void</span>*)&amp;optval, len);</span><br><span class="line"><span class="built_in">getsockopt</span>(tcp_sock, SOL_SOCKET, SO_SNDBUF, (<span class="type">void</span>*)&amp;optval, &amp;len);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*tcp_sock send buffer size is :%d\n&quot;</span>, optval);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭套接字</span></span><br><span class="line"><span class="built_in">close</span>(tcp_sock);</span><br><span class="line"><span class="built_in">close</span>(udp_sock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>套接字的多种可选项</strong></p><p>在客户端控制台输入Q消息，或通过CTRL+C终止程序。</p><p>​在客户端输入Q消息调用close函数，向服务器端发送FIN消息并经过四次挥手的过程。</p><p><font color="#FF0000">服务器端和客户端已建立连接的状态下，</font>向服务器端控制台输入CTRL+C，即强制关闭服务器端。</p><p>​如果是CTRL+C，服务器端重新运行的时候将产生问题。如果用同一端口号重新运行服务器端，将输出“bind error” 消息，并且无法再次运行。这种情况下，大约三分钟后即可重新运行服务器端。</p><p><img src="https://bu.dusays.com/2025/03/05/67c7e28519e2f.png"></p><p>上述两种方法唯一的区别就是谁先传输FIN消息。</p><p><img src="https://bu.dusays.com/2025/03/05/67c7e2b6a33fb.png"></p><p>​假设上图中主机A是服务器端，因为是主机A向B发送FIN消息，故可以想象成服务器端1在控制台输入CTRL+C。但问题是，套接字经过四次挥手过程后并非立即消除，而是要经过一段时间的Time-wait状态。当然，只有先断开连接的（先发送FIN消息的）主机才经过Time-wait状态。因此，若服务器端先断开连接，则无法立即重新运行。套接字处在Time-wait过程时，相应端口是正在使用的状态。因此，就像之前验证过的，bind函数调用过程中当然会发生错误。</p><p>​不论是服务器端还是客户端都会有Time-wait过程。先断开连接的套接字必然会经过Time-wait过程。但是无需考虑客户端Time-wait状态。因为客户端套接字的端口号是任意指定的。</p><p><strong><font color="#FF0000">为什么会有Time-wait状态？</font></strong></p><p>​如上图中假设主机A向主机B传输ACK消息（SEQ5001、ACK7502）后立即消除套接字。但最后这条ACK消息在传递途中丢失，未能传给主机B。这时会发生什么?主机B会认为之前自己发送的FIN消息（SEQ 7501、ACK 5001）未能抵达主机A，继而试图重传。但此时主机A已是完全终止的状态，因此主机B永远无法收到从主机A最后传来的ACK消息。相反，<strong>若主机A的套接字处在Time-wait状态</strong>，则会向主机B重传最后的ACK消息，主机B也可以正常终止。基于这些考虑，先传输FIN消息的主机应经过Time-wait过程。</p><p><strong>地址再分配</strong></p><p><img src="https://bu.dusays.com/2025/03/05/67c7e5e01f1b4.png"></p><p>​如上图所示，在主机A的四次握手过程中，如果最后的数据丢失，则主机B会认为主机A未能收到自己发送的FIN消息，因此重传。这时，收到FIN消息的主机A将重启Time-wait计时器。因此，如果网络状况不理想，Time-wait状态将持续。</p><p>​解决方案就是在套接字的可选项中更改SO_REUSEADDR的状态。适当调整该参数，可将Time-wait状态下的套接字端口号重新分配给新的套接字。SO_REUSEADDR的默认值为0（假），这就意味着无法分配Time-wait状态下的套接字端口号。因此需要将这个值改成1（真）。</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统编程01-基础知识</title>
      <link href="/2025/01/09/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2025/01/09/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h3 id="一、套接字编程"><a href="#一、套接字编程" class="headerlink" title="一、套接字编程"></a>一、套接字编程</h3><p><strong>TCP服务端</strong></p><p>1️⃣ 创建套接字socket()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sockfd = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// PF_INET 指定协议族为 IPv4</span></span><br><span class="line"><span class="comment">// SOCK_STREAM：指定套接字类型为流套接字</span></span><br><span class="line"><span class="comment">// 0：指定协议类型，这里使用默认协议</span></span><br><span class="line"><span class="comment">// 如果socket函数成功创建套接字，会返回一个非负整数作为套接字描述符；如果失败，返回-1。</span></span><br></pre></td></tr></table></figure><p>2️⃣ 存储地址信息</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个struct sockaddr_in类型的变量addr，用于存储地址信息。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定地址族为 IPv4，AF代表 “Address Family”，AF_INET和前面的PF_INET相对应。</span></span><br><span class="line">addr.sin_family = AF_INET; </span><br><span class="line"></span><br><span class="line"><span class="comment">// INADDR_ANY，表示该套接字将绑定到服务器上的所有网络接口。</span></span><br><span class="line">addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line"><span class="comment">// htons函数将主机字节序的端口号 9527 转换为网络字节序，并存储在sin_port字段中。</span></span><br><span class="line">addr.sin_port = <span class="built_in">htons</span>(<span class="number">9527</span>);</span><br></pre></td></tr></table></figure><p>②分配套接字地址bind()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用bind函数将创建的套接字sock绑定到指定的地址和端口。</span></span><br><span class="line"><span class="built_in">bind</span>(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="built_in">sizeof</span>(addr));</span><br><span class="line"><span class="comment">// 如果bind函数失败，返回-1。</span></span><br></pre></td></tr></table></figure><p>③等待连接请求状态listen()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">listen</span>(sockfd, <span class="number">5</span>);  <span class="comment">// 5 是请求队列的最大长度</span></span><br></pre></td></tr></table></figure><p>④允许连接accept()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> client_sock = <span class="built_in">accept</span>(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;client_addr, &amp;client_len);</span><br></pre></td></tr></table></figure><p>⑤数据交换read()&#x2F;write()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line"><span class="built_in">read</span>(client_sock, buffer, <span class="built_in">sizeof</span>(buffer));  <span class="comment">// 接收客户端的数据</span></span><br><span class="line"><span class="built_in">write</span>(client_sock, <span class="string">&quot;Hello, Client!&quot;</span>, <span class="number">15</span>);   <span class="comment">// 发送数据到客户端</span></span><br></pre></td></tr></table></figure><p>⑥断开连接close()    关闭服务器套接字</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span>(client_sock);</span><br><span class="line"><span class="built_in">close</span>(sockfd);</span><br></pre></td></tr></table></figure><p><strong>客户端套接字编程流程</strong></p><p>①创建套接字socket()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sockfd = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>②设置服务器地址</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server_addr;</span><br><span class="line">server_addr.sin_family = AF_INET;</span><br><span class="line">server_addr.sin_port = <span class="built_in">htons</span>(<span class="number">9527</span>);  <span class="comment">// 服务器端的端口号</span></span><br><span class="line">server_addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;192.168.0.1&quot;</span>);  <span class="comment">// 服务器的 IP 地址</span></span><br></pre></td></tr></table></figure><p>③连接服务器（connect）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="built_in">sizeof</span>(server_addr));</span><br></pre></td></tr></table></figure><p>④数据交换read()&#x2F;write()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">write</span>(sockfd, <span class="string">&quot;Hello, Server!&quot;</span>, <span class="number">15</span>);  <span class="comment">// 向服务器发送数据</span></span><br><span class="line"><span class="built_in">read</span>(sockfd, buffer, <span class="built_in">sizeof</span>(buffer));  <span class="comment">// 从服务器读取数据</span></span><br></pre></td></tr></table></figure><p>⑤断开连接close()    关闭服务器套接字</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span>(sockfd);</span><br></pre></td></tr></table></figure><p><strong>客户端套接字地址信息在哪里</strong>？</p><p>网络数据交换必须分配IP和端口。  调用connect函数时，在操作系统内核 IP使用计算机的IP，端口随机</p><p>即 客户端IP地址和端口在调用connect函数时自动分配，无需调用标记的bind函数进行分配。</p><p>客户端在listen之后  close之前connect才有效</p><p><strong>迭代服务器</strong></p><p>普通服务器TCP的缺点：启动一次服务程序，只能给一个客户端服务。迭代服务器比较原始，它的原型可以描述成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    new_fd = 服务器 accept客户端的连接(new_fd = <span class="built_in">accept</span>(listenfd,xx,xx));</span><br><span class="line">    <span class="comment">//逻辑处理</span></span><br><span class="line">    <span class="comment">// 在这个new_fd上给客户端发送消息</span></span><br><span class="line">    <span class="comment">// 关闭new_fd</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>基本工作流程</strong></p><ol><li><strong>等待连接</strong> ：服务器会一直监听一个端口，等待客户端的连接。</li><li><strong>接受连接</strong> ：当客户端连接时，服务器会接受连接并建立一个新的套接字与客户端通信。</li><li><strong>处理请求</strong> ：服务器会处理客户端的请求，执行一些操作，或者提供一些服务。</li><li><strong>关闭连接</strong> ：处理完一个客户端的请求后，服务器关闭与该客户端的连接。</li><li><strong>继续等待</strong> ：服务器回到监听状态，等待下一个客户端的连接请求。</li></ol><p><strong>write函数和read函数</strong></p><p>①write函数   <code>ssize_t write(int fd, const void *buf, size_t count);</code></p><p><code>write</code>函数用于向文件描述符<code>fd</code>所指向的文件、套接字或其他I&#x2F;O设备中写入数据。</p><h3 id="TCP底层原理"><a href="#TCP底层原理" class="headerlink" title="TCP底层原理"></a>TCP底层原理</h3><p><code>write</code>函数调用后并非立即传输数据，read函数调用后也并非马上接收数据。<code>write</code>函数调用瞬间，数据将移至输出缓冲；<code>read</code>函数调用瞬间，从输入缓冲读取数据。</p><p>A：I&#x2F;O缓冲在每个套接字中单独存在。</p><p>B：I&#x2F;O缓冲在创建套接字时自动生成。</p><p>C：即使关闭套接字也会<strong>继续传递输出缓冲中遗留的数据</strong>。</p><p>D：关闭套接字将丢失输入缓冲中的数据。</p><p>“客户端输入缓冲50字节，而服务器端传输了100字节。”</p><p>填满输入缓冲前迅速调用read函数读取数据，就能腾出一部分空间，问题就解决了。</p><p>其实不会发生这类问题，因为TCP会控制数据流。TCP有滑动窗口协议。</p><p><strong>数据收发也是如此，因此TCP中不会因为缓冲溢出而丢失数据。</strong></p><p><strong>但是会因为缓冲而影响传输效率。</strong></p><h4 id="TCP内部原理"><a href="#TCP内部原理" class="headerlink" title="TCP内部原理"></a>TCP内部原理</h4><p><strong>TCP通信的三大步骤</strong></p><ol><li>三次握手建立连接；</li><li>开始通信，进行数据交换；</li><li>四次挥手断开连接；</li></ol><p>利用TCP三次握手进行攻击。</p><p>断开连接有可能卡在中间两次发数据包的地方。</p><h3 id="UDP编程"><a href="#UDP编程" class="headerlink" title="UDP编程"></a>UDP编程</h3><h4 id="UDP基本原理"><a href="#UDP基本原理" class="headerlink" title="UDP基本原理"></a>UDP基本原理</h4><p>4层TCP&#x2F;IP模型中，第二层传输层分为TCP和UDP。</p><p>只考虑可靠性，TCP比UDP更好。但UDP在结构上比TCP更简洁。UDP不会发送类似ACK的应答消息，也不会想SEQ那样给数据包分配序号。因此UDP的性能有时比TCP高出很多。</p><p>为了提供可靠的数据传输服务，TCP在不可靠的IP层进行流控制，而UDP就缺少这种流控制机制。</p><p>TCP的速度无法超过UDP，但在收发某些类型的数据时有可能接近UDP。例如，每次交换的数据量越大，TCP的传输速率越接近UDP的传输速率。</p><p><strong>TCP比UDP慢的原因</strong></p><p>① 收发数据前后进行的连接设置及清除过程。</p><p>② 收发数据过程中为保证可靠性而添加的流控制。</p><p><strong>UDP 服务端</strong></p><p>UDP   服务器&#x2F;客户端不像TCP那样在连接状态下交换数据，因此与TCP不同，无需经过连接过程。也就是说，不必调用TCP连接过程中调用的listen函数和accept函数。UDP中只有<strong>创建套接字的过程和数据交换的过程</strong>。</p><p>UDP的服务端和客户端都只需要一个套接字，而TCP中，套接字之间是一一对应的关系。若要向10个客户端提供服务，则除了守门的服务器套接字外，还需要10个服务器端套接字。</p><p>UDP套接字绑定本地的IP地址和端口号，这个套接字就可以接受来自任何主机发送到该端口的数据报。</p><p>创建好TCP套接字后，传输数据时无需再添加地址信息。但是UDP套接字不会保持连接状态（UDP套接字只有简单的邮筒功能），因此每次传输数据都要添加目标地址信息。这相当于寄信前在信件中填写地址。填写地址并传输数据时调用的UDP相关函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="type">int</span> sock,<span class="type">void</span>*buff,<span class="type">size_t</span> nbytes,<span class="type">int</span> flags,<span class="keyword">struct</span> sockaddr *to, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sock     用于传输数据的UDP套接字文件描述符。</span></span><br><span class="line"><span class="comment">buff     保存待传输数据的缓冲地址值。</span></span><br><span class="line"><span class="comment">nbytes   待传输的数据长度，以字节为单位。</span></span><br><span class="line"><span class="comment">flags    可选项参数，若没有则传递0。</span></span><br><span class="line"><span class="comment">to       存有目标地址信息的sockaddr结构体变量的地址值</span></span><br><span class="line"><span class="comment">addrlen  传递给参数to的地址值结构体变量长度。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">上述函数与之前的TCP输出函数最大的区别在于，此函数需要向它传递目标地址信息。接下来介绍接收UDP数据的函数。UDP数据的发送端并不固定，因此该函数定义为可接收发送端信息的形式，也就是将同时返回UDP数据包中的发送端信息。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="type">int</span> sock,  <span class="type">void</span> *buff,<span class="type">size_t</span> nbytes,  <span class="type">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="keyword">struct</span> sockaddr*from,   <span class="type">socklen_t</span>*addrlen)</span></span>;</span><br><span class="line"><span class="comment">// →成功时返回接收的字节数，失败时返回-1。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sock用于接收数据的UDP套接字文件描述符。</span></span><br><span class="line"><span class="comment">buff保存接收数据的缓存地址值</span></span><br><span class="line"><span class="comment">nbytes 可接收的最大字节数，故无法超过参数buf所指的缓冲大小。</span></span><br><span class="line"><span class="comment">flags可选项参数，若没有则传入0。</span></span><br><span class="line"><span class="comment">from存有发送端地址信息的sockaddr结构体变量的地址值。</span></span><br><span class="line"><span class="comment">addrlen 保存参数from的结构体变量长度的变量地址值。</span></span><br><span class="line"><span class="comment">编写UDP程序时最核心的部分就在于上述两个函数，这也说明二者在UDP数据传输中的地位。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>UDP相关的函数</p><p>DDos攻击大多利用UDP</p><p><strong>发生地址分配错误</strong>（重点）</p><p>客户端是connect，所以不会出现bind  failed，因为有几万个端口可以用，所以connect失败很难</p><p><strong>I&#x2F;O缓冲区大小</strong></p><p><strong>TCP_NODELAY</strong></p><p>监控键盘的输入</p><h3 id="Linux系统编程：进程"><a href="#Linux系统编程：进程" class="headerlink" title="Linux系统编程：进程"></a>Linux系统编程：进程</h3><h4 id="并发服务器的实现方法"><a href="#并发服务器的实现方法" class="headerlink" title="并发服务器的实现方法"></a>并发服务器的实现方法</h4><p>使其同时相所有发起请求的客户端提供服务，以提高平均满意度。</p><p>而且，<strong>网络程序中数据通信时间比CPU运算时间占比更大，因此，向多个客户端提供服务是一种有效利用CPU的方式。</strong></p><ol><li>多进程服务器：通过创建多个进程提供服务。</li><li>多路复用服务器：通过捆绑并统一管理I&#x2F;O对象提供服务。</li><li>多线程服务器：通过生成与客户端等量的线程提供服务。</li></ol><p><strong>进程</strong>：占用内存空间正在运行的程序 就是进程</p><p>从操作系统的角度来看，<strong>进程是程序流的基本单位</strong>，若创建多个进程，则操作系统将同时运行。有时候一个程序运行过程中也会产生多个进程。</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cpp13常见问题</title>
      <link href="/2024/12/11/cpp13%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <url>/2024/12/11/cpp13%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h4 id="一、指针和引用的区别"><a href="#一、指针和引用的区别" class="headerlink" title="一、指针和引用的区别"></a><strong>一、指针和引用的区别</strong></h4><p><strong>①   定义和概念</strong></p><p>指针：指针是一个变量，其值为另一个变量的地址。指针本质上是存储内存地址的变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* p = &amp;a;  <span class="comment">// p 是指针，存储a的地址</span></span><br></pre></td></tr></table></figure><p>引用：引用是一个别名，它为已有的变量创建一个新的名字。引用初始化必须与某个变量绑定，并且一旦绑定之后不能再绑定到其他变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a  = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; ref = a;  <span class="comment">// ref是 a的引用，相当于a的别名。</span></span><br></pre></td></tr></table></figure><p><strong>②   语法差异</strong> </p><p>指针语法：声明指针时候使用<code>*</code>符号、获取指针指向的变量的值需要使用解引用操作符<code>*</code>、需要显式地进行地址赋值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* p = &amp;a;  <span class="comment">// &amp;a 表示获取a的地址</span></span><br><span class="line"><span class="type">int</span> value = *p; <span class="comment">// *p表示解引用，得到a的值</span></span><br></pre></td></tr></table></figure><p>引用的语法：声明引用使用<code>&amp;</code>符号、引用像普通变量一样使用，不需要使用解引用操作符、引用必须在声明时进行初始化，并且无法更改引用的对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; ref = a;   <span class="comment">// ref 是 a 的引用</span></span><br><span class="line">ref = <span class="number">20</span>;<span class="comment">// 改变a的值为20</span></span><br></pre></td></tr></table></figure><p><strong>③  是否允许为空值</strong></p><p>指针可以为<code>nullptr</code>，这意味着指针不指向任何有效的内存地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p>引用必须始终绑定到一个有效的变量。引用不能是空的，因此在创建引用时必须确保它绑定到一个有效的变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; ref = a;  <span class="comment">// ref必须引用一个已初始化的变量</span></span><br></pre></td></tr></table></figure><p><strong>④  是否可以重新绑定</strong></p><p>​指针可以在程序执行过程中重新指向不同的变量。指针是动态可变的。</p><p>​引用一旦绑定了某个变量，就不能再改变引用的对象，引用的绑定是固定的。</p><p><strong>⑤  内存分配</strong></p><p>指针是一个独立的变量，它需要占用内存存储地址。因此，指针本身需要内存空间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* p = &amp;a;  <span class="comment">// p是指针，需要为p分配内存空间</span></span><br></pre></td></tr></table></figure><p>引用本身不占用额外的内存空间，它只是一个已经存在的变量的别名。引用的实现通常是通过指针来实现的，但从语法上它没有指针的表现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; ref = a;  <span class="comment">// ref只是a的别名，不需要额外的内存</span></span><br></pre></td></tr></table></figure><p><strong>⑥  使用场景</strong></p><p>指针使用于需要动态管理内存、在函数间传递大量数据时，特别是在对象动态分配、链表、树等数据结构的实现</p><p>指针可以进行指针运算，例如加减操作，访问数组元素等。</p><p>引用 通常用于函数参数传递（尤其是传递大对象或者需要修改参数的情况下），引用使得函数调用更加简介并且避免了拷贝 的开销。</p><p>引用常用于返回对象的引用，或者作为输出参数的替代。</p><p><strong>⑦  安全性</strong></p><p>指针的安全性较差，容易发生空指针引用、悬挂指针等问题。例如，如果指针在使用后没有及时初始化为<code>nullptr</code>，可能会访问非法内存。</p><p>引用的安全性较高，因为引用始终必须绑定到一个有效对象，且不能为<code>nullptr</code> ， 这减少了访问无效内存的风险。</p><p><strong>⑧  是否可以被常量修饰</strong></p><p>指针可以被<code>const</code>修饰，指针本身、指针指向的内容都可以是常量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//const 变量类型*  只能指向一个常量</span></span><br><span class="line"><span class="comment">// 特点，指针的指向可以修改，但是指针指向的值不可以修改</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a&#123; <span class="number">100</span> &#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b&#123; <span class="number">200</span> &#125;;</span><br><span class="line"><span class="type">int</span> c&#123; <span class="number">300</span> &#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* p&#123; &amp;a &#125;;</span><br><span class="line"><span class="comment">// *p = 500;  不可以修改值</span></span><br><span class="line">std::cout &lt;&lt; *p &lt;&lt; std::endl;</span><br><span class="line">p = &amp;b;  <span class="comment">// 可以修改指向</span></span><br><span class="line">p = &amp;c;  <span class="comment">// 常量指针也可以指向非常量变量</span></span><br><span class="line"><span class="comment">// *p = 2000;  常量指针就是不让改</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//特点：指针的指向不可以改，指针指向的值可以改（内存中的数据可以更改）</span></span><br><span class="line"><span class="type">int</span> a&#123; <span class="number">100</span> &#125;;</span><br><span class="line"><span class="type">int</span> b&#123; <span class="number">200</span> &#125;;</span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> p&#123; &amp;a &#125;;</span><br><span class="line"><span class="comment">//p = &amp;b;   不能修改指向</span></span><br><span class="line">*p = <span class="number">999</span>;  <span class="comment">//可以修改指针指向的内存空间</span></span><br><span class="line">std::cout &lt;&lt; a &lt;&lt; std::endl; <span class="comment">//  这时候a输出 999；</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//const 变量类型* const</span></span><br><span class="line"><span class="comment">//特点：指针的指向和指针指向的值都不可以修改 </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a&#123; <span class="number">100</span> &#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b&#123; <span class="number">200</span> &#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> p&#123; &amp;a &#125;;</span><br><span class="line"><span class="comment">//p = &amp;b;  不能修改指向</span></span><br><span class="line"><span class="comment">//*p = 999;  不能修改内存空间里面的值</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a&#123; <span class="number">100</span> &#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b&#123; <span class="number">200</span> &#125;;</span><br><span class="line"><span class="comment">//int* pa&#123; &amp;a &#125;;   常量</span></span><br><span class="line"><span class="type">int</span>* pa&#123; (<span class="type">int</span>*)&amp;a &#125;;   <span class="comment">//通过转换是可以的</span></span><br><span class="line">*p = <span class="number">9500</span>;<span class="comment">//这种操作是允许的，但是a的值不变</span></span><br><span class="line">std::cout &lt;&lt; *pa &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>引用可以是常量引用，表示不能修改引用的对象，但引用本身无法修改为指向其他对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; ref = a;  <span class="comment">// ref是常量引用，不能修改a的值</span></span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><p>指针</p><p>​用于动态内存分配、数组、链表等数据结构。</p><p>​在函数之间传递多个值，或者需要修改函数外部的对象时使用。</p><p>​可以指向<code>nullptr</code>，适用于需要进行空指针检查的场景。</p><p>​可以进行指针运算。</p><p>引用</p><p>​用于函数参数传递，避免不必要的复制，尤其是在处理大型对象时。</p><p>​用于返回对象的引用，以便函数外部能修改对象。</p><p>​比指针更加简洁、直观。</p><p>​不支持空引用，确保引用有效。</p>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cpp12跨语言编程</title>
      <link href="/2024/12/11/cpp12%E8%B7%A8%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/"/>
      <url>/2024/12/11/cpp12%E8%B7%A8%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="C-调用汇编代码"><a href="#C-调用汇编代码" class="headerlink" title="C++ 调用汇编代码"></a>C++ 调用汇编代码</h3><p><strong>使用汇编代码的时机和意义</strong></p><p><img src="https://bu.dusays.com/2024/12/09/675697d600c3a.png"></p><p><strong>Microsoft c++ x86 内联汇编</strong></p><p><img src="https://bu.dusays.com/2024/12/09/675697d600c3a.png"></p><p><img src="https://bu.dusays.com/2024/12/09/67569ae9428a8.png"></p><p><img src="https://bu.dusays.com/2024/12/09/67569ae99537e.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">250</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不需要加分号   使用__asm来分割</span></span><br><span class="line">    __asm mov eax,a</span><br><span class="line">    __asm add eax,<span class="number">1</span></span><br><span class="line">    __asm mov a,eax</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; a;  <span class="comment">// 251</span></span><br><span class="line">    <span class="comment">// 这样省略了很多__asm</span></span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        mov eax, a</span><br><span class="line">        add eax, <span class="number">1</span></span><br><span class="line">        mov a, eax</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; a;  <span class="comment">// 252</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>__asm 中汇编使用规范</strong></p><p>_asm支持</p><p>Pentium 4 和 AMD Athlon 所有操作码</p><p>支持MMX指令集</p><p>可以利用_emit创建目标处理器支持的其他指令</p><p>如果_emit生成修改寄存器的值，编译器无法确定哪些寄存器受到影响，这个时候编译器容易做出错误的判断，程序可能产生不可预测的行为。</p><p>asm 与  段引用  __asm中必须通过寄存器来引用段  不能通过段名称来访问</p><p><img src="https://bu.dusays.com/2024/12/09/6756a0231248e.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">1000</span>];</span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line"><span class="type">int</span> arySize;</span><br><span class="line"><span class="type">int</span> typeAry;</span><br><span class="line">_asm </span><br><span class="line">&#123;</span><br><span class="line">    mov count,LENGTH a</span><br><span class="line">    mov arySize,SIZE a</span><br><span class="line">    mov typeAry,TYPE a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;元素个数为： &quot;</span> &lt;&lt; count &lt;&lt; std::endl;  <span class="comment">// 1000</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;元素大小为： &quot;</span> &lt;&lt; arySize &lt;&lt; std::endl; <span class="comment">// 4000</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;元素大小为： &quot;</span> &lt;&lt; typeAry &lt;&lt; std::endl;  <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p><strong>__asm的调试</strong></p><p>&#x2F;Zi 编译选项 可以使用源代码调试内联汇编程序，可以在C&#x2F;C++&#x2F;汇编代码上设置断点</p><p>把多条汇编语言放在同一行可能会妨碍调试</p><p><strong>__asm中 C&#x2F;C++使用规范</strong></p><p><img src="https://bu.dusays.com/2024/12/09/6756a02410305.png"></p><p><strong>__asm代码优化和寄存器的注意事项</strong></p><p>_fastcall 不建议包含_asm代码</p><p>esp、ebp跟栈有关系，不能随便改</p><p><strong>_declspec(naked)</strong></p>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cpp11多态</title>
      <link href="/2024/12/11/cpp11%E5%A4%9A%E6%80%81/"/>
      <url>/2024/12/11/cpp11%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<p><strong>多态概念</strong></p><p>多态是面向对象编程中的一个重要概念，它允许在基类的指针或引用指向派生类对象时，调用不同的函数实现。换句话说，多态是指同一接口在不同对象中有不同的实现方式。</p><p>多态的基本分类：</p><p>①  编译时多态（静态多态）：通过函数重载和运算符重载来实现。</p><p>② 运行时多态 （动态多态）：通过继承和虚函数来实现。</p><p>对象多态</p><p>① 向上转型   父类&#x3D;&#x3D;&gt;子类  人是动物 </p><p>② 向下转型   子类&#x3D;&#x3D;&gt;父类  动物是人  相当于用子类代替父类  （大神和沙雕之间二象性）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 30多态概念.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span>  age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Human</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> Money;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doit</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Do it~!!!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Human laow&#123;&#125;;</span><br><span class="line">    laow.age = <span class="number">50</span>;</span><br><span class="line">    laow.Money = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向上转型</span></span><br><span class="line">    <span class="comment">//Animal anm = laow;  // 可能发生内存切片的问题</span></span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; anm.age &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="comment">// 使用指针,没有内存截断问题</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//Human* human = anm1;  // human的成员变量要比anm1多</span></span><br><span class="line">    Animal* anm1 = &amp;laow;</span><br><span class="line">    <span class="comment">// 向下转型   更大的目的是调用里面的函数</span></span><br><span class="line">    Human* human = (Human*)anm1;</span><br><span class="line"></span><br><span class="line">    human-&gt;<span class="built_in">doit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法多态</strong></p><p>①  静态多态： 函数重载、函数模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span>  age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Human</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> Money;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doit</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Do it~!!!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BeAct</span><span class="params">(Human* R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BeAct</span><span class="params">(Animal* anm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Human laow;</span><br><span class="line">    Animal dog;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BeAct</span>(&amp;laow);</span><br><span class="line">    <span class="built_in">BeAct</span>(&amp;dog);  <span class="comment">// 静态多态   编译的时候决定使用哪个函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>②  动态多态</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 30多态概念.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span>  age;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">BeAct</span><span class="params">(Animal* anm)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;动物被攻击！！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Human</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> Money;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doit</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Do it~!!!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">BeAct</span><span class="params">(Animal* anm)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;人物被攻击！！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Human laow;</span><br><span class="line">    Animal dog;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    Animal* bA;</span><br><span class="line">    std::cin &gt;&gt; id;</span><br><span class="line">    <span class="keyword">if</span> (id)</span><br><span class="line">    &#123;</span><br><span class="line">        bA = &amp;dog;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> bA = &amp;laow;</span><br><span class="line">    bA-&gt;<span class="built_in">BeAct</span>(&amp;dog);  <span class="comment">// 编译的时候不确定，就叫做动态多态 ！！！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>virtual关键字</code></strong></p><p>它是一个在基类中声明，并且希望在派生类中重写（或覆盖）的方法。通过虚函数，可以实现多态性，使得程序能够在运行时根据对象的实际类型来调用适当的函数，而不是在编译时就决定调用哪个函数。</p><p><img src="https://bu.dusays.com/2024/12/08/67550c89eea41.png"></p><p>override 后缀可以强制要求检查函数是重载</p><p>final 后缀可以终止函数的重载</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 31多态虚函数.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MoveObject</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="comment">// virtual只能放在类内部声明</span></span><br><span class="line">    <span class="comment">// 不加上virtual 就是静态绑定</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="keyword">virtual</span> <span class="title">Move</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 如果这里设置成private，那么这个函数在派生类里面用不了</span></span><br><span class="line"><span class="comment">// private:</span></span><br><span class="line">    <span class="comment">// 虚函数在派生类和基类中的返回值要求基本一致，但是当返回类型为类类型的指针和引用时除外</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> MoveObject* <span class="title">Move1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x++;</span><br><span class="line">        y++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MoveObject::Move</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x++;</span><br><span class="line">    y++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NPCObject</span>:<span class="keyword">public</span> MoveObject</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 这种不是覆盖   而是动态绑定</span></span><br><span class="line">    <span class="comment">// 不重写 也能运行，因为继承了基类的Move函数，调用基类中的Move函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x++;</span><br><span class="line">        y++;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;我是NPC\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//void Move(int a);  // 如果参数不一样，那就是一个正常的函数</span></span><br><span class="line">    <span class="comment">// 如果这么写的话，那么调用的就是MoveObject中的Move函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 虚函数在派生类和基类中的返回值要求基本一致，但是当返回类型为类类型的指针和引用时除外</span></span><br><span class="line">    <span class="comment">// MoveObject派生除了NPCObject，那么这里可以用MoveObject或者NPCObject</span></span><br><span class="line">    <span class="comment">// 如果NPCObject类不再派生的话，后面加上final可以</span></span><br><span class="line">    <span class="function">NPCObject* <span class="title">Move1</span><span class="params">()</span>   <span class="comment">// 协变</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x++;</span><br><span class="line">        y++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*只要是派生类的虚函数都要加上override关键字*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MonsterObject</span> :<span class="keyword">public</span> MoveObject</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x++;</span><br><span class="line">        y++;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;我是怪物\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">MonsterObject* <span class="title">Move1</span><span class="params">()</span>   <span class="comment">// 协变</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x++;</span><br><span class="line">        y++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是以前的写法</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">void Move(MonsterObject* obj)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    obj-&gt;Move();</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">void Move(NPCObject* obj)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    obj-&gt;Move();</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在多态的写法， 只写一个基类即可</span></span><br><span class="line"><span class="comment">// 调用类的对象时无法使用虚函数的，必须使用基类指针来实现虚函数的调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样写调用的是MoveObject中的Move</span></span><br><span class="line"><span class="comment">/*void Move(MoveObject obj)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    obj.Move();</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="comment">// 引用的本质也是个指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">(MoveObject&amp; obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj.<span class="built_in">Move</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MonsterObject snake;</span><br><span class="line">    NPCObject zsf;</span><br><span class="line">    <span class="comment">// 如果没有virtual，那么就是静态绑定，什么都不会输出</span></span><br><span class="line">    <span class="comment">// 调用的是MoveObject 中的 Move函数</span></span><br><span class="line">    <span class="built_in">Move</span>(snake);</span><br><span class="line">    <span class="built_in">Move</span>(zsf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 建议虚函数做成私有的，不破坏封装，可以通过基类指针访问</span></span><br></pre></td></tr></table></figure><p><strong>虚函数详解</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 虚函数详解.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MoveObject</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MoveObject</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 构造函数，先构造基类再构造派生类</span></span><br><span class="line">        <span class="comment">//  派生类还没有构造，所以调用的就是MoveObject中的Move</span></span><br><span class="line">        std::cout &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">Move</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Move</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;MoveObject Moving~\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 相当于this-&gt;Move()</span></span><br><span class="line">        <span class="comment">// Move又是一个虚函数，所以调用的就是下面MonsterObject中的Move函数</span></span><br><span class="line">        <span class="built_in">Move</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MoveObject</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 只能做静态绑定，调用基类中的Move函数</span></span><br><span class="line">        <span class="built_in">Move</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MonsterObject</span> :<span class="keyword">public</span> MoveObject</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Monster Moving\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MonsterObject</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">        MoveObject::<span class="built_in">test</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">MonsterObject</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 先析构派生类  再析构基类  </span></span><br><span class="line">        <span class="built_in">Move</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 面试重点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MonsterObject snake;</span><br><span class="line">    <span class="comment">// 调用的是Monster中的Move</span></span><br><span class="line">    snake.<span class="built_in">test</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>调用虚函数基类版本</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoveObject::<span class="built_in">Move</span>();  <span class="comment">// 这样就能调用基类版本的Move函数了</span></span><br></pre></td></tr></table></figure><p><strong>默认实参在虚函数重点错误</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">AutoMove</span><span class="params">(<span class="type">int</span> step = <span class="number">2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;auto move&quot;</span> &lt;&lt; step &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AutoMove</span><span class="params">(<span class="type">int</span> step = <span class="number">3</span>)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 编译的时候已经决定了step的值,在这里改没什么用</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;~~~~~~auto move&quot;</span> &lt;&lt; step &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main()</span></span><br><span class="line">MonsterObject snake;</span><br><span class="line"></span><br><span class="line">MoveObject* p = &amp;snake;</span><br><span class="line">p-&gt;<span class="built_in">AutoMove</span>();</span><br><span class="line"><span class="comment">// 调用的是派生类的AutoMove  但是step的值在编译的时候就已经确定了，在派生类里面改是没有用的</span></span><br></pre></td></tr></table></figure><p><strong>释放含有虚函数的派生对象</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 虚函数详解.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MoveObject</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MoveObject</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">Move</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Move</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;MoveObject Moving~\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">AutoMove</span><span class="params">(<span class="type">int</span> step = <span class="number">2</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;auto move&quot;</span> &lt;&lt; step &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">Move</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">MoveObject</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; Moveobj析构函数！！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">Move</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 析构函数中没有内容的话可以换种写法</span></span><br><span class="line">    <span class="comment">// virtual ~MoveObject() = default;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MonsterObject</span> :<span class="keyword">public</span> MoveObject</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Monster Moving\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MonsterObject</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">        MoveObject::<span class="built_in">Move</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AutoMove</span><span class="params">(<span class="type">int</span> step = <span class="number">3</span>)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 编译的时候已经决定了step的值,在这里改没什么用</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~~~~~~auto move&quot;</span> &lt;&lt; step &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">MonsterObject</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; Monsterobj析构函数！！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">Move</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 面试重点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// MonsterObject snake;</span></span><br><span class="line"></span><br><span class="line">    MoveObject* p = <span class="keyword">new</span> <span class="built_in">MonsterObject</span>();</span><br><span class="line">    p-&gt;<span class="built_in">AutoMove</span>();</span><br><span class="line">    <span class="keyword">delete</span> p; <span class="comment">// 触发析构函数，先析构派生类再析构基类</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数不是虚函数，所以调用MoveObject中的析构函数</span></span><br><span class="line">    <span class="comment">//p-&gt;~MoveObject()</span></span><br><span class="line">    <span class="comment">// 但是没有释放内存，造成内存泄露，所以做一个虚析构函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在类里面，析构函数和构造函数是静态绑定，其余都是动态绑定的。</p><p><strong>对象多态详解</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 33对象多态详解.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MoveObject</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*virtual*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MonsterObject</span> :<span class="keyword">public</span> MoveObject</span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NPCObject</span> :<span class="keyword">public</span> MoveObject</span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wolf</span> :<span class="keyword">public</span> MonsterObject</span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Man</span> :<span class="keyword">public</span> MonsterObject</span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WolfMan</span> :<span class="keyword">public</span> Wolf,<span class="keyword">public</span> MoveObject,<span class="keyword">public</span> Man</span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MonsterObject monster;</span><br><span class="line">    MoveObject* _move = &amp;monster;  <span class="comment">// 隐式类型转换，向上转型</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// _move = new MoveObject();</span></span><br><span class="line">    <span class="comment">// 编译器不确定_pmonster指向的是什么</span></span><br><span class="line">    <span class="comment">// MonsterObject* _pmonster = _move; // 隐式类型转换不被允许  向下转型不允许</span></span><br><span class="line">    <span class="comment">//可以强制，但是基类得是可以访问的才行</span></span><br><span class="line">    MonsterObject* _pmonster = (MonsterObject*)_move; <span class="comment">// 强制类型转换  向下转换</span></span><br><span class="line">    MonsterObject* _pmonsterA = <span class="built_in">static_cast</span>&lt;MonsterObject*&gt;(_move); <span class="comment">// 静态强制类型转换</span></span><br><span class="line">    <span class="comment">// 虚基类不能强制转换，类是虚拟的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line">    WolfMan wolfman;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* ptr = &amp;wolfman;</span><br><span class="line">    Wolf* pwlf = &amp;wolfman;</span><br><span class="line">    <span class="comment">// Man* pman = &amp;wolfman;</span></span><br><span class="line">    <span class="comment">// 存在类型转换</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ptr: &quot;</span> &lt;&lt; ptr &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;pwlf: &quot;</span> &lt;&lt; pwlf &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; &quot;pman: &quot; &lt;&lt; pman &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;----------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">void</span>* ptr1 = &amp;wolfman;</span><br><span class="line">    Wolf* pwlf1 = (Wolf*)ptr1;  <span class="comment">// void* =&gt; Wolf*</span></span><br><span class="line">    <span class="comment">//Man* pman1 = (Man*)ptr1;  // 指针   类型 和内存地址</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ptr1: &quot;</span> &lt;&lt; ptr1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;pwlf1: &quot;</span> &lt;&lt; pwlf1 &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; &quot;pman1: &quot; &lt;&lt; pman1 &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;----------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">void</span>* ptr2 = &amp;wolfman;</span><br><span class="line">    Wolf* pwlf2 = (Wolf*)&amp;wolfman;  <span class="comment">// void* =&gt; Wolf*  Wolfman*=&gt;Wolf</span></span><br><span class="line">    <span class="comment">//Man* pman2 = (Man*)&amp;wolfman;    // 类型</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ptr2: &quot;</span> &lt;&lt; ptr2 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;pwlf2: &quot;</span> &lt;&lt; pwlf2 &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; &quot;pman2: &quot; &lt;&lt; pman2 &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//_move = &amp;wolfman; // 多重继承  编译器不知道怎么转，尽量避免多重继承</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;----------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    WolfMan wolfman1;</span><br><span class="line">    wolfman<span class="number">1.</span>::Wolf::MonsterObject::MoveObject::x = <span class="number">2500</span>;</span><br><span class="line">    wolfman<span class="number">1.</span>::MoveObject::x = <span class="number">3500</span>;</span><br><span class="line">    MoveObject* _move1 = <span class="built_in">static_cast</span>&lt;MoveObject*&gt;(&amp;wolfman1);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; _move1-&gt;x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>强制类型转换都是有风险的！！！</p><p><strong>动态强制转换</strong></p><p><img src="https://bu.dusays.com/2024/12/08/67555d8e3fb89.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 33对象多态详解.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MoveObject</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Move</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//if (dynamic_cast&lt;MonsterObject*&gt;(this))</span></span><br><span class="line">        <span class="comment">// 不推荐写法，非常依赖派生类</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*virtual*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MonsterObject</span> :<span class="keyword">public</span> MoveObject</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NPCObject</span> :<span class="keyword">public</span> MoveObject</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wolf</span> :<span class="keyword">public</span> MonsterObject</span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Man</span> :<span class="keyword">public</span> MonsterObject</span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">boss</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WolfMan</span> : <span class="keyword">public</span> Man<span class="comment">//,public boss</span></span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无论 向上转还是向下转，推荐无损转，使用指针或者引用来转</span></span><br><span class="line">    MonsterObject monster;</span><br><span class="line">    MoveObject* _move =(MoveObject*)&amp;monster;</span><br><span class="line">    MoveObject&amp; lMove = monster;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//_move = new MoveObject();</span></span><br><span class="line">    <span class="comment">//MonsterObject* _pmonsterA = dynamic_cast&lt;MonsterObject*&gt;(_move);</span></span><br><span class="line">    <span class="comment">//auto _pmonsterA = dynamic_cast&lt;MonsterObject*&gt;(_move);</span></span><br><span class="line">    <span class="comment">//MonsterObject和NPCObject之间没有继承关系，_move不能被转换为NPCObject*。</span></span><br><span class="line">    <span class="comment">//auto _pmonsterB = dynamic_cast&lt;NPCObject*&gt;(_move);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//if (_pmonsterA != nullptr) _pmonsterA-&gt;MonsterMove();</span></span><br><span class="line">    <span class="comment">//if (_pmonsterB != nullptr) _pmonsterB-&gt;NPCMove();</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 直接这样使用就可以了，避免过度使用 dynamic_cast</span></span><br><span class="line">    <span class="comment">//_move-&gt;Move();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不应该转换  没有空引用 </span></span><br><span class="line">    <span class="comment">//NPCObject&amp; lNPC = dynamic_cast&lt;NPCObject&amp;&gt;(monster);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//没有关系的类转换   跨类转换</span></span><br><span class="line">    WolfMan wlfman;</span><br><span class="line">    MoveObject* pMove = &amp;wlfman;</span><br><span class="line">    <span class="keyword">auto</span> p = <span class="built_in">dynamic_cast</span>&lt;WolfMan*&gt;(pMove);</span><br><span class="line">    <span class="keyword">auto</span> p1 = <span class="built_in">dynamic_cast</span>&lt;boss*&gt;(pMove);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;p: &quot;</span> &lt;&lt; p &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;p1: &quot;</span> &lt;&lt; p1 &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>抽象类</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 拥有纯虚函数的类称为抽象类，因为该类的函数没有实现，因此不能创建抽象类的实例</span></span><br><span class="line"><span class="comment">// 但是可以使用抽象类的指针和引用作为返回或参数！！</span></span><br><span class="line"><span class="comment">// 抽象类的构造函数因为不能实际使用，所以一般推荐把抽象类的构造函数定义为protected</span></span><br><span class="line"><span class="comment">// 抽象类的派生类如果没有定义纯虚函数，则该派生类依然是抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="keyword">virtual</span> <span class="title">Move</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 这个虚函数没什么实际内容，就设计成纯虚函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="keyword">virtual</span> <span class="title">fly</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="keyword">virtual</span> <span class="title">Notice</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 发送通知</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="keyword">virtual</span> <span class="title">Eat</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个类里面都是纯虚函数，没有提供具体内容，这就是接口类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">Animal</span>() &#123;&#125;  <span class="comment">// 抽象类的构造函数因为不能实际使用，所以一般推荐把抽象类的构造函数定义为protected</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="keyword">virtual</span> <span class="title">Move</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里没有fly函数的，所以这个类也是抽象类</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="keyword">virtual</span> <span class="title">Move</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Animal GetAnm() &#123; &#125;  不能创建实体</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 拥有纯虚函数的类称为抽象类，因为该类的函数没有实现，因此不能创建抽象类的实例</span></span><br><span class="line">    <span class="comment">//Animal anm;</span></span><br><span class="line">    <span class="comment">//Animal* anm1 = new Cat(); // 指针可以，实体不行</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>类的成员函数的指针</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类的成员函数的函数指针.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里限定了类Wolf</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wolf</span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(Wolf::* PGROUP)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wolf</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Count</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Wolf</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        pGroup = &amp;Wolf::Group0;</span><br><span class="line">        (<span class="keyword">this</span>-&gt;*pGroup)();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Group0</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;一阶段！！！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Group1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;二阶段！！！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Group2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;三阶段！！！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PGROUP pGroup;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*COUNT)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PGROUP pFunction = &amp;Wolf::Group2;</span><br><span class="line">    Wolf* pWolf = <span class="keyword">new</span> <span class="built_in">Wolf</span>();</span><br><span class="line">    (pWolf-&gt;*pFunction)();  <span class="comment">// 成员函数的函数指针</span></span><br><span class="line"></span><br><span class="line">    COUNT _count = &amp;Wolf::Count;</span><br><span class="line">    _count();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Wolf</span>; <span class="comment">// 类的前置声明</span></span><br><span class="line"><span class="comment">// 定义了一个新类型PGROUP，它是指向Wolf类的成员函数指针，指向的成员函数没有参数且返回类型为void</span></span><br><span class="line"><span class="comment">// PGROUP 是一个类型别名，用于指向Wolf类中没有参数且返回类型为void的成员函数。</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(Wolf::* PGROUP)</span><span class="params">()</span></span>;  </span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Wolf</span>()</span><br><span class="line">&#123;</span><br><span class="line">    pGroup = &amp;Wolf::Group0;  <span class="comment">// 构造函数中初始化pGroup</span></span><br><span class="line">    (<span class="keyword">this</span>-&gt;*pGroup)();        <span class="comment">// 调用pGroup指向的成员函数</span></span><br><span class="line">    PGROUP pGroup;  <span class="comment">// 成员函数指针，指向Wolf类的成员函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// COUNT是一个类型别名，用于定义指向没有参数且返回类型为void 普通函数的指针</span></span><br><span class="line"><span class="comment">// COUNT 是一个指向无参数无返回值函数的指针。</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*COUNT)</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PGROUP pFunction = &amp;Wolf::Group2;  <span class="comment">// 定义一个成员函数指针，指向Group2</span></span><br><span class="line">    Wolf* pWolf = <span class="keyword">new</span> <span class="built_in">Wolf</span>();  <span class="comment">// 创建一个Wolf对象（会调用构造函数）</span></span><br><span class="line">    (pWolf-&gt;*pFunction)();  <span class="comment">// 通过成员函数指针调用Group2</span></span><br><span class="line"></span><br><span class="line">    COUNT _count = &amp;Wolf::Count;  <span class="comment">// 定义一个普通函数指针，指向静态成员函数Count</span></span><br><span class="line">    _count();  <span class="comment">// 调用静态成员函数Count</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成员函数指针：指向类成员函数时，需要使用::*语法并制定类名。在调用的时候，必须通过类实例（this指针）来调用。</p><p>静态成员函数：静态成员函数不依赖于对象实例，可以像普通函数一样直接通过类名或函数指针调用。</p><p>成员函数与普通函数指针的不同：成员函数指针需要对象实例来调用，而普通函数指针则不需要。</p><p><strong>多态：虚函数的实现</strong></p><p>（面试可能问到）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConsoleApplication1.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Hack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;劫持了！！！1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AIM</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> HP;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Eat</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;AIM&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Die</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;AIM_die&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wolf</span> :<span class="keyword">public</span> AIM</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Eat</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Wolf&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Die</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;WOLF-DIE&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Sound</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;aoaoaoaoa~~~~&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AIM* wolf = <span class="keyword">new</span> <span class="built_in">Wolf</span>();</span><br><span class="line">    wolf-&gt;<span class="built_in">Die</span>(); <span class="comment">// 调用的是Wolf类中的函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出8   多了4个字节</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span>(AIM) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试下多出的四个字节是头部还是尾部</span></span><br><span class="line">    std::cout &lt;&lt; wolf &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;wolf-&gt;HP &lt;&lt; std::endl; <span class="comment">// 加在头部了</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span>* vtable = (<span class="type">unsigned</span>*)wolf;</span><br><span class="line">    std::cout &lt;&lt; std::hex &lt;&lt; <span class="string">&quot;Vtable:  &quot;</span> &lt;&lt; vtable[<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span>* func = (<span class="type">unsigned</span>*)vtable[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::hex &lt;&lt; <span class="string">&quot;eat: &quot;</span> &lt;&lt; func[<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; std::hex &lt;&lt; <span class="string">&quot;die: &quot;</span> &lt;&lt; func[<span class="number">1</span>] &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过修改虚函数表的数据可以实现劫持</span></span><br><span class="line">    DWORD old;</span><br><span class="line">    <span class="built_in">VirtualProtect</span>(func, <span class="number">8</span>, PAGE_EXECUTE_READWRITE, &amp;old);</span><br><span class="line">    func[<span class="number">0</span>] = (<span class="type">unsigned</span>)Hack;</span><br><span class="line">    func[<span class="number">1</span>] = (<span class="type">unsigned</span>)Hack;</span><br><span class="line">    wolf-&gt;<span class="built_in">Eat</span>();</span><br><span class="line">    <span class="comment">// 以上只是影响的Wolf类  </span></span><br><span class="line"></span><br><span class="line">    AIM* _aim = <span class="keyword">new</span> <span class="built_in">AIM</span>();</span><br><span class="line">    _aim-&gt;<span class="built_in">Eat</span>();</span><br><span class="line"></span><br><span class="line">    AIM* _aim1 = <span class="keyword">new</span> <span class="built_in">Wolf</span>();</span><br><span class="line">    _aim1-&gt;<span class="built_in">Eat</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有通过指针访问函数才会调用虚函数表</span></span><br><span class="line">    Wolf wl;</span><br><span class="line">    wl.<span class="built_in">Sound</span>();  <span class="comment">// 这个不涉及指针，能够调用我们想要的函数</span></span><br><span class="line">    wl.<span class="built_in">Eat</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/12/09/67568e837d723.png"></p><p> 虚表的性质</p><p>1️⃣ 同一个类的多个实例都指向同一个虚函数表</p><p>2️⃣ 通过修改虚函数表的数据可以实现劫持</p><p>3️⃣ 只有通过指针访问函数才会调用虚函数表</p>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cpp10继承</title>
      <link href="/2024/12/11/cpp10%E7%BB%A7%E6%89%BF/"/>
      <url>/2024/12/11/cpp10%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<p><strong>继承的概念</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span>:<span class="keyword">public</span> Base<span class="comment">//公有继承</span></span><br><span class="line">&#123;&#125;；</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive2</span>:<span class="keyword">protected</span> Base <span class="comment">//保护继承</span></span><br><span class="line">&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive3</span>:<span class="keyword">private</span> Base<span class="comment">//私有继承</span></span><br><span class="line">&#123;&#125;;</span><br><span class="line"><span class="comment">//上面的代码中，Derive，Derive2，Derive3都继承自Base基类</span></span><br><span class="line"><span class="comment">//区别就是继承方式不同</span></span><br></pre></td></tr></table></figure><p><strong>多继承</strong></p><p>如果省略继承方式，默认为<code>private</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> &lt;派生类名&gt;:&lt;继承方式<span class="number">1</span>&gt;&lt;基类名<span class="number">1</span>&gt;,&lt;继承方式<span class="number">2</span>&gt;&lt;基类名<span class="number">2</span>&gt;,....</span><br><span class="line">&#123;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/12/07/6753b6c38f762.png"></p><p>private 和 protected 区别：类继承，private无法被访问  protected可以被访问。</p><p>继承的时候，私有变量是占内存空间的，但是没办法访问。。。</p><p><strong>继承中的访问控制</strong></p><p><img src="https://bu.dusays.com/2024/12/07/6753c254715ca.png"></p><p><img src="https://bu.dusays.com/2024/12/07/6753c2ca2a6ed.png"></p><p><img src="https://bu.dusays.com/2024/12/07/6753c3c88b103.png"></p><p>一般来说，尽量设计类的成员变量为private，如果需要访问这些成员变量，应该提供setter以及getter函数。</p><p><strong>继承中的构造函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">object</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mapObject</span> :<span class="keyword">public</span> object</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">actObject</span> :<span class="keyword">public</span> mapObject</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 构造顺序为object-&gt;mapObject-&gt;actObject</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">object</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line"><span class="built_in">object</span>()</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;object was created\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">object</span>(<span class="type">const</span> object&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;object was created by copy\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mapObject</span> :<span class="keyword">public</span> object</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> mapId;</span><br><span class="line"><span class="built_in">mapObject</span>()</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot; mapObject was created\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">mapObject</span>(<span class="type">const</span> mapObject&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot; mapObject was created by copy\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">mapObject</span>(<span class="type">int</span> id) :mapId&#123; id &#125;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">actObject</span> :<span class="keyword">public</span> mapObject</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> damage;</span><br><span class="line"><span class="comment">// 不能加上mapId  因为现在还没有构造，不认为mapId是actObject的成员</span></span><br><span class="line"><span class="built_in">actObject</span>():mapObject&#123;<span class="number">100</span>&#125;,damage&#123;<span class="number">100</span>&#125;</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 可以在里面写</span></span><br><span class="line">mapId = <span class="number">3939</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot; actObject was created\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// mapObject&#123;obj&#125;没有做类型转换就传进去了</span></span><br><span class="line"><span class="built_in">actObject</span>(<span class="type">const</span> actObject&amp; obj):mapObject&#123;obj&#125;</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;actObject&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">actObject obj&#123;&#125;;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">actObject obj2 = obj;  <span class="comment">// 副本构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>继承构造函数</strong></p><p>允许派生类从基类继承构造函数。这意味着派生类可以使用基类的构造函数来初始化从基类继承来的数据成员，而不需要在派生类中重新定义类似的构造函数（默认构造函数和副本构造函数无法继承）</p><p>语法：<code>using &lt;基类名称&gt;::&lt;基类名称&gt;;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">object</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line"><span class="built_in">object</span>()</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;object was created\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">object</span>(<span class="type">const</span> object&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;object was created by copy\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mapObject</span> :<span class="keyword">public</span> object</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> mapId;</span><br><span class="line"><span class="built_in">mapObject</span>()</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot; mapObject was created\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">mapObject</span>(<span class="type">const</span> mapObject&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot; mapObject was created by copy\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">mapObject</span>(<span class="type">int</span> id) :mapId&#123; id &#125;</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">mapObject</span>(<span class="type">int</span> id, <span class="type">int</span> id2) :mapId&#123; id &#125;</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; id;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">actObject</span> :<span class="keyword">public</span> mapObject</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 这样就继承了mapObject中的构造函数   但是默认构造函数、副本构造函数没办法继承</span></span><br><span class="line"><span class="keyword">using</span> mapObject::mapObject;</span><br><span class="line"><span class="type">int</span> damage;</span><br><span class="line"><span class="comment">// 不能加上mapId  因为现在还没有构造，不认为mapId是actObject的成员</span></span><br><span class="line"><span class="built_in">actObject</span>():mapObject&#123;<span class="number">100</span>&#125;,damage&#123;<span class="number">100</span>&#125;</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 可以在里面写</span></span><br><span class="line">mapId = <span class="number">3939</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot; actObject was created\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// mapObject&#123;obj&#125;没有做类型转换就传进去了</span></span><br><span class="line"><span class="built_in">actObject</span>(<span class="type">const</span> actObject&amp; obj):mapObject&#123;obj&#125;</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;actObject&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">actObject obj&#123;<span class="number">200</span>&#125;;</span><br><span class="line">actObject objx&#123; <span class="number">200</span>,<span class="number">300</span> &#125;;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">actObject obj2 = obj;  <span class="comment">// 副本构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>继承中的析构函数与重名问题</strong></p><p>构造的时候由基类开始构造的，析构的时候恰恰相反，先析构派生类的</p><p>继承中的成员变量名称重复的问题</p><p>1️⃣ 函数名相同，参数不同</p><p>​using 基类::函数名</p><p>不会出错，有个作用域的问题，不存在变量名重复的问题，访问的时候 使用作用域的符号 <code>object::x</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mapObject MAP;</span><br><span class="line">MAP.x = <span class="number">2500</span>;</span><br><span class="line">MAP.object::x = <span class="number">3500</span>; <span class="comment">// 使用作用域来解决这个问题</span></span><br></pre></td></tr></table></figure><p>2️⃣ 函数名相同，参数相同</p><p>​基类::函数名</p><p>函数存在一个重载的问题，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数不同名字相同   直接 在派生类里面引入函数</span></span><br><span class="line"><span class="keyword">using</span> object::showX;</span><br><span class="line"><span class="comment">// 不引入的话会被覆盖掉</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果基类和派生类的函数名参数以及返回类型都一样， using已经区分不出来了，只能通过作用域来区别</span></span><br><span class="line"><span class="comment">// object类</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ShowX</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mapObject 类</span></span><br><span class="line"><span class="keyword">using</span> object::showX;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ShowX</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// actObject 类</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ShowX</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main函数</span></span><br><span class="line">mapObject MAP:</span><br><span class="line">MAP.<span class="built_in">ShowX</span>(<span class="number">1500</span>);  <span class="comment">// 调用派生类中的函数</span></span><br><span class="line">MAP.object::<span class="built_in">ShowX</span>(<span class="number">2500</span>);  <span class="comment">// 调用基类中的函数</span></span><br><span class="line"></span><br><span class="line">actObject obj;</span><br><span class="line">obj.<span class="built_in">ShowX</span>(<span class="string">&quot;222&quot;</span>);</span><br><span class="line">obj.mapObject::<span class="built_in">ShowX</span>(<span class="number">33</span>);</span><br><span class="line">obj.mapObject::object::<span class="built_in">ShowX</span>(<span class="number">44</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以直接调用,没什么层次感</span></span><br><span class="line">obj.object::<span class="built_in">ShowX</span>(<span class="number">55</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接这么操作即可</span></span><br></pre></td></tr></table></figure><p><strong>多重继承问题</strong></p><p>多重继承带来的重复继承的问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wolf</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bite</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Wolf Bite!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Wolf eat!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Man</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Man eat!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WolfMan</span> :<span class="keyword">public</span> Wolf, <span class="keyword">public</span> Man</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Change</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">IsWolf = !IsWolf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (IsWolf) Wolf::<span class="built_in">eat</span>();</span><br><span class="line"><span class="keyword">else</span> Man::<span class="built_in">eat</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">bool</span> IsWolf = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">WolfMan Jack;</span><br><span class="line">Jack.<span class="built_in">bite</span>();</span><br><span class="line">Jack.<span class="built_in">eat</span>();</span><br><span class="line">Jack.<span class="built_in">Change</span>();  <span class="comment">// 变身</span></span><br><span class="line">Jack.<span class="built_in">eat</span>();   <span class="comment">//  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>派生类之间的内存并不是重叠的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class MoveObject</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MoveObject</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">WolfMan Jack;</span><br><span class="line">Jack.<span class="built_in">bite</span>();</span><br><span class="line">Jack.Wolf::x = <span class="number">250</span>;</span><br><span class="line">Jack.Wolf::y = <span class="number">250</span>;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; Jack.Wolf::x &lt;&lt; std::endl;  <span class="comment">// 250</span></span><br><span class="line">std::cout &lt;&lt; Jack.Man::x &lt;&lt; std::endl;  <span class="comment">// -858993460</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>虚基类</strong>，如果发现已经继承一次了，下次就不会再继承的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class Man :public virtual MoveObject   这样就是虚基类</span></span><br><span class="line"><span class="comment">// class Wolf:public virtual MoveObject</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// main</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">WolfMan Jack;</span><br><span class="line">Jack.<span class="built_in">bite</span>();</span><br><span class="line">Jack.Wolf::x = <span class="number">250</span>;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; Jack.Wolf::x &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; Jack.x &lt;&lt; std::endl;    <span class="comment">// 这三个都是指向的一个x</span></span><br><span class="line">std::cout &lt;&lt; Jack.Man::x &lt;&lt; std::endl;  <span class="comment">// 虚基类，这样都是250，它俩x指向的是同一个地方，没有歧义了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>从内存的角度来理解继承</strong></p><p>未完待续。。。</p>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cpp09运算符重载</title>
      <link href="/2024/12/11/cpp09%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
      <url>/2024/12/11/cpp09%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<p>运算符重载的主要目的是为了让目标代码更方便使用和维护，而不是提升开发效率，重载运算符未必能提升开发效率。</p><p>① 让类也支持原生的运算  比如 + -  * &#x2F; </p><p>② 提升对程序的控制权  比如重载new  delete new[]   delete[]</p><p>它允许你为自定义类型（如类或结构体）定义操作符的行为，使得这些操作符可以像内建类型一样工作。通过重载运算符，可以使自定义对象之间的运算更加直观和简洁。运算符重载是通过定义特殊的成员函数或友元函数来实现的</p><p><strong>初探运算符重载</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(Person&amp; psa, Person&amp; psb);</span><br><span class="line"><span class="keyword">friend</span> <span class="type">bool</span> <span class="built_in">operator</span>&lt;(Person&amp; psa, <span class="type">unsigned</span> <span class="type">short</span> _Age);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> Age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">unsigned</span> <span class="type">short</span> _Age) :Age&#123; _Age &#125;&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得私有变量</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">GetAge</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Age; &#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&gt;(Person&amp; person);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类的成员函数来实现运算符重载</span></span><br><span class="line"><span class="type">bool</span> Person::<span class="keyword">operator</span>&gt;(Person &amp; person)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> Age &gt; person.Age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非类的成员函数实现运算符重载</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(Person&amp; psa, Person&amp; psb)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> psa.<span class="built_in">GetAge</span>() &lt; psb.Age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跟数字比</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(Person&amp; psa, <span class="type">unsigned</span> <span class="type">short</span> _Age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> psa.Age &lt; _Age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">Man</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">Woman</span><span class="params">(<span class="number">50</span>)</span></span>;</span><br><span class="line"><span class="comment">// 调用的是 Person::operator&gt;(Person &amp; person)</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">if</span> (Man&gt;Woman) std::cout &lt;&lt; <span class="string">&quot; 你找到富婆了！！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用operator&lt;(Person&amp; psa, unsigned short _Age)</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">if</span> (Man &lt; <span class="number">10</span>) std::cout &lt;&lt; <span class="string">&quot; 你找到富婆了！！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类的非成员函数实现运算符重载  声明为友元函数了</span></span><br><span class="line"><span class="comment">// Man &lt; Woman &lt;=&gt; operator&lt;(Man,Woman)</span></span><br><span class="line"><span class="keyword">if</span> (Man&lt;Woman) std::cout &lt;&lt; <span class="string">&quot; 你找到富婆了！！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>！！！记住理解那些等价关系</p><p><strong>运算符重载的原则和时机</strong></p><p><img src="https://bu.dusays.com/2024/12/03/674e63385333d.png"></p><p>不能把加法重载为减法！！！</p><p><img src="https://bu.dusays.com/2024/12/03/674e65fd43456.png"></p><p><img src="https://bu.dusays.com/2024/12/03/674e65fd5013e.png"></p><p><img src="https://bu.dusays.com/2024/12/03/674e65fd5ca10.png"></p><p>传递值或者传递引用  建议传递引用  尤其是右值引用，不修改在前面加上<code>const</code> 就可以了</p><p><strong>重载赋值运算符</strong></p><p>默认赋值运算符重载</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Role x, y;</span></span><br><span class="line"><span class="comment">....</span></span><br><span class="line"><span class="comment">y = x;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Role</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> hp;</span><br><span class="line">    <span class="type">int</span> mp;</span><br><span class="line">    Role&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Role&amp; role);</span><br><span class="line">    &#123;</span><br><span class="line">        hp = role.hp;</span><br><span class="line">        mp = role.mp;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Role&amp; operator=(const Role&amp; role) = delete;   那么编译器就不再重载了</span></span><br><span class="line">    <span class="comment">// main.cpp中  y = x不再正确了</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>实现赋值运算符的重载</strong></p><p>！！！operator&#x3D;只能用类的成员函数来实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Role</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> hp;</span><br><span class="line">    <span class="type">int</span> mp;</span><br><span class="line">    Role&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Role&amp; role);</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line">Role&amp; Role::<span class="keyword">operator</span>=(<span class="type">const</span> Role&amp; role)</span><br><span class="line">&#123;</span><br><span class="line">        hp = role.hp;</span><br><span class="line">        mp = role.mp;</span><br><span class="line">    <span class="comment">// 而且返回值是空的时候void Role::operator=(const Role&amp; role)</span></span><br><span class="line">    <span class="comment">// 如果注释掉 return *this;  </span></span><br><span class="line">    <span class="comment">// 那么就不能 z = y = x;</span></span><br><span class="line">    <span class="comment">// z.operator=(y.operator=(x));   因为返回值为空，所以这个操作不能执行了</span></span><br><span class="line">    <span class="comment">// 返回值编程Role 类型也没问题，但是引用节省开销</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Role x, y;</span><br><span class="line">    x.hp = <span class="number">100</span>;</span><br><span class="line">    y.mp = <span class="number">200</span>;</span><br><span class="line">    y = x;</span><br><span class="line">    <span class="comment">// z = y = x;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当类里面有指针的时候，往往不能采用默认运算符，必须重载（例子如下）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Role x, y, z;</span><br><span class="line">    x.hp = <span class="number">100</span>;</span><br><span class="line">    y.mp = <span class="number">200</span>;</span><br><span class="line">    </span><br><span class="line">    z = y =x;</span><br><span class="line">    std::cout &lt;&lt; y.hp &lt;&lt; <span class="string">&quot;//////&quot;</span> &lt;&lt; y.mp;</span><br><span class="line">    <span class="type">char</span> strA[]&#123; <span class="string">&quot;aaaaabbbccccc&quot;</span> &#125;;</span><br><span class="line">    hstring str&#123; strA &#125;;</span><br><span class="line">    <span class="comment">// 如果strA的内存空间改变了，那么str没有值了，因为内存空间不属于str</span></span><br><span class="line">    strA[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    std::cout &lt;&lt; str.<span class="built_in">c_str</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>重载赋值运算符的代码如下</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hstring.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">hstring::GetStrLen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (str[len] != <span class="string">&#x27;\0&#x27;</span>) &#123;  <span class="comment">// 遍历字符串直到遇到 &#x27;\0&#x27;</span></span><br><span class="line">len++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 拷贝  函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hstring::CopyStrs</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* source)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> len = <span class="built_in">GetStrLen</span>(source);</span><br><span class="line"><span class="keyword">if</span> (len &gt; usmlen)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[] cstr;  <span class="comment">// 释放之前分配的内存</span></span><br><span class="line">cstr = <span class="keyword">new</span> <span class="type">char</span>[len];  <span class="comment">// 重新分配内存</span></span><br><span class="line">usmlen = len; <span class="comment">// 修正内存长度 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memcpy</span>(cstr, source, len);</span><br><span class="line">cstr[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">uslen = len;  <span class="comment">// 字符串长度修正</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓冲区</span></span><br><span class="line"><span class="comment">// 默认构造函数 </span></span><br><span class="line">hstring::<span class="built_in">hstring</span>()</span><br><span class="line">&#123;</span><br><span class="line">usmlen = <span class="number">0x32</span>;  <span class="comment">// 内存空间等于32字节</span></span><br><span class="line">uslen = <span class="number">0</span>;</span><br><span class="line">cstr = <span class="keyword">new</span> <span class="type">char</span>[usmlen];</span><br><span class="line">cstr[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;  <span class="comment">// 初始化为空字符串</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化hstring类对象的构造函数。</span></span><br><span class="line"><span class="comment">// 带参数的构造函数</span></span><br><span class="line"><span class="comment">// 可以接受一个或者多个参数，在创建对象时，通过这些参数来初始化对象的数据成员。这使得对象在创建之初就能被赋予特定的值。</span></span><br><span class="line">hstring::<span class="built_in">hstring</span>(<span class="type">const</span> <span class="type">char</span>* str) :<span class="built_in">hstring</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">CopyStrs</span>(cstr, str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝构造函数  使用一个已经存在的同类型对象初始化新创建的对象。它的参数是一个常量引用，指向同类型的对象。</span></span><br><span class="line">hstring::<span class="built_in">hstring</span>(<span class="type">const</span> hstring&amp; str):<span class="built_in">hstring</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">CopyStrs</span>(cstr, str.cstr);</span><br><span class="line">&#125;</span><br><span class="line">hstring&amp; hstring::<span class="keyword">operator</span>=(<span class="type">const</span> hstring&amp; str)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> != &amp;str)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">CopyStrs</span>(cstr, str.cstr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hstring&amp; hstring::<span class="keyword">operator</span>=(<span class="type">const</span> <span class="type">long</span> <span class="type">long</span>&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (cstr != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] cstr;</span><br><span class="line">        cstr = <span class="literal">nullptr</span>;</span><br><span class="line">        usmlen = <span class="number">0</span>;</span><br><span class="line">        uslen = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> tempValue = value;</span><br><span class="line">    <span class="type">bool</span> isNegative = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 计算数字的位数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断负号</span></span><br><span class="line">    <span class="keyword">if</span> (tempValue &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        count++;  <span class="comment">// 负数的话  先把符号算进去</span></span><br><span class="line">        isNegative = <span class="literal">true</span>;</span><br><span class="line">        tempValue = -tempValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> temp = tempValue;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        temp = temp / <span class="number">10</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (temp &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先判断是否为负数再判断是否为0  如果为0 数值位数就是1</span></span><br><span class="line">    <span class="keyword">if</span> (tempValue == <span class="number">0</span>) count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    uslen = count;       </span><br><span class="line">    usmlen = uslen + <span class="number">1</span>;       </span><br><span class="line">    cstr = <span class="keyword">new</span> <span class="type">char</span>[usmlen];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> index = usmlen - <span class="number">2</span>; <span class="comment">// usmlen-1是\0</span></span><br><span class="line">    cstr[usmlen - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isNegative)</span><br><span class="line">    &#123;</span><br><span class="line">        cstr[<span class="number">0</span>] = <span class="string">&#x27;-&#x27;</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里tempValue已经是个非负数了</span></span><br><span class="line">    <span class="keyword">while</span> (tempValue &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> charValue = (<span class="type">char</span>)(tempValue % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        cstr[index--] = charValue;</span><br><span class="line">        tempValue = tempValue / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>重载&lt;&lt; 和&gt;&gt;</strong></p><p><img src="https://bu.dusays.com/2024/12/07/67545d0215102.png"></p><p>·</p><p><strong>重载括号()</strong></p><p><img src="https://bu.dusays.com/2024/12/03/674eb16dbd58f.png"></p><p><strong>重载二元运算符</strong></p><p><img src="https://bu.dusays.com/2024/12/03/674eb16d9fbeb.png"></p>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cpp08类</title>
      <link href="/2024/12/11/cpp08%E7%B1%BB/"/>
      <url>/2024/12/11/cpp08%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p><strong>静态成员变量</strong></p><p>static  关键字声明一个类的静态成员变量，类的静态成员变量的特点：</p><p>1️⃣ 所有类的实例中，共享类中的静态成员变量</p><p>2️⃣ 类的静态成员变量在没有类的实例的情况下，依然可以访问</p><p>3️⃣ 类的静态成员变量并不完全属于类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">T</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count;   <span class="comment">// 内存空间不属于类</span></span><br><span class="line">    <span class="type">int</span> hp;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> T::count = <span class="number">100</span>;  <span class="comment">//定义 必须加上T::</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T::cout &lt;&lt; <span class="number">350</span>;</span><br><span class="line">    T t1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态成员变量的初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">T</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">static</span> <span class="type">int</span> count&#123;&#125;;  <span class="comment">// 利用inline  在类里面定义count</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> hp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">T</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">static</span> <span class="type">int</span> count&#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> hp;</span><br><span class="line">    <span class="built_in">T</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        count ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">GetCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">T t4;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T t1, t2, t3;</span><br><span class="line">    T t5;</span><br><span class="line">    std::cout &lt;&lt; t<span class="number">1.</span><span class="built_in">GetCount</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">static</span> <span class="type">int</span> count&#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> hp;</span><br><span class="line">    <span class="built_in">T</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        count ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">GetCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">T</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">T t4;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T t1, t2, t3;</span><br><span class="line">    T t5;</span><br><span class="line">    std::cout &lt;&lt; t<span class="number">1.</span><span class="built_in">GetCount</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>静态成员常量</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">T</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">static</span> <span class="type">int</span> count&#123;<span class="number">250</span>&#125;;  <span class="comment">// 有时候可以在这里定义，有时候不可以，我个人觉得在外面定义</span></span><br><span class="line">    <span class="type">int</span> hp;</span><br><span class="line">    <span class="built_in">T</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        count ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">GetCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">T</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>静态成员函数</strong></p><p><img src="https://bu.dusays.com/2024/12/02/674da3de88eb6.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一条</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">inline</span> <span class="type">static</span> <span class="type">int</span> count&#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> hp;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Test</span><span class="params">()</span> <span class="comment">// const 第三条，不需要const来限定</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// hp++;  第二条  没有类的实例不能访问这个   一 二  条冲突</span></span><br><span class="line">        <span class="comment">// this-&gt;hp++;  避免访问非静态成员变量</span></span><br><span class="line">        count ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T::<span class="built_in">Test</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>友元类</strong></p><p>友元类是一个可以访问另一个类的私有成员（<code>private</code>）和保护成员（<code>protected</code>）的类。即使是私有或保护成员，友元类也可以直接访问它们，打破了类的封装性（encapsulation）的一部分。友元类的机制为类提供了一种灵活的方式来控制哪些外部类可以访问其私有成员。</p><p>友元会破坏类的封装性，没有更好选择的情况下再使用友元，友元咧不是一种平等的关系，你能访问它的私有变量，它不一样能访问你的私有变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">T</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> hp;  <span class="comment">// 默认为私有的</span></span><br><span class="line">    <span class="type">int</span> mp;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">GetMP</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; mp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">SetHP</span><span class="params">(T&amp; t1)</span></span>;  <span class="comment">// 可以有多个友元</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetHP</span><span class="params">(T&amp; t1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t<span class="number">1.</span>hp = <span class="number">100</span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">GetMP</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T1</span>;  <span class="comment">// 不在这里声明，那T中的T1编译器识别不出来</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> hp;  <span class="comment">// 默认为私有的</span></span><br><span class="line">    <span class="type">int</span> mp;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">GetMP</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; mp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">SetHP</span><span class="params">(T&amp; t1, T1&amp; t2)</span></span>;  <span class="comment">// 可以有多个友元</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">SetMP</span><span class="params">(T&amp; t1, T1&amp; t2)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> hp;  <span class="comment">// 默认为私有的</span></span><br><span class="line">    <span class="type">int</span> mp;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">GetMP</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; mp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">SetHP</span><span class="params">(T&amp; t1, T1&amp; t2)</span></span>;  <span class="comment">// 可以有多个友元</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">SetMP</span><span class="params">(T&amp; t1, T1&amp; t2)</span></span>; <span class="comment">// 放在public 或者 private 都可以</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetMP</span><span class="params">(T&amp; t1, T1&amp; t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t<span class="number">1.</span>hp = <span class="number">100</span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">GetMP</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetHP</span><span class="params">(T&amp; t1, T1 t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t<span class="number">1.</span>hp = <span class="number">100</span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">GetMP</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>嵌套类</strong></p><p>1️⃣ 用法</p><p>2️⃣ 作用域</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Role</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> hp;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">testx</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">WeaponLv</span></span><br><span class="line">&#123;</span><br><span class="line">normal = <span class="number">0</span>,</span><br><span class="line">high,</span><br><span class="line">rare,</span><br><span class="line">myth</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Role</span>()</span><br><span class="line">&#123;</span><br><span class="line">Weapon::<span class="built_in">test1</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Weapon</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> tt1;</span><br><span class="line"><span class="function">Weapon* <span class="title">ReturnW</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Weapon</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">testx</span>();  <span class="comment">// 可以访问Role静态成员函数</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Weapon</span>()</span><br><span class="line">&#123;</span><br><span class="line">Role role;</span><br><span class="line">role.hp++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">short</span> lv;</span><br><span class="line">WeaponLv wlv;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> mp;</span><br><span class="line">Weapon leftHands;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Role::Weapon* Role::Weapon::<span class="built_in">ReturnW</span>()  <span class="comment">// 注意作用域</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a1;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> x=<span class="number">250</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> hp;</span><br><span class="line"><span class="type">int</span> mp;</span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetHP</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">a1++;</span><br><span class="line"><span class="comment">//x++;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">GetCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">T t1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问权限问题：嵌套类可以访问外层类的所有成员 ，外层类仅能访问嵌套类的共有成员</p><p>枚举类型也可以放进去，但有个作用域的问题</p><p><strong>局部类</strong></p><p><strong>定义在函数内的类称为局部类</strong>：局部类的定义必须写在类内、 局部类中不允许使用静态成员变量、局部类可以访问全局变量。</p><p>静态成员变量不能定义在类里面，定义在外面又受作用域的问题，矛盾</p><p>虽然有<code>inline</code>关键字， 但避免那么写    局部类都少用</p><p><strong>嵌套类模块化问题</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Role.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="comment">// 这里不要Skill.h的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Role</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Skill</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Skill.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Role.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Role</span>::Skill</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> hp;</span><br><span class="line">    <span class="type">int</span> mp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Role.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Skill.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>malloc 和 new 的本质区别：malloc仅仅分配内存，new除了分配内存以外还会调用构造函数</p><p>free() 没有调用析构函数，delete不进释放内存空间，会调用类的析构函数</p><p><img src="https://bu.dusays.com/2024/12/02/674dba5f2954b.png"></p><p><img src="https://bu.dusays.com/2024/12/02/674dba5f505ef.png"></p><p><img src="https://bu.dusays.com/2024/12/02/674dba5f2e452.png"></p><p><strong>从底层理解类</strong></p><p><img src="https://bu.dusays.com/2024/12/02/674dbde4a10b1.png"></p><p><img src="https://bu.dusays.com/2024/12/02/674dbe7601fb6.png"></p><p><img src="https://bu.dusays.com/2024/12/02/674dbfcc11236.png"></p><p><strong>类的自定义函数调用</strong></p><p><strong>项目</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HPMed</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> Recover&#123; <span class="number">100</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Role</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> hp;</span><br><span class="line">    <span class="type">int</span> maxHp;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Role</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        hp = <span class="number">1000</span>;</span><br><span class="line">        maxHp = <span class="number">3500</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">GetHP</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;HP:&quot;</span> &lt;&lt; hp &lt;&lt; <span class="string">&quot;\\&quot;</span> &lt;&lt; maxHp&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">EatMed</span><span class="params">(HPMed&amp; hpMed)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        hp += hpMed.Recover;</span><br><span class="line">        hp = hp &gt; maxHp ? maxHp : hp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Role user;</span><br><span class="line">    HPMed med;</span><br><span class="line">    <span class="comment">//user = user + med;</span></span><br><span class="line">    user.<span class="built_in">GetHP</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        std::cin &gt;&gt; a;</span><br><span class="line">        user.<span class="built_in">EatMed</span>(med);</span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">        user.<span class="built_in">GetHP</span>();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cpp07编译器、面向对象</title>
      <link href="/2024/12/11/cpp07%E7%BC%96%E8%AF%91%E5%99%A8%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>/2024/12/11/cpp07%E7%BC%96%E8%AF%91%E5%99%A8%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p><code>#define A B</code>   将标识A定义为B的别名    <code>#define 整数  int</code>       <code>整数  a&#123;&#125;;</code></p><p><code>#define H</code>      定义一个标识符H， 代码中的H将会被删除掉   ，<code>int H a =&gt;  int a;</code>         提高代码可阅读性的</p><p><code>#undef H</code>      删除这个标识符的定义，以后用不了了，  删除的顺序是根据代码编译的顺序进行的。</p><p><strong>定义复杂表达式的宏</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _out_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUM(X, Y) X+Y*3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RELEASE(x) delete[] x, x = nullptr;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #define BIGGER(X, Y) (X&gt;Y?X:Y)   // (X&gt;Y?X:Y)必须加括号，不然处理不了</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BIGGER(X, Y) ((X)&gt;(Y)?(X):(Y))  <span class="comment">// 更保险的方式，全都加上括号</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHOW(X) std::cout&lt;&lt;X</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHOW1(X) std::cout&lt;&lt;#X   <span class="comment">// 处理成字符串</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHOW2(X,Y) void X##Y() &#123;std::cout&lt;&lt;#X;&#125;</span></span><br><span class="line"><span class="built_in">SHOW2</span>(test,<span class="number">22</span>)  <span class="comment">// 函数名字就叫test22</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">SUM</span>(<span class="number">100</span>,<span class="number">200</span>);   <span class="comment">// 100 + 200 * 3</span></span><br><span class="line">    <span class="type">int</span>* a = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">50</span>];</span><br><span class="line">    <span class="built_in">RELEASE</span>(a);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">BIGGER</span>(<span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line">    <span class="built_in">SHOW</span>(<span class="number">2333</span>);   <span class="comment">//  输出</span></span><br><span class="line">    <span class="built_in">SHOW1</span>(<span class="number">233</span>sdjfkldsjf);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">test22</span>();   <span class="comment">// 就可以调用这个函数了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>const int width&#123;100&#125;;</code></p><p><code>#define width 1000</code></p><p><code>#define</code> 的方式来定义常量存在一个问题，定义的常量并不具备类型，有时候并不安全</p><p><strong><code>namespace</code> 命名空间</strong></p><p>把相关的函数，变量，结构体放进一个命名空间里面</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// code.cpp</span></span><br><span class="line"><span class="keyword">namespace</span> t</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> p&#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t::v = <span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> p = <span class="number">200</span>;</span><br><span class="line">    std::cout &lt;&lt; p &lt;&lt; std::endl;  <span class="comment">// 输出200， 局部的</span></span><br><span class="line">    std::cout &lt;&lt; ::p &lt;&lt; std::endl;  <span class="comment">// 访问全局命名空间中的p  值为0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> x;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ::x;  <span class="comment">// 就能访问到code.cpp 中的 x</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全局命名空间，所有具有链接属性的对象，只要没有定义命名空间，就默认定义在全局命名空间中，全局命名空间中的成员的访问不用显示的指定，当局部名称覆盖了全局名称时才需要显式的指定全局命名空间。</p><p>命名空间是可以扩展的,命名空间可以放在多个头文件里面 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> t</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> t</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// t::// 这里会出来俩变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>命名空间的声明</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// htc.h   头文件</span></span><br><span class="line"><span class="keyword">namespace</span> t</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">int</span> v;  <span class="comment">// 这就是声明</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//code.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cc.h&quot;</span></span></span><br><span class="line"><span class="comment">// int t::v&#123; 20 &#125;;  这样也是可以的 </span></span><br><span class="line"><span class="keyword">namespace</span> t</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> v&#123;<span class="number">200</span>&#125;;  <span class="comment">// 声明和定义分开写了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; t::v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>命名空间的嵌套</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cc.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">namespace</span> t</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">int</span> v;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">namespace</span> hack</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">hack</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// code.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> t</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> v&#123; <span class="number">200</span> &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; t::v &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> t::hack::<span class="built_in">hack</span>()</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;hack!!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t::<span class="built_in">test</span>();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>未命名的命名空间  只针对本转换单元有效（待查询资料整理）</p><p>命名空间的别名</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> a = t::hack;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a::<span class="built_in">hack</span>();  <span class="comment">// 面对深度嵌套的命名空间，使用别名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> htd</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendSms</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">namespace</span> hack</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">hackServer</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> hServer = htd::hack;</span><br><span class="line">hServer::<span class="built_in">hackServer</span>();</span><br></pre></td></tr></table></figure><p><strong>未定义的命名空间和static</strong></p><p>未命名的命名空间是用<code>namespace &#123;&#125;</code>定义的，没有名字。</p><ul><li>任何定义在未命名命名空间中的变量、函数或类型仅在当前编译单元（文件）中可见。</li><li>实际上，未命名命名空间的内容被编译器视为具有<strong>内部链接</strong> （类似于<code>static</code>）。</li></ul><p>优点：提供了作用域隔离，防止名称冲突。相比static， 它可以包含多个声明(变量、函数、类型等)并形成一个逻辑分组。   建议使用未命名的命名空间代替<code>static</code>，因为它支持更复杂的结构和逻辑。</p><p>static 修饰的 变量或函数在当前文件中可见。</p><ul><li><code>static</code>变量和函数具有<strong>内部链接</strong> ，即它们只能在定义它们的文件中访问。</li><li>主要用于标记单个实体的作用域，不支持逻辑分组。</li></ul><p><img src="https://bu.dusays.com/2024/11/30/674ab5bf6fd98.png"></p><p><strong>预处理指令逻辑</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> VERSION 103</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SENDSMS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> VERSION==100&amp;&amp;SENDSMS   <span class="comment">// 这里可以做一些计算的  #if VERSION==(100 + 1)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sendSms</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> VERSION==101||SENDSMS</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sendSms</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> VERSION==102</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sendSms</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> VERSION==103</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sendSms</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> VERSION==104</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sendSms</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">// #if 和 #endif 是成套出现的</span></span><br></pre></td></tr></table></figure><p><strong>预定义宏</strong></p><p>标准预定义标识符  <code>__func__</code>   返回函数名字</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ave</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; __func__ &lt;&lt; std::endl;  <span class="comment">// 输出ave</span></span><br><span class="line"><span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">ave</span>(<span class="number">100</span>, <span class="number">1200</span>);</span><br><span class="line">std::cout &lt;&lt; __func__;  <span class="comment">//  输出main</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; __DATE__ &lt;&lt; std::endl;  <span class="comment">// 日期</span></span><br><span class="line">std::cout &lt;&lt; __TIME__ &lt;&lt; std::endl;  <span class="comment">// 时间</span></span><br><span class="line">std::cout &lt;&lt; __func__ &lt;&lt; std::endl;  <span class="comment">// 函数名</span></span><br><span class="line">std::cout &lt;&lt; __FILE__ &lt;&lt; std::endl;  <span class="comment">// 源文件名称</span></span><br><span class="line">std::cout &lt;&lt; __LINE__ &lt;&lt; std::endl;  <span class="comment">// 当前的行号</span></span><br><span class="line">std::cout &lt;&lt; __cplusplus &lt;&lt; std::endl;  <span class="comment">// 当翻译单元为C++时，__cplusplus为一个整数文本否则为未定义</span></span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/11/30/674a850dab4fb.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _CHAR_UNSIGNED</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;char unsigned&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; __FUNCDNAME__ &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; __FUNCSIG__ &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; __TIMESTAMP__ &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; _WIN64 &lt;&lt; std::</span><br><span class="line">    <span class="comment">//  _WIN64 仅在64位下才显示</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;win32\n&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_DEBUG</code>  在debug模式下可以使用，发布模式下没有了</p><p><strong>调试</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _DBG_FOR    <span class="comment">// 通过注释这里就可以不调试 </span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DBG_FOR</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br></pre></td></tr></table></figure><p><strong>assert断言</strong></p><p><img src="https://bu.dusays.com/2024/11/30/674aafc634452.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NDEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入一个整数\n&quot;</span>;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    std::cin &gt;&gt; c;</span><br><span class="line">    <span class="built_in">assert</span>(c);   <span class="comment">// 只要是0就会弹出来</span></span><br><span class="line">    std::cout &lt;&lt; <span class="number">1000</span> / c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>static_assert</strong></p><p>用于编译时检查条件</p><p><code>static_assert(bool 表达式,&quot;错误信息&quot;);</code></p><p><code>static_assert(bool表达式);</code></p><p>与assert不同，static_assert主要是用来在编译时检查重要的条件。  因此检查的bool表达式中，只能用于常量</p><p><strong>面向对象的编程</strong></p><p><img src="https://bu.dusays.com/2024/11/30/674b125faff00.png" alt="https:&#x2F;&#x2F;bu.dusays.com&#x2F;2024&#x2F;11&#x2F;30&#x2F;674b125faff00.png"></p><p>类      定义了对象的属性（成员变量）和行为（成员函数）</p><p>对象   是类的实例化，可以用来存储数据和调用函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NPC</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> hp;</span><br><span class="line"><span class="type">int</span> mp;</span><br><span class="line"><span class="type">int</span> damage;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MONSTER</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> hp;</span><br><span class="line"><span class="type">int</span> mp;</span><br><span class="line"><span class="type">int</span> damage;</span><br><span class="line"><span class="type">int</span> price;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ROLE</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> hp;</span><br><span class="line"><span class="type">int</span> mp;</span><br><span class="line"><span class="type">int</span> damage;</span><br><span class="line"><span class="type">int</span> diamond;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Act</span><span class="params">(NPC* acter, NPC* beacter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">beacter-&gt;hp -= acter-&gt;damage;</span><br><span class="line"><span class="keyword">return</span> beacter-&gt;hp &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MONSTER atm&#123; <span class="number">1000</span>,<span class="number">500</span>,<span class="number">100</span>,<span class="number">6000</span> &#125;;</span><br><span class="line">ROLE zs&#123; <span class="number">1000</span>,<span class="number">1000</span>,<span class="number">50</span>,<span class="number">1000</span> &#125;;</span><br><span class="line">ROLE ls&#123; <span class="number">1000</span>,<span class="number">500</span>,<span class="number">100</span>,<span class="number">600</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Act</span>((NPC*)&amp;atm, (NPC*)&amp;ls);  <span class="comment">// 只进行强制类型转换就可以了，没必要写很多函数了</span></span><br><span class="line">std::cout &lt;&lt; ls.hp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>一个例子</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Role.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Role.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Role::Act</span><span class="params">(Role&amp; role)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    role.hp -= damage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Role::Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hpRecover = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Role* <span class="title">Role::bigger</span><span class="params">(Role* role)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> role-&gt;lv &gt; lv ? role : <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Role&amp; <span class="title">Role::SetLv</span><span class="params">(<span class="type">int</span> newLv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    lv = newLv;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Role&amp; <span class="title">Role::SetHp</span><span class="params">(<span class="type">int</span> newHp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hp = newHp;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Role&amp; <span class="title">Role::SetDamage</span><span class="params">(<span class="type">int</span> newDamage)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    damage = newDamage;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Role.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">200</span>;</span><br><span class="line">    <span class="type">int</span>* p = &amp;a;</span><br><span class="line">    <span class="type">int</span>&amp; c = *p;</span><br><span class="line"></span><br><span class="line">    Role user;</span><br><span class="line">    Role monster;</span><br><span class="line">    user.<span class="built_in">SetLv</span>(<span class="number">100</span>).<span class="built_in">SetDamage</span>(<span class="number">50</span>).<span class="built_in">SetHp</span>(<span class="number">500</span>).<span class="built_in">bigger</span>(&amp;monster)-&gt;<span class="built_in">bigger</span>(&amp;user);</span><br><span class="line">    Role* biggerRole= user.<span class="built_in">bigger</span>(&amp;monster);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Role.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Role</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> hpRecover;</span><br><span class="line"><span class="type">int</span> hp;</span><br><span class="line"><span class="type">int</span> lv;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*如果inline函数的定义不在类内部，也不在头文件中，而是放在某个.cpp文件中，</span></span><br><span class="line"><span class="comment">编译器确实可能出现问题，因为它在链接阶段无法找到该函数的实现*/</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">GetHp</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> damage;</span><br><span class="line"><span class="function">Role* <span class="title">bigger</span><span class="params">(Role* role)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Act</span><span class="params">(Role&amp; role)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Role&amp; <span class="title">SetLv</span><span class="params">(<span class="type">int</span> newLv)</span></span>;</span><br><span class="line"><span class="function">Role&amp; <span class="title">SetHp</span><span class="params">(<span class="type">int</span> newHp)</span></span>;</span><br><span class="line"><span class="function">Role&amp; <span class="title">SetDamage</span><span class="params">(<span class="type">int</span> newDamage)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>内联函数，以Role.cpp里面的函数为准，重写原则</p><p><strong>this指针</strong></p><p><code>this</code>指针是一个指向调用成员函数的对象的指针。每当你在一个类的成员函数中使用<code>this</code>时，它自动指向当前调用该成员函数的对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">x</span>(val) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; endl;   </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;this = &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    obj.<span class="built_in">show</span>(); <span class="comment">// x = 10   this指针的值是对象的地址</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>this</strong> 指针的特点</p><p> · <code>this</code>指针是隐式传递给成员函数的。不需要显示地将它作为参数传递，它是C++编译器自动提供的。</p><p> · <code>this</code>指针是只读的。你不能修改 <code>this</code>指针本身（既不能让 <code>this</code> 指针指向其他对象），但是可以通过它访问的对象的成员。</p><p> · 对于非静态成员函数， <code>this</code> 指针总是存在的，而在静态成员函数中没有this指针，因为静态函数不依赖任何特定的对象。</p><p> · <code>this</code> 指针的类型是ClassName*， 它指向调用成员函数的对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Myclass</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Myclass</span>(<span class="type">int</span> val) : <span class="built_in">x</span>(val) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>this-&gt;x</code> 表示当前对象的成员变量x，而x则表示函数的参数。这样可以避免成员变量与函数参数名称冲突的问题。</p><p><code>this</code>  指针的使用场景</p><p>1️⃣ 区分成员变量和局部变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>2️⃣ 链式调用</p><p><code>this</code> 指针的返回值可以用于链式调用，常见于实现流式操作接口（比如std::string的操作）。返回<code>*this</code> 意味着返回当前对象的引用，从而可以链式调用多个方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="function">MyClass&amp; <span class="title">setX</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x = val;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 返回当前对象的引用，实现链式调用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    obj.<span class="built_in">setX</span>(<span class="number">20</span>).<span class="built_in">setX</span>(<span class="number">30</span>).<span class="built_in">show</span>();  <span class="comment">// 链式调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3️⃣ this 指针的特殊情况</p><p><code>this</code> 指针在静态成员函数中的不存在，静态成员函数不依赖于任何特定的对象，因此它们没有<code>this</code>指针。你不能在静态成员函数中使用<code>this</code>，因为静态成员函数是类的级别上的，而不是对象的级别上的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">staticFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 不能使用this指针，因为staticFunction 是静态成员函数</span></span><br><span class="line">        <span class="comment">// this-&gt; x = 10;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4️⃣ <code>this</code> 指针与 <code>const</code> 修饰符</p><p> · 在常量成员函数中，<code>this</code> 指针是 <code>const</code>类型的，这意味着你不能通过this指针访问的对象成员。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">x</span>(val) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//不能修改成员变量</span></span><br><span class="line">        <span class="comment">// x = 10;  // 错误： 不能在const函数中修改对象的状态</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>5️⃣ <code>this</code> 指针与<code>const</code>对象</p><p>对于常量对象，<code>this</code> 指针会被隐式地转换为<code>const</code> 类型，确保通过<code>this</code>指针访问的对象不会被修改。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printObject</span><span class="params">(<span class="type">const</span> MyClass&amp; obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; obj.x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6️⃣ <code>this</code> 指针的返回类型</p><p>由于 <code>this</code> 指针的类型是当前类的指针，所以可以将它作为返回值返回。这样通常用于链式调用或在类成员函数中传递对象的引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">x</span>(val) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">MyClass* <span class="title">getThis</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;  <span class="comment">// 返回当前对象的指针。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>this</code>指针是C++中非常重要的特性，它允许成员函数访问当前对象的成员，并且有助于在类中实现链式调用、区分参数和成员变量等功能。理解<code>this</code>指针对于深入掌握C++至关重要，特别是在对象操作和内存管理方面。</p><p><strong><code>const</code></strong></p><p><code>const</code> 在前面说明函数返回值是<code>const</code>  ，在后面说明这个函数是<code>const</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Role.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">const</span> Role user;</span><br><span class="line"></span><br><span class="line">Role monster;</span><br><span class="line"><span class="type">const</span> Role* puser&#123; &amp;user &#125;;</span><br><span class="line"><span class="comment">// puser-&gt;damage = 2;  // 常量指针不能编译</span></span><br><span class="line"><span class="comment">// puser-&gt;    这里不能调用成员函数</span></span><br><span class="line">puser-&gt;<span class="built_in">GetHp</span>();  <span class="comment">// GetHp()后面加上const 就可以定义了</span></span><br><span class="line">monster.<span class="built_in">GetHp</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Role</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> hp;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetHP</span><span class="params">()</span> <span class="type">const</span></span>;   <span class="comment">// const 成员函数内部一律不可以做任何改变的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>const</code> 对象不能以任何方式改变，这是<code>const</code> 原则，在这个原则下，<code>const</code>对象只能调用<code>const</code>成员函数。</p><p>在<code>const</code> 成员函数下，<code>this</code>指针也变成了<code>const</code>指针。</p><p>成员函数是<code>const</code>的情况下，想返回引用，只能在前面加上<code>const</code>，或者不返回引用，按值来传递。</p><p>1️⃣ 所有没有设计修改成员变量的成员函数，一律加上<code>const</code></p><p>2️⃣ 利用函数重载</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetDamage</span><span class="params">()</span> <span class="type">const</span></span>;  <span class="comment">// const 对象，调用这个函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetDamage</span><span class="params">()</span></span>;   <span class="comment">// 非const 对象，调用这个函数</span></span><br></pre></td></tr></table></figure><p><strong>const 类型转换</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(Role* p)</span>   <span class="comment">// 忘记加const了， 所以下面才进行类型转换</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p-&gt;<span class="built_in">SetHP</span>(<span class="number">5000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> Role user;</span><br><span class="line">    <span class="type">const</span> Role* puser&#123; &amp;user &#125;;</span><br><span class="line">    <span class="built_in">test</span>((Role*)(&amp;user));  <span class="comment">// C 语言的转换</span></span><br><span class="line">    <span class="built_in">test</span>(<span class="built_in">const_cast</span>&lt;Role*&gt;(&amp;user));   <span class="comment">// c++ 的转换</span></span><br><span class="line">    std::cout &lt;&lt; puser-&gt;<span class="built_in">GetHP</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>mutable 关键字</strong></p><p><code>mutable</code> 关键字是一个非常特殊的修饰符，它主要用于类的数据成员上。<code>mutable</code> 的作用是允许即使在 <code>const</code> 成员函数中，也可以修改被修饰的成员变量的值。&#96;</p><p>1️⃣ <code>const</code> 成员函数的限制，指一个声明为 <code>const</code> 的成员函数，这意味着该成员函数承诺不会修改对象的状态，即不会修改对象的非 <code>mutable</code> 成员变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">x</span>(val) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span></span>&#123;    <span class="comment">// const 成员函数</span></span><br><span class="line">        x = <span class="number">10</span>;    <span class="comment">//  错误， const 成员函数不能修改成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>show()</code> 被声明为 <code>const</code> 成员函数，它承诺不修改类的任何成员。因为 <code>x</code> 不是 <code>mutable</code> 成员变量，所以试图在 <code>const</code> 成员函数中修改 <code>x</code> 是不允许的，编译器会报错。</p><p>2️⃣  <code>mutable</code> 的作用</p><p><code>mutable</code> 关键字的出现就是为了允许某些特定成员变量在 <code>const</code> 成员函数中修改。这对实现缓存、延迟计算、记录日志等场景非常有用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">x</span>(val) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span></span>&#123;    <span class="comment">// const 成员函数</span></span><br><span class="line">        x = <span class="number">10</span>;    <span class="comment">//  允许：x 是 mutable， 可以在 const 函数中修改</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>构造函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> hp;</span><br><span class="line">    <span class="type">int</span> mp;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetMP</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> mp; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetMP</span><span class="params">(<span class="type">int</span> _lv)</span> </span>&#123; lv = _lv; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> lv;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T t1&#123; <span class="number">100</span>,<span class="number">200</span> &#125;;  <span class="comment">// 不能初始化lv</span></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">SetMP</span>(<span class="number">109</span>);  <span class="comment">// 可以设置lv</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数在类被创建的时候自动被调用，一般用来创建新的类实例时执行初始化操作，构造函数与它所在的类同名，并且没有返回值，任何类都至少有一个构造函数；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> hp;</span><br><span class="line">    <span class="built_in">T</span>()  <span class="comment">// 无参数的构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;T()\n&quot;</span>;</span><br><span class="line">        hp = <span class="number">100</span>;</span><br><span class="line">        mp = <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">T</span>(<span class="type">int</span> _hp, <span class="type">int</span> _mp,)  <span class="comment">// 有参数的构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;T(int,int)\n&quot;</span>;</span><br><span class="line">        hp = _hp;</span><br><span class="line">        mp = _mp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">T</span>(T&amp; t)   <span class="comment">//  留下疑问，为什么要加个引用</span></span><br><span class="line">    &#123;</span><br><span class="line">        hp = t.hp;</span><br><span class="line">        mp = t.<span class="built_in">GetMP</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> mp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T t1&#123;<span class="number">100</span>, <span class="number">200</span>&#125;;   <span class="comment">// 调用有参数的构造函数</span></span><br><span class="line">    <span class="function">T <span class="title">t2</span><span class="params">(t1)</span></span>;   <span class="comment">// 调用的就是T(T&amp; t)</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n.............\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; t<span class="number">1.</span>hp &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; t<span class="number">1.</span><span class="built_in">GetMP</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个类没有明显的定义一个构造函数，那么编译器会自动的添加一个默认的构造函数，这个默认的构造函数是无参数、无返回值的函数</p><p><strong><code>default</code>关键字</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Role</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="built_in">Role</span>(<span class="type">int</span> _lv = <span class="number">500</span>) &#123; lv = _lv; &#125;  <span class="comment">// 如果有默认值的话编译器不能区分出来</span></span><br></pre></td></tr></table></figure><p>不建议这么写</p><p><strong><code>explicit</code> 关键字</strong></p><p>被 <code>explicit</code> 关键字修饰的构造函数会禁用类型转换，它可以防止编译器在进行类型转换时，自动调用某些构造函数。这是为了避免隐式类型转换（隐式构造或隐式转换）导致潜在的错误或不希望发生的行为。</p><p>隐式类型转换的风险</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> x)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;----------&quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(MyClass obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;In foo&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>(<span class="number">42</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>foo(42)</code> 实际上是调用了 <code>MyClass</code> 的构造函数，并将 <code>42</code> 转换为 <code>MyClass</code> 类型对象。这种隐式转换可能是安全的，但它也可能会引入意外的行为，特别是在构造函数的逻辑较为复杂时。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;----------&quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(MyClass obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;In foo&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>(<span class="built_in">MyClass</span>(<span class="number">42</span>));  <span class="comment">// 必须显示的调用构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>深入理解构造函数</strong></p><p>使用成员初始化列表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ROLE</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> lv;</span><br><span class="line">    <span class="type">int</span> hpRecover;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        hpRecover = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//  效率更高  某些情况下只能用这种方式初始化</span></span><br><span class="line">    <span class="built_in">ROLE</span>(<span class="type">int</span> _lv, <span class="type">int</span> _damage) : lv&#123;_lv&#125;,damage&#123;_damage&#125; &#123;&#125;</span><br><span class="line">    <span class="type">int</span> hp;</span><br><span class="line">    <span class="type">int</span> damage;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Act</span><span class="params">(ROLE&amp; role)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用成员函数初始化列表这样的方式构造类，要注意一个问题，即为成员赋值的顺序不是依据代码的顺序，而是成员变量在类的出现顺序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ROLE</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> lv;</span><br><span class="line">    <span class="type">int</span> hpRecover;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ROLE</span>(<span class="type">int</span> _lv, <span class="type">int</span> _damage) : lv&#123;_lv&#125;,damage&#123;_damage&#125;,hp&#123;_lv*<span class="number">100</span>&#125;,hpRecover&#123;lv&#125; &#123;&#125;</span><br><span class="line">    <span class="type">int</span> damage;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Act</span><span class="params">(ROLE&amp; role)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">实际初始化的顺序</span></span><br><span class="line"><span class="comment">hp=lv*100</span></span><br><span class="line"><span class="comment">hpRecover = lv;</span></span><br><span class="line"><span class="comment">lv = _lv;</span></span><br><span class="line"><span class="comment">damage = _damage;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>委托构造函数</strong></p><p>它允许一个构造函数调用另一个构造函数。委托构造函数通过将其构造逻辑委托给同一类中的另一个构造函数来减少代码重复，并提高代码的可维护性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ROLE</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> lv;</span><br><span class="line">    <span class="type">int</span> hpRecover;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ROLE</span>():<span class="built_in">ROLE</span>(<span class="number">100</span>,<span class="number">200</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ROLE</span>(<span class="type">int</span> _lv, <span class="type">int</span> _damage):lv&#123;_lv&#125;,damage&#123;_damage&#125; &#123;&#125;</span><br><span class="line">    <span class="type">int</span> damage;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Act</span><span class="params">(ROLE&amp; role)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 委托构造函数初始化列表里不能初始化成员变量且只能调用一次同一个类的构造函数</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 委托构造函数：调用另一个构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>() : <span class="built_in">Person</span>(<span class="string">&quot;Unknown&quot;</span>, <span class="number">0</span>)  <span class="comment">// 委托之后，这里就不写name(name), age(age)这种了列表了</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Default constructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 另一个构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">int</span> age) : <span class="built_in">name</span>(name), <span class="built_in">age</span>(age) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Parameterized constructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;, Age: &quot;</span> &lt;&lt; age &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person p1;  <span class="comment">// 将调用默认构造函数，进而委托给带参数的构造函数</span></span><br><span class="line">    p<span class="number">1.</span><span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>)</span></span>;  <span class="comment">// 调用带参数的构造函数</span></span><br><span class="line">    p<span class="number">2.</span><span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>副本构造函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Role role1;</span><br><span class="line"><span class="function">Role <span class="title">role2</span><span class="params">(role1)</span></span>;</span><br><span class="line"><span class="comment">// 编译器为类指定了一个默认的副本构造函数，我们也可以手动指定副本构造函数。</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Role.h</span></span><br><span class="line"><span class="built_in">Role</span>(Role&amp; rl) </span><br><span class="line">&#123;</span><br><span class="line">    hp = rl.hp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line">user.<span class="built_in">setHP</span>(<span class="number">5000</span>);</span><br><span class="line"><span class="function">Role <span class="title">userA</span><span class="params">(user)</span></span>;  <span class="comment">// 使用我们自己做的构造函数，只拷贝hp的值</span></span><br></pre></td></tr></table></figure><p><code>Role(Role&amp; rl)</code>   引用问题</p><p>在 C++ 中，当你传递对象给函数或者在对象初始化时，如果参数类型不是引用（即传值方式），那么会发生<strong>副本创建</strong>，即编译器会调用副本构造函数来创建一个新的对象。传值会导致一次额外的复制操作，消耗额外的时间和资源。</p><p>使用引用类型参数（<code>Role&amp; rl</code>）可以避免这种多余的复制，直接引用原有对象。因此，副本构造函数的参数一般定义为<strong>常量引用</strong>（<code>const Role&amp; rl</code>），来避免对原对象进行修改。</p><p>如果副本构造函数的参数是按值传递，那么在调用副本构造函数时，编译器会尝试用这个值初始化一个新对象。这又会调用副本构造函数，而副本构造函数是用来构造副本的，这会导致递归调用，造成栈溢出。</p><p>通过传递引用，副本构造函数避免了重新调用自身，解决了递归调用的问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Role userA = user;  <span class="comment">// userA还没有构造，把user当成参数</span></span><br><span class="line">userA = user;   <span class="comment">// 这里就不再构造函数了</span></span><br></pre></td></tr></table></figure><p><strong>析构函数</strong></p><p>用来销毁一个类，析构函数没有参数，没有返回类型，使用default来定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">~类名()   <span class="comment">// 没参数就不能重载</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 空的析构函数</span></span><br><span class="line">~<span class="built_in">ROLE</span>() = <span class="keyword">default</span>;  </span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Role</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>* ary;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Role</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        ary = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">100</span>];</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;\n类被创建&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Role</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] ary;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;\n 类被销毁&quot;</span>;   <span class="comment">// 这样写防止内存泄露</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// std::string 就用到这种技术</span></span><br></pre></td></tr></table></figure><p><strong>实现字符串类<code>hstring</code></strong></p><p><code>std::string</code> 设计一个类 <code>hstirng</code></p><p><code>hstring str(&quot;你好！&quot;);</code>    &#x2F;&#x2F; 构造函数</p><p><code>hstring strA(str);</code>   &#x2F;&#x2F; 副本构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hstring</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span>* c_str;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> len;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">length</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> len&#123;&#125;;</span><br><span class="line"><span class="keyword">while</span> (str[len++]);</span><br><span class="line"><span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">hstring</span>()</span><br><span class="line">&#123;</span><br><span class="line">len = <span class="number">1</span>;</span><br><span class="line">c_str = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">hstring</span>(<span class="type">const</span> <span class="type">char</span>* str)</span><br><span class="line">&#123;</span><br><span class="line">len = <span class="built_in">length</span>(str) + <span class="number">1</span>;</span><br><span class="line"><span class="comment">//c_str = (char*)str;  // 指向了常量的内存空间,所以运行起来会出错</span></span><br><span class="line">c_str = <span class="keyword">new</span> <span class="type">char</span>[len];</span><br><span class="line"><span class="built_in">memcpy</span>(c_str, str, len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">Show</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> c_str;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">hstring</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">hstring <span class="title">str</span><span class="params">(<span class="string">&quot;你好！！&quot;</span>)</span></span>;</span><br><span class="line">std::cout &lt;&lt; str.<span class="built_in">Show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>私有成员变量的访问</p><p>在 C++ 中，类的私有变量（private members）只能在类的内部进行访问，不能直接从类的外部进行访问。私有成员是为了实现数据封装（Encapsulation）这一面向对象编程的基本原则，目的是隐藏类的内部实现细节，只允许通过公共接口（如公共成员函数）来访问和修改私有数据。</p><h3 id="1-如何访问类的私有成员"><a href="#1-如何访问类的私有成员" class="headerlink" title="1. 如何访问类的私有成员"></a>1. <strong>如何访问类的私有成员</strong></h3><p>C++ 提供了一些方法来访问和修改类的私有变量：</p><h4 id="1-1-通过公共成员函数访问私有成员"><a href="#1-1-通过公共成员函数访问私有成员" class="headerlink" title="1.1 通过公共成员函数访问私有成员"></a>1.1 <strong>通过公共成员函数访问私有成员</strong></h4><p>最常见的方式是通过公共成员函数（通常称为 getter 和 setter）来访问或修改私有成员。类的私有成员可以通过这些函数提供对外接口。</p><p><strong>示例代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cpp复制代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateVar;  <span class="comment">// 私有成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 公共构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">privateVar</span>(val) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getter：访问私有成员变量</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getPrivateVar</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> privateVar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Setter：修改私有成员变量</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setPrivateVar</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        privateVar = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">42</span>)</span></span>;  <span class="comment">// 创建对象并初始化私有成员</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Private Var: &quot;</span> &lt;&lt; obj.<span class="built_in">getPrivateVar</span>() &lt;&lt; endl;  <span class="comment">// 通过公共成员函数访问私有成员</span></span><br><span class="line">    obj.<span class="built_in">setPrivateVar</span>(<span class="number">100</span>);  <span class="comment">// 修改私有成员</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Private Var: &quot;</span> &lt;&lt; obj.<span class="built_in">getPrivateVar</span>() &lt;&lt; endl;  <span class="comment">// 再次访问修改后的值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，私有成员变量 <code>privateVar</code> 只能通过公共的 getter 函数 <code>getPrivateVar()</code> 和 setter 函数 <code>setPrivateVar()</code> 访问和修改。这是实现类的<strong>数据封装</strong>的一种常见方法。</p><h4 id="1-2-通过友元函数（Friend-Function）访问私有成员"><a href="#1-2-通过友元函数（Friend-Function）访问私有成员" class="headerlink" title="1.2 通过友元函数（Friend Function）访问私有成员"></a>1.2 <strong>通过友元函数（Friend Function）访问私有成员</strong></h4><p>除了通过公共成员函数外，还可以通过定义<strong>友元函数</strong>来访问私有成员。友元函数不是类的成员函数，但它可以访问类的私有成员。友元函数被声明为类的朋友，拥有对该类私有成员的访问权限。</p><p><strong>示例代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cpp复制代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateVar;  <span class="comment">// 私有成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">privateVar</span>(val) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明友元函数</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">showPrivateVar</span><span class="params">(<span class="type">const</span> MyClass&amp; obj)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 友元函数定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPrivateVar</span><span class="params">(<span class="type">const</span> MyClass&amp; obj)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Private Var: &quot;</span> &lt;&lt; obj.privateVar &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line">    <span class="built_in">showPrivateVar</span>(obj);  <span class="comment">// 通过友元函数访问私有成员</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>showPrivateVar()</code> 是 <code>MyClass</code> 类的友元函数，它可以直接访问 <code>MyClass</code> 的私有成员 <code>privateVar</code>。</p><h4 id="1-3-通过友元类（Friend-Class）访问私有成员"><a href="#1-3-通过友元类（Friend-Class）访问私有成员" class="headerlink" title="1.3 通过友元类（Friend Class）访问私有成员"></a>1.3 <strong>通过友元类（Friend Class）访问私有成员</strong></h4><p>除了友元函数，C++ 还允许整个类成为另一个类的友元类。友元类可以访问被它声明为友元的类的私有成员。</p><p><strong>示例代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cpp复制代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AnotherClass</span>;  <span class="comment">// 前向声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateVar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">privateVar</span>(val) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明 AnotherClass 为友元类</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">AnotherClass</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AnotherClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showPrivateVar</span><span class="params">(<span class="type">const</span> MyClass&amp; obj)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Private Var: &quot;</span> &lt;&lt; obj.privateVar &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line">    AnotherClass anotherObj;</span><br><span class="line">    anotherObj.<span class="built_in">showPrivateVar</span>(obj);  <span class="comment">// 通过友元类访问私有成员</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>AnotherClass</code> 是 <code>MyClass</code> 的友元类，因此 <code>AnotherClass</code> 可以直接访问 <code>MyClass</code> 的私有成员 <code>privateVar</code>。</p><h4 id="1-4-通过指针和引用访问私有成员"><a href="#1-4-通过指针和引用访问私有成员" class="headerlink" title="1.4 通过指针和引用访问私有成员"></a>1.4 <strong>通过指针和引用访问私有成员</strong></h4><p>如果有指向对象的指针或引用，并且你能通过公共接口访问私有成员，那么你就可以通过这些接口来访问私有成员。值得注意的是，直接通过指针或引用访问私有成员是不可行的，除非使用 <code>friend</code> 函数或者 <code>getter</code> 和 <code>setter</code>。</p><p><strong>示例代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cpp复制代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateVar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">privateVar</span>(val) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getter</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getPrivateVar</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> privateVar;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line">    MyClass* ptr = &amp;obj;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Private Var via pointer: &quot;</span> &lt;&lt; ptr-&gt;<span class="built_in">getPrivateVar</span>() &lt;&lt; endl;  <span class="comment">// 通过指针访问</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-总结"><a href="#2-总结" class="headerlink" title="2. 总结"></a>2. <strong>总结</strong></h3><ul><li><strong>私有成员变量</strong>（private members）是 C++ 中类的一部分，只能在类内部访问，不允许外部直接访问。</li><li><strong>公共成员函数</strong>（getter&#x2F;setter）通常是访问私有成员的推荐方式。通过提供控制访问的接口，可以保护数据的安全性和一致性。</li><li><strong>友元函数</strong>和<strong>友元类</strong>允许外部的函数或类访问该类的私有成员，但这种方式通常会打破封装性，因此应该谨慎使用。</li><li>在实际应用中，通常建议将类的成员变量设为私有，并通过公共接口（getter、setter）进行访问和修改，以确保数据的有效性和安全性。</li></ul><p>总之，访问类的私有变量应该遵循<strong>封装性</strong>的原则，避免直接在外部访问类的私有数据，而是通过设计好的接口来进行操作</p><p>在 C++ 中，<code>=</code> 运算符用于赋值操作，但是在不同的上下文中，<code>=</code> 运算符的含义和行为是不同的。你提到的两种情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cpp复制代码</span></span><br><span class="line">Role userA = user; <span class="comment">// 这种形式是复制初始化</span></span><br><span class="line">userA = user;       <span class="comment">// 这种形式是赋值操作</span></span><br></pre></td></tr></table></figure><p>这两者之间有很大的区别，我们将逐一分析它们的含义和不同之处。</p><h3 id="1-Role-userA-user-——-复制初始化（Copy-Initialization）"><a href="#1-Role-userA-user-——-复制初始化（Copy-Initialization）" class="headerlink" title="1. Role userA = user; —— 复制初始化（Copy Initialization）"></a>1. <code>Role userA = user;</code> —— <strong>复制初始化</strong>（Copy Initialization）</h3><p>这行代码属于<strong>复制初始化</strong>（Copy Initialization），它通常会调用<strong>副本构造函数</strong>。它的执行过程如下：</p><ul><li><strong>首先创建一个新对象 <code>userA</code></strong>，并用 <code>user</code> 对象初始化它。</li><li>在这个过程中，<strong>副本构造函数</strong>会被调用，通常情况下是 <code>Role(const Role&amp; user)</code>。</li></ul><p>也就是说，<code>Role userA = user;</code> 实际上是通过调用类的副本构造函数来构造 <code>userA</code> 对象的副本。这种赋值形式会复制 <code>user</code> 对象的状态到 <code>userA</code>。</p><h3 id="副本构造函数的工作流程："><a href="#副本构造函数的工作流程：" class="headerlink" title="副本构造函数的工作流程："></a>副本构造函数的工作流程：</h3><ul><li>调用副本构造函数创建 <code>userA</code>。</li><li>将 <code>user</code> 对象的成员变量的值复制给 <code>userA</code>。</li><li>这通常会涉及成员的深拷贝（如果类中有动态分配内存等需要处理的资源）。</li></ul><h3 id="2-userA-user-——-赋值操作（Assignment）"><a href="#2-userA-user-——-赋值操作（Assignment）" class="headerlink" title="2. userA = user; —— 赋值操作（Assignment）"></a>2. <code>userA = user;</code> —— <strong>赋值操作</strong>（Assignment）</h3><p>这行代码属于<strong>赋值操作</strong>（Assignment），它会调用对象的<strong>赋值运算符</strong>。赋值运算符用于将一个已有对象的状态赋值给另一个对象。执行过程如下：</p><ul><li>这里 <code>userA</code> 是已经存在的对象，而 <code>user</code> 是另一个对象。</li><li><code>userA = user;</code> 会调用类的赋值运算符，通常是 <code>Role&amp; operator=(const Role&amp; user)</code>，该运算符用于将 <code>user</code> 对象的状态复制到 <code>userA</code> 中。</li></ul><h3 id="赋值运算符的工作流程："><a href="#赋值运算符的工作流程：" class="headerlink" title="赋值运算符的工作流程："></a>赋值运算符的工作流程：</h3><ul><li>如果类的赋值运算符已定义，<code>operator=</code> 会被调用。</li><li>它会将 <code>user</code> 对象中的数据成员赋值给 <code>userA</code>，并可能涉及内存管理（例如，释放已有资源、分配新资源等）。</li><li>如果没有定义自定义的赋值运算符，编译器会提供一个默认的赋值运算符，该默认版本执行逐个成员的赋值操作。</li></ul><h3 id="关键区别"><a href="#关键区别" class="headerlink" title="关键区别"></a>关键区别</h3><ol><li><strong>操作对象不同：</strong><ul><li><code>Role userA = user;</code> 是创建一个新的对象 <code>userA</code> 并初始化它，这个过程调用的是副本构造函数。</li><li><code>userA = user;</code> 是将已经存在的对象 <code>userA</code> 赋值为 <code>user</code>，这个过程调用的是赋值运算符。</li></ul></li><li><strong>调用的函数不同：</strong><ul><li><code>Role userA = user;</code> 调用的是类的<strong>副本构造函数</strong>，它在创建新对象时用于初始化。</li><li><code>userA = user;</code> 调用的是类的<strong>赋值运算符</strong>，它用于将一个已存在对象的值复制到另一个已存在对象。</li></ul></li><li><strong>创建新对象与赋值对象：</strong><ul><li>在 <code>Role userA = user;</code> 中，<code>userA</code> 是通过副本构造函数创建的一个新对象。</li><li>在 <code>userA = user;</code> 中，<code>userA</code> 已经存在，它的内容会被替换为 <code>user</code> 的内容。</li></ul></li><li><strong>效率考虑：</strong><ul><li>副本构造函数通常用于创建新对象，因此它需要分配内存并初始化对象。</li><li>赋值运算符通常在对象已经存在的情况下执行，它会处理已有对象的资源，可能会包括释放资源、重新分配内存等操作。</li></ul></li></ol><h3 id="深入理解赋值运算符与副本构造函数"><a href="#深入理解赋值运算符与副本构造函数" class="headerlink" title="深入理解赋值运算符与副本构造函数"></a>深入理解赋值运算符与副本构造函数</h3><p>为了进一步理解它们的行为，我们可以看一下副本构造函数和赋值运算符的实现。</p><h4 id="副本构造函数"><a href="#副本构造函数" class="headerlink" title="副本构造函数"></a>副本构造函数</h4><p>副本构造函数的目标是创建一个新对象，它接受一个对象作为参数，并用该对象的内容初始化新对象。典型的副本构造函数实现如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cpp复制代码class Role &#123;</span><br><span class="line">public:</span><br><span class="line">    Role(const Role&amp; other) &#123;</span><br><span class="line">        // 通过 other 来初始化当前对象</span><br><span class="line">        this-&gt;name = other.name;  // 假设是简单的成员复制</span><br><span class="line">        this-&gt;age = other.age;</span><br><span class="line">        // 如果有动态内存分配，需要深拷贝</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><p>赋值运算符用于将一个已存在的对象的状态赋值给另一个已存在的对象。典型的赋值运算符实现如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cpp复制代码class Role &#123;</span><br><span class="line">public:</span><br><span class="line">    Role&amp; operator=(const Role&amp; other) &#123;</span><br><span class="line">        if (this != &amp;other) &#123;  // 防止自我赋值</span><br><span class="line">            this-&gt;name = other.name;</span><br><span class="line">            this-&gt;age = other.age;</span><br><span class="line">            // 如果有动态内存分配，确保释放旧的资源并分配新资源</span><br><span class="line">        &#125;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><code>Role userA = user;</code> 使用的是<strong>副本构造函数</strong>，其作用是创建一个新的对象 <code>userA</code> 并用 <code>user</code> 初始化它。</li><li><code>userA = user;</code> 使用的是<strong>赋值运算符</strong>，其作用是将已有对象 <code>user</code> 的内容赋值给已有对象 <code>userA</code>。</li></ul><p>两者的主要区别在于：副本构造函数负责新对象的创建并进行初始化，而赋值运算符负责已有对象的内容赋值。因此，它们各自有不同的性能和功能特点，适用于不同的情境。</p>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cpp06不同语言联合编程</title>
      <link href="/2024/12/11/cpp06%E4%B8%8D%E5%90%8C%E8%AF%AD%E8%A8%80%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/"/>
      <url>/2024/12/11/cpp06%E4%B8%8D%E5%90%8C%E8%AF%AD%E8%A8%80%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>​                                                              <strong>此章节干货较少，笔记也比较混乱，理解为主</strong></p><p><strong>static 和 inline</strong></p><p>静态变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ave</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count;    <span class="comment">// 初始化为0   生命周期跟全局变量一样（局部变量）  （不会放在栈上面）</span></span><br><span class="line">    std::cout &lt;&lt; count ++ &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 静态变量（无论是局部的还是全局的）通常被存储在 数据段（data segment）中，而不是栈或堆中。静态变量的内存分配在程序启动时就已完成，并且在整个程序运行期间都保持有效，直到程序退出。</span></span><br></pre></td></tr></table></figure><p>内联函数</p><p><strong>内联函数</strong>（Inline Function）是 C++ 中的一种函数优化技术，它的作用是让编译器将函数的代码直接嵌入到调用该函数的地方，而不是通过函数调用的机制进行跳转。这种优化有助于减少函数调用的开销（尤其是对于短小的函数），从而提高程序的执行效率。</p><p>递归函数不能用，本身就需要栈空间。</p><p>可以用一个inline声明一个内联函数   内联函数会建议编译器把这个函数处理成内联代码以提升性能</p><p>始终是建议，具体编译器是否采纳，由编译器决定。。。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span> + <span class="number">2</span>;   <span class="comment">// 加上inline之后，直接 把相应的代码放在这里了  不调用函数了   直接a + b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>从编译器的角度理解定义和声明</strong></p><p>函数声明（也称为函数原型）是告诉编译器函数的名称、返回类型和参数类型的声明，但不包含函数体。它主要用于在调用函数之前告诉编译器函数的存在及其接口。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ave</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;  <span class="comment">//  </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c = <span class="built_in">ave</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ave</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数定义是函数的实际实现，包含了函数的返回类型、参数以及函数体。函数定义包括了函数的逻辑实现，并且会占用内存资源。</p><ul><li><strong>函数声明</strong>只提供函数的接口信息，不包含实现，通常用于让编译器在调用函数之前知道函数的存在。</li><li><strong>函数定义</strong>提供了函数的完整实现，包含了函数的所有细节。</li></ul><p><strong>变量和函数的不同（声明  定义）</strong></p><p><code>extern int x;</code>  &#x2F;&#x2F; 声明变量 x     声明，默认是extern</p><p><code>extern</code> 关键字用于声明变量而不定义它。这样可以在多个文件之间共享变量。例如，当你需要在多个源文件中使用同一个全局变量时，可以使用 <code>extern</code> 来声明该变量。</p><p>x86  32位windows操作系统下内存分配</p><p><strong>头文件和源文件</strong></p><p>头文件用于声明类、函数、变量、常量等信息，但不包含具体的实现</p><p>头文件只有在调用的时候才被编译，主要是用来写声明的，也可以写定义。</p><p>函数只要是在一个工程里就不能重复定义（重载除外）</p><p>情况 1️⃣ 静态函数，只在所在的cpp文件中有效，加上 <code>static</code> 关键字，那么不同的cpp文件中的静态函数都有各自的空间，如果不加，那么整个工程里面的相同函数名的函数都用的同一块空间。</p><p>情况 2️⃣ 内联函数  也是一样的</p><p>如果是变量的话，要用 <code>extern</code> 关键字，只声明不定义，那写在头文件里没问题。</p><p>静态变量也是在各自的源文件里有效。<code>static</code>关键字</p><p>重复调用的情况不会出现问题，原因是 <code>#pragma once</code>  但有的编译器不支持这个命令了 </p><p><strong>头文件保护机制</strong>（Include Guard）。头文件保护机制的目的是防止头文件被多次包含，避免重复定义和潜在的编译错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _HEMATH_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _HEMATH_</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><ol><li><strong><code>#ifndef _HEMATH_</code></strong>：<ul><li><code>#ifndef</code> 是 “if not defined” 的缩写，意思是“如果未定义”。</li><li>它检查是否已定义名为 <code>_HEMATH_</code> 的宏。如果没有定义，那么接下来的代码会被编译；如果已经定义，则跳过。</li><li>这个宏通常是头文件的唯一标识符，用来确保头文件只被包含一次。</li></ul></li><li><strong><code>#define _HEMATH_</code></strong>：<ul><li><code>#define</code> 用于定义宏 <code>_HEMATH_</code>。一旦定义了这个宏，后续的 <code>#ifndef</code> 就会失败，避免重复包含该头文件。</li><li>宏 <code>_HEMATH_</code> 在第一次包含该头文件时定义，以后任何包含此头文件的地方都会跳过其中的内容。</li></ul></li><li><strong><code>#endif</code></strong>：<ul><li>这是 <code>#ifndef</code> 的结束标志，表示条件编译的结束。它标志着条件保护代码块的结束。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：`hemath.h`</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _HEMATH_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _HEMATH_</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">subtract</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在源文件中使用</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hemath.h&quot;</span> <span class="comment">// 第一次包含，宏 _HEMATH_ 没有定义，会进入条件编译区块</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hemath.h&quot;</span> <span class="comment">// 第二次包含，宏 _HEMATH_ 已定义，直接跳过头文件内容</span></span></span><br></pre></td></tr></table></figure><p>这样，第二次 <code>#include</code> 时，头文件的内容就不会被重新包含，从而避了重复定义的问题。</p><ul><li>宏名字（<code>_HEMATH_</code>）可以自定义，但最好使用独特且具有全局唯一性的名字，通常使用项目名或文件名来避免与其他库的宏冲突。</li><li>另外，也可以考虑使用 <code>#pragma once</code> 来替代传统的 <code>#ifndef</code> 方式，这样做更简洁，并且现代编译器通常会优化它。</li></ul><p>C语言不支持函数重载，所以有多个源文件包含相同的函数，C语言把函数名加_  但是C++有函数重载不能这样处理，.c 文件和 .cpp 文件若有相同的函数，也不会出错，因为编译器处理之后 的名字不一样</p><p>1️⃣ 定义在C语言里面的函数，不能在C++中直接访问 （<strong>要使用extern关键字才行</strong>）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">int</span> <span class="title">ave</span><span class="params">()</span></span>;  <span class="comment">// 加上这个就能在cpp文件里面运行c中的函数了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法1️⃣</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ave</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pve</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法2️⃣   直接把头文件 用extern &quot;C&quot;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;e.h&quot;</span>  <span class="comment">// 头文件里面的全是C的风格</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这种手段，C++可以调用C语言代码</p><p>2️⃣<strong>在C语言中调用C++的函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">int</span> <span class="title">xve</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 把C++ 中的函数定义成C风格即可</span></span><br></pre></td></tr></table></figure><p>为了让C语言文件知道C++中定义的函数，在C++的头文件中使用 <code>extern &quot;C&quot;</code> 来声明这些函数。这样，C语言和C++都可以包含这个头文件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example.h (C++头文件)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;  <span class="comment">// 声明C++中的add函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>3️⃣ 在C语言代码中，使用extern “C” 声明该函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example.c (C文件)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;  <span class="comment">// 声明C++中的add函数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> result = add(<span class="number">2</span>, <span class="number">3</span>);  <span class="comment">// 调用C++中的函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Result: %d\n&quot;</span>, result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>C 和 c++ 源文件混用的问题</strong></p><p>如果.c 文件 和 .cpp 文件重名（都叫a），那编译的时候，会有俩a.obj，一个文件下目录下有俩a.obj  那么就会出问题，尽量不要让C++和C文件重名</p><p><strong>创建自己的SDK</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;edoyun.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法一  配好包含目录和库目录之后，写下面的指令即可</span></span><br><span class="line"><span class="comment">//#pragma comment(lib,&quot;edoyun.lib&quot;)</span></span><br><span class="line"><span class="comment">// 方法二  链接器-&gt;输入-&gt;附加依赖项</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; edoyun::<span class="built_in">GetVersion</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">ave</span>(<span class="number">100</span>,<span class="number">300</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/11/28/67480783670e4.png"></p><p><strong>函数调用约定</strong></p><p>函数调用约定是函数调用与被调用者之间的一种协议，这个协议主要规定了以下两个内容：</p><p>如何传递参数    如何恢复栈平衡</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> __cdecl <span class="title">ave</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ave</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// __cdecl 参数入栈顺序 从右到左</span></span><br><span class="line"><span class="comment">// 堆栈平衡：谁调用谁平衡</span></span><br><span class="line"><span class="comment">// 正因为__cdecl这种堆栈平衡方式，能够支持不定量参数</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> __stdccall <span class="title">ave</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ave</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// __stdcall 参数入栈顺序  从右到左</span></span><br><span class="line"><span class="comment">// 堆栈平衡：函数自己恢复栈平衡</span></span><br><span class="line"><span class="comment">// Windows 编程中 WINAPI CALLBACK 都是 __stdcall 的宏</span></span><br><span class="line"><span class="comment">// 生成的函数名会加下划线，后面跟@和参数尺寸</span></span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/11/28/674823c0b7270.png"></p><p><img src="https://bu.dusays.com/2024/11/28/674823ba10bfe.png"></p><p><strong>递归函数</strong></p><p><strong>递归函数</strong>是指在函数的定义中，调用了它自身的函数。递归的核心思想是将复杂的问题分解为更简单的同类问题。通过递归，问题可以被拆解成较小的子问题，直到达到最简单的基本情况（即递归的终止条件）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ave</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> x * <span class="built_in">ave</span>(x - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Role</span></span><br><span class="line">&#123;</span><br><span class="line">string Id;</span><br><span class="line"><span class="type">int</span> Exp;</span><br><span class="line">&#125;*PROLE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetDataCount</span><span class="params">(string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> icount&#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">length</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (str[i] == <span class="string">&#x27;;&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">icount++;</span><br><span class="line">i += <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> icount / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetStringData</span><span class="params">(PROLE prole, string&amp; strData, <span class="type">int</span> istart)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">istart = strData.<span class="built_in">find</span>(<span class="string">&quot;id=&quot;</span>, istart);</span><br><span class="line"><span class="keyword">if</span> (istart == std::string::npos) <span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> iend = strData.<span class="built_in">find</span>(<span class="string">&quot;;&quot;</span>, istart + <span class="number">3</span>);</span><br><span class="line">prole-&gt;Id = strData.<span class="built_in">substr</span>(istart + <span class="number">3</span>, iend - istart - <span class="number">3</span>);</span><br><span class="line">istart = iend + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">istart = strData.<span class="built_in">find</span>(<span class="string">&quot;exp=&quot;</span>, istart);</span><br><span class="line">iend = strData.<span class="built_in">find</span>(<span class="string">&quot;;&quot;</span>, istart + <span class="number">4</span>);</span><br><span class="line">prole-&gt;Exp = std::<span class="built_in">stoi</span>(strData.<span class="built_in">substr</span>(istart + <span class="number">4</span>, iend - istart - <span class="number">4</span>));</span><br><span class="line">istart = iend + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">GetStringData</span>(++prole, strData, istart);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string strData = <span class="string">&quot;id=Tomy Clare;exp=9523;id=Sunny;exp=9523;id=DyBaby;exp=25301;id=Simple;exp=25301;id=Bkacs11;exp=2100;id=DumpX;exp=36520;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> icount&#123; <span class="built_in">GetDataCount</span>(strData) &#125;;</span><br><span class="line">PROLE pRole = <span class="keyword">new</span> Role[icount];</span><br><span class="line"><span class="built_in">GetStringData</span>(pRole, strData, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; icount; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">1</span>; y &lt; icount; y++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pRole[y].Exp &gt; pRole[y - <span class="number">1</span>].Exp)</span><br><span class="line">&#123;</span><br><span class="line">Role tmp = pRole[y - <span class="number">1</span>];</span><br><span class="line">pRole[y - <span class="number">1</span>] = pRole[y];</span><br><span class="line">pRole[y] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; icount; i++)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; pRole[i].Id &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; pRole[i].Exp &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译器</strong></p><p><img src="https://bu.dusays.com/2024/11/28/674823b859eb4.png"></p><p>1️⃣ 未定义行为</p><p>C++标准未作规定的行为，称为未定义行为，未定义行为的结果是不确定的，具体在不同的编译器下会有不同的效果；</p><p><code>c=2*a++ + ++a*6;</code></p><p>这里先算<code>a++</code> 还是先算 <code>++ a</code> 就是一个未定义行为</p><p><code>int x = -25602;</code>   <code>x=x&gt;&gt;2;</code>  x的结果在不同编译器下是不确定的，这也属于未定义行为。</p><p>​<strong>One Definition Rule</strong></p><p>ODR是一系列规则，而不是一个规则，程序中定义的每个对象都对应着自己的规则；</p><p>但是基本上来讲，任何变量、函数、类、枚举、模板，概念在每个转换单元中都只允许有一个定义；非inline的函数或者变量，在程序中，有且只有一个定义</p><p>仅在自己的转换单元有效：</p><p>1️⃣ <code>const</code>类型的变量 ：<strong>全局const变量</strong>，没有特别声明，只在当前转换单元内可见。<strong>静态const变量</strong>，在类或函数中的作用域内有效，不会暴露到其他地方。<strong>外部const变量</strong>，使用<code>extern</code>关键字使得变量拥有外部链接属性。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;  <span class="comment">// 只在当前源文件有效</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> b;  <span class="comment">// 在其他文件中也可以引用，但变量定义只能在一个文件中</span></span><br></pre></td></tr></table></figure><p>2️⃣ <code>static</code> 类型的变量 ：<strong>全局static变量</strong>  仅在定义它的源文件内有效，不能被其他源文件访问。<strong>局部static变量</strong> 只在函数内有效，但它们的生命周期持续整个程序运行周期，只有在第一次调用时初始化，之后的调用将保留上一次修改的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> global_var = <span class="number">10</span>;  <span class="comment">// 只能在当前源文件有效</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> local_static = <span class="number">0</span>;  <span class="comment">// 只在该函数调用中有效，但其生命周期持续整个程序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 3️⃣ <code>inline</code> 变量：在当前转换单元内生效，但是可以跨多个转换单元共享。<code>inline</code>变量的作用类似于常量，允许在多个源文件中定义和使用，而不发生重复定义链接错误。</p><p><code>inline</code>变量通常用在头文件中定义常量或其他需要跨多个文件共享的变量。<code>inline</code>变量遵循一翻译单元一实例的规则，保证多个源文件中不会出现重复定义的问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// header.h</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> a = <span class="number">1350</span>;  <span class="comment">// 内联变量，多个翻译单元可以共享这个变量。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// cpp文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;header.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a = <span class="number">2000</span>;   <span class="comment">// 修改inline 变量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：仅在当前翻译单元生效的：<code>static</code> 和 默认的 <code>const</code> 变量。  可以跨多个翻译单元共享：<code>inline</code> 变量。</p><p>名称的链接属性：</p><p>1️⃣ 内部链接属性：该名称仅在本转换单元中有效。</p><p>2️⃣ 外部链接属性：该名称在其他的转换单元中也有效。</p><p>3️⃣ 无链接属性： 该名称仅仅能够用于该名称的作用域内访问。</p>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cpp05函数和栈</title>
      <link href="/2024/12/11/cpp05%E5%87%BD%E6%95%B0%E5%92%8C%E6%A0%88/"/>
      <url>/2024/12/11/cpp05%E5%87%BD%E6%95%B0%E5%92%8C%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<p>栈的本质是一段提前分配好的内存空间，主要就是用来存放临时变量！只需要管理好栈的读写就可以避免频繁的内存分配和不必要的内存浪费！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Ave</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a = a + <span class="number">250</span>;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">250</span>;</span><br><span class="line">    <span class="type">int</span> d = <span class="built_in">Ave</span>(a, b);</span><br><span class="line">    c = c + d;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; Add;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="type">int</span> x = <span class="built_in">Add</span>(<span class="number">250</span>, <span class="number">50</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CPU 的寄存器：</p><p><code>return</code>  的值 一般使用 eax 来传递</p><p><img src="https://bu.dusays.com/2024/11/27/6747130a5ebff.png"></p><p><img src="https://bu.dusays.com/2024/11/27/674713b137197.png"></p>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cpp04函数进阶</title>
      <link href="/2024/12/11/cpp04%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/"/>
      <url>/2024/12/11/cpp04%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="函数返回-返回指针和引用"><a href="#函数返回-返回指针和引用" class="headerlink" title="函数返回-返回指针和引用"></a>函数返回-返回指针和引用</h3><h4 id="返回指针不要返回局部变量"><a href="#返回指针不要返回局部变量" class="headerlink" title="返回指针不要返回局部变量"></a>返回指针不要返回局部变量</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">clen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; str[i]; i ++ )</span><br><span class="line">    <span class="keyword">return</span> ++i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">cstr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">clen</span>(str);</span><br><span class="line">   <span class="comment">// char strRt[0x20];   // 这就是错误示范，返回了一个局部变量</span></span><br><span class="line">    <span class="comment">// 只要不释放，一直在堆上面</span></span><br><span class="line">    <span class="type">char</span>* strRt = <span class="keyword">new</span> <span class="type">char</span>[len];</span><br><span class="line">    <span class="built_in">memcpy</span>(strRt, str, len);</span><br><span class="line">    <span class="keyword">return</span> strRt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>项目设计</strong></p><p><img src="https://bu.dusays.com/2024/11/24/6742aa525f2f5.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Role</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span>* name;</span><br><span class="line"><span class="type">int</span> Hp;</span><br><span class="line"><span class="type">int</span> maxHp;</span><br><span class="line"><span class="type">int</span> Mp;</span><br><span class="line"><span class="type">int</span> maxMp;</span><br><span class="line"><span class="type">int</span> lv;</span><br><span class="line">&#125;*PROLE, ROLE;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">clen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; str[i]; i++);</span><br><span class="line"><span class="keyword">return</span> ++i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">cstr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 不要返回一个局部变量</span></span><br><span class="line"><span class="type">int</span> len = <span class="built_in">clen</span>(str);</span><br><span class="line"><span class="comment">// 只要不释放，一直在堆上面</span></span><br><span class="line"><span class="type">char</span>* strRt = <span class="keyword">new</span> <span class="type">char</span>[len];</span><br><span class="line"><span class="built_in">memcpy</span>(strRt, str, len);</span><br><span class="line"><span class="keyword">return</span> strRt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ROLE <span class="title">CreateMonster</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str, <span class="type">int</span> Hp, <span class="type">int</span> Mp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 申请了空间，把它返回之后，还得赋值到 role上面，造成了性能损失</span></span><br><span class="line">Role rt&#123; <span class="built_in">cstr</span>(str), Hp, Hp, Mp, Mp, <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span>* str;</span><br><span class="line">str = <span class="built_in">cstr</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">std::cout &lt;&lt; str;</span><br><span class="line"></span><br><span class="line">ROLE role = <span class="built_in">CreateMonster</span>(<span class="string">&quot;aoteman&quot;</span>, <span class="number">1500</span>, <span class="number">1500</span>);</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; role.name &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; role.Hp &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------------改进方法1️⃣  返回指针--------------------*/</span></span><br><span class="line"><span class="function">PROLE <span class="title">CreateMonster</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str, <span class="type">int</span> Hp, <span class="type">int</span> Mp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这下返回的是4字节的指针</span></span><br><span class="line">PROLE rt = <span class="keyword">new</span> ROLE&#123; <span class="built_in">cstr</span>(str), Hp, Hp, Mp, Mp, <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span>* str;</span><br><span class="line">str = <span class="built_in">cstr</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">std::cout &lt;&lt; str;</span><br><span class="line"></span><br><span class="line">PROLE role = <span class="built_in">CreateMonster</span>(<span class="string">&quot;aoteman&quot;</span>, <span class="number">1500</span>, <span class="number">1500</span>);</span><br><span class="line">    <span class="comment">// 这样的话性能折损几乎没有了</span></span><br><span class="line">std::cout &lt;&lt; role-&gt;name &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; role-&gt;Hp &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------------改进方法2️⃣  返回引用--------------------*/</span></span><br><span class="line"><span class="function">ROLE&amp; <span class="title">CreateMonster</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str, <span class="type">int</span> Hp, <span class="type">int</span> Mp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">PROLE rt = <span class="keyword">new</span>&#123; <span class="built_in">cstr</span>(str), Hp, Hp, Mp, Mp, <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="comment">// 由于是引用，所以不能传空指针</span></span><br><span class="line"><span class="keyword">return</span> *rt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span>* str;</span><br><span class="line">str = <span class="built_in">cstr</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">std::cout &lt;&lt; str;</span><br><span class="line"></span><br><span class="line">ROLE&amp; role = <span class="built_in">CreateMonster</span>(<span class="string">&quot;aoteman&quot;</span>, <span class="number">1500</span>, <span class="number">1500</span>);</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; role.name &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; role.Hp &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数组的引用（补充）"><a href="#数组的引用（补充）" class="headerlink" title="数组的引用（补充）"></a>数组的引用（补充）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span>&amp; b = a;</span><br><span class="line"><span class="type">int</span> c[<span class="number">100</span>];</span><br><span class="line"><span class="comment">// int&amp; d[100] = c;  error</span></span><br><span class="line"><span class="built_in">int</span> (&amp;e)[<span class="number">100</span>] = a;  <span class="comment">// 必须为100 才行   而且得告诉编译器，e是个引用</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ave</span><span class="params">(<span class="type">int</span>(&amp;art)[<span class="number">100</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span>(art) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : art);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">100</span>];</span><br><span class="line">    <span class="type">int</span> c[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">int</span> (&amp;b)[<span class="number">100</span>] = c;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">ave</span>(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add1</span><span class="params">(<span class="type">int</span>&amp;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add2</span><span class="params">(<span class="type">int</span>&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">320</span> + <span class="number">250</span>;</span><br><span class="line">    <span class="type">int</span>&amp; d = c;</span><br><span class="line">    <span class="comment">// 右值引用 &amp;&amp;</span></span><br><span class="line">    <span class="comment">// int&amp;&amp; e = d;  右值引用你就不能指向内存中有位置的对象，</span></span><br><span class="line">    <span class="type">int</span>&amp;&amp; e = <span class="number">320</span>;   <span class="comment">// 右值引用可以指向临时的东西</span></span><br><span class="line">    </span><br><span class="line">    e = <span class="number">1500</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> x = c + <span class="number">100</span> + <span class="number">200</span>;</span><br><span class="line">    <span class="built_in">Add2</span>(x);</span><br><span class="line">    <span class="comment">// 使用右值引用，减少不必要的内存浪费</span></span><br><span class="line">    <span class="built_in">Add1</span>(c + <span class="number">100</span> + <span class="number">200</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Role <span class="title">CrateMonster</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Role rt&#123;<span class="number">100</span>,<span class="number">200</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(Role&amp;&amp; r1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; r<span class="number">1.</span>hp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Show</span>(<span class="built_in">CreateMonster</span>());</span><br><span class="line">    <span class="comment">// 原来的方法是创建一个额外的变量来保存</span></span><br><span class="line">    <span class="comment">// ROLE role = CreateMonster(&quot;aoteman&quot;, 1500, 1500);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/11/24/6742beef8067c.png"></p><p>右边的部分，<code>Role r1</code> 是需要创建变量的，有内存开销。  <code>Role&amp; r1</code>无法传递局部变量（临时量）。</p><p>左边部分，虽然Role CreateRole()分配到栈里，但跑到下一个函数，这部分内容要擦除的。</p><h4 id="函数的本质（底层）"><a href="#函数的本质（底层）" class="headerlink" title="函数的本质（底层）"></a>函数的本质（底层）</h4><p><img src="https://bu.dusays.com/2024/11/24/6742c2f421215.png"> push  有个作用  传参的    ，把参数推到栈区</p><p><img src="https://bu.dusays.com/2024/11/24/6742c5e9d7b54.png"></p><p>函数的名字就是一个内存地址  代码就是二进制数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; Add;  <span class="comment">//函数的名字就是一个内存地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span>* str = (<span class="type">char</span>*)Add;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%02X\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">char</span>)str[i]);</span><br><span class="line">        <span class="comment">// 打印出来的内容就是命令对应的二进制</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 测试下能不能写入</span></span><br><span class="line">    <span class="comment">// str[0] = 25; 出错  常量一样，，不让写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h4><p>函数返回类型  (*函数指针变量名)(参数类型  参数名称, …  参数类型  参数名称);</p><p><code>int (*pAdd)(int a, int b)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新用法</span></span><br><span class="line"><span class="comment">// 声明一个函数指针类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">char</span><span class="params">(*pfAdd)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">using</span> pFAdd = <span class="built_in">char</span> (*)(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">AddX</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 类型转换  上面声明的 两个类型</span></span><br><span class="line">    pfAdd pAdd1 = (pfAdd)Add1;</span><br><span class="line">    pFAdd pAdd2 = (pFAdd)AddX;</span><br><span class="line">    <span class="comment">// 类型不一样的时候使用强制类型转换</span></span><br><span class="line">    <span class="comment">// 声明函数指针</span></span><br><span class="line">    <span class="built_in">int</span> (*pxAdd)(<span class="type">int</span>, <span class="type">int</span>) = AddX;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">pxAdd</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span>(pAdd1) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">pAdd1</span>(<span class="number">30</span>, <span class="number">35</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tips</p><p><img src="https://bu.dusays.com/2024/11/24/6742d6cc78d8f.png"></p><h4 id="从函数的角度彻底认识栈"><a href="#从函数的角度彻底认识栈" class="headerlink" title="从函数的角度彻底认识栈"></a>从函数的角度彻底认识栈</h4><p>栈十分重要，底层很重要</p><p>1️⃣ 栈是预先分配好的，连续的内存空间，局部变量就放在栈空间上，通过控制esp来实现局部变量的创建和释放</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">250</span>;</span><br><span class="line">    <span class="type">int</span> d = <span class="built_in">Ave</span>(a, b);</span><br><span class="line">    c = c + d;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2️⃣ 栈平衡如果被破坏，函数就可能不能返回到预期的位置，同理，利用这个原理，我们也可以控制目标程序进入指定的位置，来获取目标操作系统的控制权限，这也就是栈攻击的技术原理，同时编写代码时也要积极预防栈攻击。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00</span>C61073 <span class="number">6</span>A <span class="number">32</span>             push   <span class="number">32</span>h</span><br><span class="line"><span class="number">00</span>C61075 <span class="number">68</span> FA <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    push   <span class="number">0</span>FAh</span><br><span class="line"><span class="number">00</span>C6107A E8 A1 FF FF FF    call   <span class="number">00</span>C61020</span><br><span class="line"><span class="number">00</span>C6107F <span class="number">83</span> C4 <span class="number">0</span>8          add    esp,<span class="number">8</span></span><br><span class="line"><span class="number">00</span>C61082 <span class="number">89</span> <span class="number">45</span> FC          mov    dword ptr [ebp<span class="number">-4</span>],eax</span><br></pre></td></tr></table></figure><p>3️⃣ 当我们逆向的时候，可以通过函数头部的sub esp, x来判断这个函数有多少局部变量</p><p>4️⃣ 关于CPU寄存器的说明</p><p>​eax： 函数的执行结果会通过eax来传递</p><p>​esp： 栈顶，栈顶以下的值代表着是可以访问的局部变量。</p><p>​ebp： 栈底</p><p>​eip：  CPU执行的位置</p><h4 id="函数重载（C-内容）"><a href="#函数重载（C-内容）" class="headerlink" title="函数重载（C++内容）"></a>函数重载（C++内容）</h4><p>函数重载（Function Overloading）是编程中一种允许在同一个作用域中定义多个同名函数的技术。这些函数根据其参数的个数或类型的不同，能够执行不同的操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ave</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ave</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这种是不可以的，int* a 和  int a[]其实是一样的 </span></span><br><span class="line"><span class="comment">// 函数重载使用时不能出现歧义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ave</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ave</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>, b = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">ave</span>(a, b);  <span class="comment">// 这种就是不行，出现歧义了  上面两个函数都适用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ave</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">ave</span><span class="params">(<span class="type">float</span> a, <span class="type">float</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> a = <span class="number">100</span>, b = <span class="number">100</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">ave</span>(a, b) &lt;&lt; std::endl;  <span class="comment">// 自动转成float</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">ave</span>((<span class="type">int</span>)a, (<span class="type">int</span>)b) &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 这地方的 转换是临时 的变量，没有固定的内存地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ave</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ave</span><span class="params">(<span class="type">const</span> <span class="type">int</span> a, <span class="type">const</span> <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不可以重载，是以值传参，不能修改内存里面的值，所以const形同虚设</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ave</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ave</span><span class="params">(<span class="type">const</span>&amp; <span class="type">int</span> a, <span class="type">const</span>&amp; <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以重载，</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>, b = <span class="number">100</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> c = <span class="number">20</span>, d = <span class="number">10</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">ave</span>(a, b) &lt;&lt; std::endl;  <span class="comment">//  非调用第一个</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">ave</span>(c, d) &lt;&lt; std::endl;  <span class="comment">//  常量执行第二个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x2F;&#x2F; 函数重载的时候不能默认参数   编译器分不清</p><h4 id="函数模板（C-内容）"><a href="#函数模板（C-内容）" class="headerlink" title="函数模板（C++内容）"></a>函数模板（C++内容）</h4><p>先说下什么是模板，模板就是编写“<code>类型参数化</code>”的代码，等到编译时再根据具体类型生成对应版本。</p><p>模板在编译时实例化，当编译器遇到模板的具体使用时，例如调用模板函数或创建模板类实例时，编译器会生成相应的代码。这一过程称为模板的实例化。</p><p>1️⃣函数模板  ，定义通用的函数逻辑，<code>template&lt;typename T&gt; T add(T a, T b)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;      <span class="comment">// 推导出 T=int</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>(<span class="number">3.5</span>, <span class="number">2.1</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 推导出 T=double</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2️⃣类模板，定义通用的类或数据结构，<code>template&lt;typename T&gt; class MyVector</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T value;</span><br><span class="line">    <span class="built_in">Box</span>(T val) : <span class="built_in">value</span>(val) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; value &lt;&lt; <span class="string">&quot;\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Box&lt;<span class="type">int</span>&gt; <span class="title">intBox</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Box&lt;std::string&gt; <span class="title">strBox</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    intBox.<span class="built_in">show</span>();   <span class="comment">// 输出 10</span></span><br><span class="line">    strBox.<span class="built_in">show</span>();   <span class="comment">// 输出 hello</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面主要介绍下<strong>函数模板</strong></p><p>函数模板（Function Template）是 C++ 中的一种通用编程技术，允许程序员编写可以操作多种数据类型的函数，而无需为每种数据类型单独重写代码。函数模板通过引入模板参数，使函数的类型可以在调用时动态确定。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type1&gt; <span class="function">type1 <span class="title">ave</span><span class="params">(type1 a, type1 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type1&gt;</span><br><span class="line"><span class="function">type1 <span class="title">ave</span><span class="params">(type1 a, type1 b, type1 c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a + b + c) / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">type1 <span class="title">ave1</span><span class="params">(type1* a, type1* b, type1* c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a + b + c) / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把type1当作一种类型来使用   指针  数组  都可以</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">ave</span>(<span class="number">12.0f</span>, <span class="number">250.0f</span>, <span class="number">35.33f</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">ave</span>(<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">ave</span>((<span class="type">char</span>)<span class="number">11</span>, (<span class="type">char</span>)<span class="number">12</span>, (<span class="type">char</span>)<span class="number">13</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定函数参数的模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type1&gt; <span class="function">type1 <span class="title">ave</span><span class="params">(type1 a, type1 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">ave</span>&lt;<span class="type">int</span>&gt;(<span class="number">12.0f</span>, <span class="number">250.0f</span>, <span class="number">35.33f</span>) &lt;&lt; std::endl;  <span class="comment">// 转换成int类型了</span></span><br><span class="line">    <span class="comment">// 相当于执行下面的代码</span></span><br><span class="line">    <span class="comment">// int ave(int a, int b);   而不是 float ave(float a, float b);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数重载大于函数模板</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type1&gt;</span></span><br><span class="line"><span class="function">type1 <span class="title">bigger</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 例外</span></span><br><span class="line"><span class="comment">//template&lt;&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">bigger</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *a &gt; *b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">float</span>* <span class="title">bigger</span><span class="params">(<span class="type">float</span>* a, <span class="type">float</span>* b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *a &gt; *b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type1&gt;</span></span><br><span class="line"><span class="function">type1 <span class="title">ave</span><span class="params">(type1 a, type1 b, type1 c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b + c) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 本来是想着减少内存开销，传入指针，结果发现，传入的是地址</span></span><br><span class="line">    <span class="type">int</span> a&#123; <span class="number">100</span> &#125;, b&#123; <span class="number">200</span> &#125;, c&#123; <span class="number">300</span> &#125;;</span><br><span class="line">    c = *<span class="built_in">bigger</span>(&amp;a, &amp;b);</span><br><span class="line">    c = *<span class="built_in">ave</span>(&amp;a, &amp;b, &amp;c);   <span class="comment">//相当于把内存地址加起来除以3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键字<strong>auto decltype</strong></p><p>1️⃣auto 不保留const属性  <code>const int a&#123; 10 &#125;;</code> <code>auto b = a;</code>  这里的b就是int类型 。</p><p>2️⃣ auto 会优先推断为值类型而非引用类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> b&#123;<span class="number">200</span>&#125;;</span><br><span class="line"><span class="type">int</span>&amp; l&#123;b&#125;;</span><br><span class="line"><span class="keyword">auto</span> c = l;   <span class="comment">// 这里l还是int类型</span></span><br></pre></td></tr></table></figure><p>3️⃣ auto 利用函数返回值来确定类型的时候，函数会执行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="built_in">ave</span>(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">// ave(1,2)会执行    x的类型根据ave函数的返回类型来确定</span></span><br></pre></td></tr></table></figure><p>根据特性2️⃣</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#inlcude <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// auto 拖尾函数</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">bigger</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span>-&gt;<span class="type">float</span>   <span class="comment">// 转成float类型了</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">bigger</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span>  <span class="comment">// 这里改成auto不行，会把&amp;转成int</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a&#123;<span class="number">100</span>&#125;;</span><br><span class="line">    <span class="type">int</span> b&#123;<span class="number">200</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 能这么写是因为返回值不是临时变量，左值</span></span><br><span class="line">    <span class="comment">// bigger(a, b) = 500;  // 比较a 和 b 哪个数大，大的 改成500;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>decltype关键字</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a&#123;&#125;;</span><br><span class="line"><span class="type">unsigned</span> b&#123;&#125;;</span><br><span class="line"><span class="keyword">decltype</span>(a-b) x;  <span class="comment">// 相当于unsigned x;    有符号数和无符号运算，结果为无符号数</span></span><br></pre></td></tr></table></figure><p>如果表达式没有经历过运算，那么类型是一样的，  可以保留引用属性  （引用必须初始化）</p><p>（没有固定内存地址的情况）如果经历过运算了，会根据结果的类型来推断类型</p><p>（有固定内存地址的情况）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a&#123;<span class="number">100</span>&#125;;</span><br><span class="line"><span class="type">int</span>* pa&#123;&amp;a&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(*pa) x = a;<span class="comment">// x 是int 类型的引用</span></span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/11/24/674327db2d723.png"></p><p><code>decltype(pa[5]) x;</code>  相当于int&amp; x    pa[5]是有地址的，只是不归我们访问而已</p><p><img src="https://bu.dusays.com/2024/11/24/674328e67c835.png"></p><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://bu.dusays.com/2024/11/24/67432a50d20d6.png"></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">bigger</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span>-&gt;<span class="title">decltype</span><span class="params">(a &gt; b ? a : b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">bigger</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="推断函数模板返回类型"><a href="#推断函数模板返回类型" class="headerlink" title="推断函数模板返回类型"></a>推断函数模板返回类型</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function">T1 <span class="title">ave</span><span class="params">(T2 a, T1 b)</span>   <span class="comment">// T1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 返回类型是由后面的决定的</span></span><br><span class="line">    <span class="built_in">ave</span>(<span class="number">100.02f</span>, <span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="title">delctype</span><span class="params">(<span class="keyword">auto</span>)</span> <span class="title">bigger</span><span class="params">(T1&amp; a, T2&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> a = <span class="number">50</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">50000</span>;</span><br><span class="line">    <span class="comment">// float&amp; lx = b;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">bigger</span>(a, b);  <span class="comment">// 结果是个float引用，但是不能指向int类型</span></span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="函数模板参数的默认值"><a href="#函数模板参数的默认值" class="headerlink" title="函数模板参数的默认值"></a>函数模板参数的默认值</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 返回值默认为int类型, 建议写在前面</span></span><br><span class="line"><span class="comment">// 另一种写法,  可以不指定了，跟着T1 走</span></span><br><span class="line"><span class="comment">// template&lt;typename T1, typename T2, typename TR = T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TR </span>= <span class="type">int</span>, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function">TR <span class="title">ave</span><span class="params">(T1 a, T2 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数模板可以有非类型的模板参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type1, <span class="type">int</span> max, <span class="type">int</span> min&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">AddHp</span><span class="params">(type1&amp; hp, type1 damage)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hp -= damage;</span><br><span class="line">    <span class="keyword">if</span> (hp &gt; max) hp = max;</span><br><span class="line">    <span class="keyword">return</span> hp &lt; min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实践，试下这个函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> max, <span class="type">int</span> min, <span class="keyword">typename</span> type1&gt;   <span class="comment">// 建议将 非类型参数写在前面</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ChangeHp</span><span class="params">(type1&amp; hp, type1 damage)</span>  <span class="comment">// max 和 min 不是变量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hp -= damage;</span><br><span class="line">    <span class="keyword">if</span> (hp &gt; max) hp = max;</span><br><span class="line">    <span class="keyword">return</span> hp &lt; min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hp = <span class="number">2500</span>;</span><br><span class="line">    <span class="comment">// const int x = 2500;</span></span><br><span class="line">    <span class="comment">// ChangHp&lt;x,1000&gt;(hp, 100);  // 这样会报错，x 是常量才可以，这也说明了max和min不是变量</span></span><br><span class="line">    <span class="built_in">ChangHp</span>&lt;<span class="number">2000</span>,<span class="number">1000</span>&gt;(hp, <span class="number">100</span>);   <span class="comment">// &lt;&gt;里面的数据需要指定</span></span><br><span class="line">    std::cout &lt;&lt; hp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  指定默认值</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 指定默认值之后，在main里面就不需要&lt;&gt;来指定max  min的值了</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="type">int</span> max </span>= <span class="number">2000</span>, <span class="type">int</span> min = <span class="number">1000</span>, <span class="keyword">typename</span> type1&gt;</span><br><span class="line"><span class="type">bool</span> <span class="built_in">ChangeHp</span>(type1&amp; hp, type1 damage) </span><br><span class="line">&#123;</span><br><span class="line">    hp -= damage;</span><br><span class="line">    <span class="keyword">if</span> (hp &gt; max) hp = max;</span><br><span class="line">    <span class="keyword">return</span> hp &lt; min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hp = <span class="number">2500</span>;</span><br><span class="line">    <span class="built_in">ChangHp</span>(hp, <span class="number">100</span>);</span><br><span class="line">    std::cout &lt;&lt; hp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将非类型参数写在后面</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将max 和 min 转换为type1类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type1, type1 max = <span class="number">2000</span>, type1 min = <span class="number">1000</span>, &gt; type1 类型</span><br><span class="line"><span class="type">bool</span> <span class="built_in">ChangeHp</span>(type1&amp; hp, type1 damage) </span><br><span class="line">&#123;</span><br><span class="line">    hp -= damage;</span><br><span class="line">    <span class="keyword">if</span> (hp &gt; max) hp = max;</span><br><span class="line">    <span class="keyword">return</span> hp &lt; min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/11/25/6743c6535c905.png"></p><p><strong>处理不同元素数组的模板函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">short</span> count&gt;</span></span><br><span class="line"><span class="function">T <span class="title">ave</span><span class="params">(T(&amp;ary)[count])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T all&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i ++ )</span><br><span class="line">        all += ary[i];</span><br><span class="line">    <span class="keyword">return</span> all / count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">ave</span>(a);  <span class="comment">// count的值是通过数组大小自动推导出来的</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 显式指定模板参数</span></span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; ave&lt;int, 5&gt;(a) &lt;&lt; std::endl;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 只指定 count 的值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">ave</span>&lt;<span class="keyword">decltype</span>(a[<span class="number">0</span>]), <span class="number">5</span>&gt;(a) &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>小项目：万能排序工具</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T tmp&#123; a &#125;;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sort</span><span class="params">(T* ary, <span class="type">unsigned</span> count, <span class="type">bool</span> BigSort = <span class="literal">true</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">1</span>; i &lt; count; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">1</span>; i &lt; count; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">bool</span> bcase = BigSort &gt; ary[i] &gt; ary[i - <span class="number">1</span>] : ary[i] &lt; ary[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (bcase) <span class="built_in">Swap</span>(ary[i], ary[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">6</span>]&#123; <span class="number">123</span>, <span class="number">343</span>, <span class="number">434</span>, <span class="number">1</span>, <span class="number">3454</span>, <span class="number">33</span>&#125;;</span><br><span class="line">    <span class="type">short</span> a1[<span class="number">6</span>]&#123; <span class="number">123</span>, <span class="number">343</span>, <span class="number">434</span>, <span class="number">1</span>, <span class="number">3454</span>, <span class="number">33</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    std::string a2[<span class="number">5</span>]&#123; <span class="string">&quot;12&quot;</span>,<span class="string">&quot;asd&quot;</span>,<span class="string">&quot;sdf&quot;</span>,<span class="string">&quot;sesdas&quot;</span>,<span class="string">&quot;sdasd&quot;</span> &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Sort</span>(a1, <span class="number">6</span>);</span><br><span class="line"><span class="built_in">Sort</span>(a, <span class="number">6</span>);</span><br><span class="line"><span class="built_in">Sort</span>(a2, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x : a)std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x : a1)std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x : a2)std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cpp03函数</title>
      <link href="/2024/12/11/cpp03%E5%87%BD%E6%95%B0/"/>
      <url>/2024/12/11/cpp03%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p><strong>函数参数：指针参数</strong></p><ul><li>如果需要传递大型数据结构，可以传递指针而不是整个数据结构，避免复制数据。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span>* x, <span class="type">int</span>* y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (*x) *= <span class="number">100</span>;</span><br><span class="line">    (*y) *= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> (*x) + (*y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">2</span>, y = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> c = <span class="built_in">Add</span>(&amp;x, &amp;y);</span><br><span class="line">    <span class="comment">//x 和  y 的值都改了  指针改的是内存中的数值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c=&quot;</span> &lt;&lt; c &lt;&lt; <span class="string">&quot;x=&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;y=&quot;</span> &lt;&lt; y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Role</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> Hp;</span><br><span class="line">    <span class="type">int</span> Mp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int Exp(Role r1)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    return r1.Hp + r1.Mp;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Exp</span><span class="params">(Role* r1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> r1-&gt;Hp + r1-&gt;Mp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Role r1&#123;<span class="number">500</span>,<span class="number">200</span>&#125;;</span><br><span class="line">    <span class="comment">//c = Exp(r1);</span></span><br><span class="line">    c = <span class="built_in">Exp</span>(&amp;r1);  <span class="comment">// 效率大大提升</span></span><br><span class="line">    std::cout &lt;&lt; c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>避免修随意修改值，使用常量指针限定只读操作</p><p>游戏小程序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Role</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> Hp;</span><br><span class="line">    <span class="type">int</span> Mp;</span><br><span class="line">    <span class="type">int</span> damage;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Act</span><span class="params">(<span class="type">const</span> Role* Acter, Role* beActer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    beActer-&gt;Hp -= Acter-&gt;damage;</span><br><span class="line">    <span class="keyword">return</span> beActer-&gt;Hp &lt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Role User&#123; <span class="number">1000</span>,<span class="number">1500</span>,<span class="number">2222220</span> &#125;;</span><br><span class="line">    Role Monster&#123; <span class="number">1500</span>,<span class="number">100</span>,<span class="number">100</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Act</span>(&amp;Monster, &amp;User))</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;角色死亡！！&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">Act</span>(&amp;User, &amp;Monster)) std::cout &lt;&lt; <span class="string">&quot;怪物死亡！获得屠龙宝刀！&quot;</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>数组参数</strong></p><p>数组参数两种方式(等价，汇编代码也一样)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sort</span><span class="params">(<span class="type">int</span> ary[], <span class="type">unsigned</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i ++ )</span><br><span class="line">        std::cout &lt;&lt; ary[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sort</span><span class="params">(<span class="type">int</span>* ary. <span class="type">unsigned</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i ++ )</span><br><span class="line">        std::cout &lt;&lt; ary[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面这俩都不能给到预期的结果</span></span><br><span class="line"><span class="comment">// 指针，能得到地址，但是得不到总大小，后面还得传入个数组大小才行  加个unsigned </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sort</span><span class="params">(<span class="type">int</span> ary[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span>(ary);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sort</span><span class="params">(<span class="type">int</span> ary[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span>(ary);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二维数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 必须指定后面的</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sort</span><span class="params">(<span class="type">int</span> ary[][<span class="number">2</span>] <span class="type">unsigned</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">3</span>][<span class="number">2</span>]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line">    <span class="built_in">Sort</span>(a,<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作业，改造Sort函数</p><p><strong>引用参数</strong></p><p>可以像指针一样，设定只能读不能写</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Role</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> hp;</span><br><span class="line">    <span class="type">int</span> mp;</span><br><span class="line">    <span class="type">int</span> damage;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Act</span><span class="params">(<span class="type">const</span> Role&amp; Acter, Role&amp; beAct)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    beAct.hp -= Acter.damage;</span><br><span class="line">    <span class="keyword">return</span> beAct.hp &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Role user&#123;<span class="number">200</span>,<span class="number">300</span>,<span class="number">850</span>&#125;;</span><br><span class="line">    Role monster&#123;<span class="number">800</span>,<span class="number">300</span>,<span class="number">50</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Act</span>(user,monster)) std::cout &lt;&lt; <span class="string">&quot;怪物死亡，获得。。。。&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指针和引用的区别</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Act</span><span class="params">(Role&amp; Acter, Role&amp; beAct)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Act</span><span class="params">(Role* Acter, Role* beAct)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Act</span>(<span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="comment">// 区别：指针可以传入nullptr空指针, 而引用不可以。</span></span><br></pre></td></tr></table></figure><p>*&amp;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Role类型的指针的引用</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Act</span><span class="params">(<span class="type">const</span> Role&amp; Acter, Role* beAct)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    beAct-&gt;hp -= Acter.damage;</span><br><span class="line">    <span class="type">bool</span> bEnd = beAct-&gt;hp&lt;<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 让beAct指向Acter</span></span><br><span class="line">    beAct = (Role*)&amp;Acter;</span><br><span class="line">    <span class="keyword">return</span> beAct-&gt;hp &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Role user&#123;<span class="string">&quot;奥特曼&quot;</span>,<span class="number">200</span>,<span class="number">300</span>,<span class="number">500</span>&#125;;</span><br><span class="line">    Role monster&#123;<span class="string">&quot;小怪兽&quot;</span>,<span class="number">800</span>,<span class="number">300</span>,<span class="number">50</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    Role* pRole = &amp;monster;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出的name还是小怪兽，因为在函数作用内beAct指向了Acter,但是pRole没有指向Acter</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Act</span>(user, pRole)) std::cout &lt;&lt; pRole-&gt;Name &lt;&lt; <span class="string">&quot;怪物死亡。。。&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决办法</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Act</span><span class="params">(<span class="type">const</span> Role&amp; Acter, Role*&amp; beAct)</span></span>;</span><br><span class="line"><span class="comment">// 这样 pRole也指向Acter了</span></span><br></pre></td></tr></table></figure><p>完整的代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Role</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> Name[<span class="number">0x20</span>];</span><br><span class="line">    <span class="type">int</span> Hp;</span><br><span class="line">    <span class="type">int</span> Mp;</span><br><span class="line">    <span class="type">int</span> damage;</span><br><span class="line">&#125;*PROLE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Act</span><span class="params">(<span class="type">const</span> Role* Acter, PROLE&amp; beActer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    beAct-&gt;hp -= Acter-&gt;damage;</span><br><span class="line">    <span class="type">bool</span> bEnd = beAct-&gt;hp&lt;<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    beAct = (Role*)&amp;Acter;</span><br><span class="line">    <span class="keyword">return</span> beAct-&gt;hp &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Role user&#123;<span class="string">&quot;奥特曼&quot;</span>,<span class="number">200</span>,<span class="number">300</span>,<span class="number">500</span>&#125;;</span><br><span class="line">    Role monster&#123;<span class="string">&quot;小怪兽&quot;</span>,<span class="number">800</span>,<span class="number">300</span>,<span class="number">50</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    PROLE pRole = &amp;monster;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Act</span>(user, pRole)) std::cout &lt;&lt; pRole-&gt;Name &lt;&lt; <span class="string">&quot;怪物死亡。。。&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>按值传递 vs 按引用传递</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Act</span><span class="params">(<span class="type">const</span> Role* Acter, PROLE beActer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// beActer 是 PROLE 的拷贝，修改它不会影响原始的 PROLE</span></span><br><span class="line">    beActer = (Role*)&amp;Acter;</span><br><span class="line">    <span class="keyword">return</span> beActer-&gt;Hp &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在这种情况下，beActer 是 PROLE 的拷贝，修改 beActer 后不会影响 pRole。pRole 依然指向原始的 monster。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Act</span><span class="params">(<span class="type">const</span> Role* Acter, PROLE&amp; beActer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// beActer 是 PROLE 的引用，修改它会影响原始的 PROLE</span></span><br><span class="line">    beActer = (Role*)&amp;Acter;</span><br><span class="line">    <span class="keyword">return</span> beActer-&gt;Hp &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span>* x, <span class="type">int</span>* y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (*x) *= <span class="number">100</span>;  <span class="comment">// 修改 x 指向的值</span></span><br><span class="line">    (*y) *= <span class="number">10</span>;   <span class="comment">// 修改 y 指向的值</span></span><br><span class="line">    <span class="keyword">return</span> (*x) + (*y);  <span class="comment">// 返回修改后的值之和</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个例子也是值传递，但因为通过指针解引用(*x 和 *y)修改了指针所指向的变量的值，所以下面的代码实际上是修改了原始变量的内容。所以，尽管是值传递，但是通过指针传递数据导致的效果是修改了原始数据。</p><ul><li><strong>指针本身是值传递</strong>（函数内的指针 <code>x</code> 和 <code>y</code> 是原始指针的副本）。</li><li><strong>指针所指向的内容是通过解引用修改的</strong>（因此修改了原始数据）。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> tmp = ary[i];</span><br><span class="line">    ary[i] = ary[i - <span class="number">1</span>];</span><br><span class="line">    ary[i - <span class="number">1</span>] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sort</span><span class="params">(<span class="type">int</span> ary[], <span class="type">unsigned</span> count, <span class="type">bool</span> BigSort)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; count; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; count; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">bool</span> bcase = BigSort?ary[i] &gt; ary[i - <span class="number">1</span>] : ary[i] &lt; ary[i - <span class="number">1</span>];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (bcase) <span class="built_in">swap</span>(ary[i], ary[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>默认实参</strong></p><p>用户不指定值的时候，就使用默认的值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sort</span><span class="params">(<span class="type">int</span> ary[], <span class="type">unsigned</span> count, <span class="type">bool</span> BigSort = <span class="literal">true</span>)</span></span></span><br></pre></td></tr></table></figure><p>默认参数只能放在最后</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a = <span class="number">100</span>, b = <span class="number">200</span>)</span></span>; <span class="comment">// 正确， 相当于Add(100,200);</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a = <span class="number">100</span>, <span class="type">int</span> b)</span></span>;  <span class="comment">// 错误</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">100</span>, <span class="type">int</span> c = <span class="number">250</span>)</span></span>; <span class="comment">// 正确</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span>&amp; b = <span class="number">100</span>)</span></span>;   <span class="comment">//error   引用的本质是一个指针，指定100错了</span></span><br></pre></td></tr></table></figure><p><strong>不定量参数</strong></p><p>main: 处理命令行选项 ，有时候需要给main传递实参，一种常见的情况是用户通过设置一组选项来确定函数所要执行的操作。假定main函数位于可执行文件prog之内，向程序传递下面的选项</p><p><code>prog -d -o ofile data0</code></p><p>这些命令行通过两个可选的形参传递给main函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, cahr* argv[])</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>第二个形参是一个数组，它的元素是指向C风格字符串的指针：第一个形参argc表示数组中字符串的数量。因为第二个形参是数组，所以main函数也可以定义成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>其中 argv 指向char* 。。</p><p>当实参传给main函数之后，argv的第一个元素指向程序的名字或者一个空字符串，接下来的元素一次传递命令行提供的实参。最后一个指针之后的元素保证为0 。</p><p><code>argv[0] = &quot;prog&quot;;</code></p><p><code>argv[1] = &quot;-d&quot;;</code></p><p><code>argv[2] = &quot;-o&quot;;</code></p><p><code>argv[3] = &quot;ofile&quot;;</code></p><p><code>argv[4] = &quot;data0&quot;;</code></p><p><code>argv[5] = 0;</code></p><p>例题：输出程序名字和路径</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// argv[0] 是程序完整的路径（包括文件名）</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;程序名字&quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* programName = <span class="built_in">strrchr</span>(argv[<span class="number">0</span>], <span class="string">&#x27;\\&#x27;</span>);</span><br><span class="line">    <span class="comment">// strrchr 是一个 字符串函数，用于查找路径中最后一次出现反斜杠\位置。</span></span><br><span class="line">    <span class="comment">// 如果找到反斜杠，返回指向它的指针   否则返回nullptr</span></span><br><span class="line">    <span class="keyword">if</span> (programName != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        programName++;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;程序名称：&quot;</span> &lt;&lt; programName &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;程序名称：&quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用刚学的find方法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &gt; <span class="number">0</span>) std::string programPath = argv[<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;程序路径：&quot;</span> &lt;&lt; programPath &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    std::<span class="type">size_t</span> lastSlash = programPath.<span class="built_in">rfind</span>(<span class="string">&#x27;\\&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (lastSlash == std::string::npos) lastSlash = programPath.<span class="built_in">rfind</span>(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (lastSlash != std::string::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        std::string programName = programPath.<span class="built_in">substr</span>(lastSlash + <span class="number">1</span>);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;程序名称： &quot;</span> &lt;&lt; programName &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> std::cout &lt;&lt; <span class="string">&quot;程序名称： &quot;</span> &lt;&lt; programPath &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>可变形参的函数</strong></p><p>使用 <code>...</code> 语法（C 风格的可变参数）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdarg&gt;</span>  <span class="comment">// 头文件支持可变参数</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printNumbers</span><span class="params">(<span class="type">int</span> count, ...)</span> </span>&#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    <span class="comment">// 可以使用char* args&#123;&#125;; 替代</span></span><br><span class="line">    <span class="comment">// 告诉args有多少个参数</span></span><br><span class="line">    <span class="built_in">va_start</span>(args, count);  <span class="comment">// 初始化 args 以访问可变参数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印传入的所有参数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">        <span class="comment">// 要读的指针  和  参数的类型</span></span><br><span class="line">        <span class="comment">// 每调用一次，就能获取下一个参数</span></span><br><span class="line">        <span class="type">int</span> num = <span class="built_in">va_arg</span>(args, <span class="type">int</span>);  <span class="comment">// 获取下一个参数，类型为 int</span></span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">va_end</span>(args);  <span class="comment">// 清理  释放args</span></span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printNumbers</span>(<span class="number">3</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>);  <span class="comment">// 打印 10 20 30</span></span><br><span class="line">    <span class="built_in">printNumbers</span>(<span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);  <span class="comment">// 打印 1 2 3 4 5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>std::initializer_list</code>(C++11之后)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printNumbers</span><span class="params">(std::initializer_list&lt;<span class="type">int</span>&gt; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printNumbers</span>(&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;);  <span class="comment">// 打印 10 20 30</span></span><br><span class="line">    <span class="built_in">printNumbers</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;);  <span class="comment">// 打印 1 2 3 4 5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>std::vector</code> 或者其他容器</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printNumbers</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printNumbers</span>(&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;);  <span class="comment">// 打印 10 20 30</span></span><br><span class="line">    <span class="built_in">printNumbers</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;);  <span class="comment">// 打印 1 2 3 4 5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>std::function</code>  和 Lambda 表达式（高级用法）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">applyFunction</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; func)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Lambda 接受不定数量参数</span></span><br><span class="line">    <span class="built_in">applyFunction</span>([]() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Lambda with no arguments!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>一个小作业</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">ReadRef</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* ref, <span class="type">const</span> <span class="type">char</span>* cmds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; cmds[i]; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cmds[i] == ref[<span class="number">0</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">bool</span> found = <span class="literal">true</span>;</span><br><span class="line">            <span class="type">int</span>  x;</span><br><span class="line">            <span class="keyword">for</span> (x = <span class="number">0</span>; ref[x]; x ++ )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (ref[x] != cmds[i + x])</span><br><span class="line">                &#123;</span><br><span class="line">                    found = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (found) <span class="keyword">return</span> &amp;cmds[i + x];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* id = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* pass = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* country = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!id) id = <span class="built_in">ReadRef</span>(<span class="string">&quot;id:&quot;</span>, argv[i]);</span><br><span class="line">        <span class="keyword">if</span> (!pass) pass = <span class="built_in">ReadRef</span>(<span class="string">&quot;pass:&quot;</span>, argv[i]);</span><br><span class="line">        <span class="keyword">if</span> (!country) country = <span class="built_in">ReadRef</span>(<span class="string">&quot;country:&quot;</span>, argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (id &amp;&amp; pass &amp;&amp; country) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;注册成功！\n&quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;账号：&quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;密码：&quot;</span> &lt;&lt; pass &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;国家：&quot;</span> &lt;&lt; country &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;参数不足！请按以下格式调用程序：\n&quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;./program id:&lt;your_id&gt; pass:&lt;your_pass&gt; country:&lt;your_country&gt;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cpp02联合体和字符</title>
      <link href="/2024/12/11/cpp02%E8%81%94%E5%90%88%E4%BD%93%E5%92%8C%E5%AD%97%E7%AC%A6/"/>
      <url>/2024/12/11/cpp02%E8%81%94%E5%90%88%E4%BD%93%E5%92%8C%E5%AD%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<p><strong>联合体语法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示范</span></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">USER</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">short</span> sHP;</span><br><span class="line">    <span class="type">int</span> nHP;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 通过union 可以创建一个联合体，union中的成员变量共享内存，因此union的数据类型大小由其最大的成员变量决定。</span></span><br></pre></td></tr></table></figure><p>实践一下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 联合体</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">USER</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">short</span> sHP;</span><br><span class="line"><span class="type">int</span> nHP;</span><br><span class="line"><span class="type">double</span> fHP;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line"><span class="type">short</span> sHP;</span><br><span class="line"><span class="type">int</span> nHP;</span><br><span class="line"><span class="type">double</span> fHP;</span><br><span class="line">&#125; ls;<span class="comment">// 不重用，临时的 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="type">short</span> sHP;</span><br><span class="line"><span class="type">int</span> nHP;</span><br><span class="line"><span class="type">double</span> fHP;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 内存分配   没有初始化</span></span><br><span class="line">USER user;</span><br><span class="line">Test t;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sizeof</span>(user) &lt;&lt; std::endl; </span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sizeof</span>(t) &lt;&lt; std::endl;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">user.sHP = <span class="number">100</span>;<span class="comment">//[100][0][][][][][][]</span></span><br><span class="line">std::cout &lt;&lt; user.sHP &lt;&lt; std::endl;  <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//[100][0][？][？][？][？][？][？]</span></span><br><span class="line"><span class="comment">// 访问4个格子，但有俩没有初始化，不知道是什么值</span></span><br><span class="line">std::cout &lt;&lt; user.nHP &lt;&lt; std::endl;  </span><br><span class="line">user.nHP = <span class="number">0</span>;</span><br><span class="line">std::cout &lt;&lt; user.nHP &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>未命名的联合体是供临时使用的！</p><p><strong>C 语言中 字符串的拼接</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">0x10</span>] = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="type">char</span> strB[<span class="number">0x10</span>] = <span class="string">&quot;456&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> strC[<span class="number">0x20</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(strC, str, <span class="built_in">strlen</span>(str));</span><br><span class="line"><span class="built_in">memcpy</span>(strC + <span class="built_in">strlen</span>(str), strB, <span class="built_in">strlen</span>(strB) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; strC;</span><br></pre></td></tr></table></figure><p><strong>C++ 中 字符串拼接</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">string str&#123;<span class="string">&quot;12345&quot;</span>&#125;;</span><br><span class="line"><span class="comment">// 不必考虑溢出</span></span><br><span class="line">std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">string str1&#123; <span class="string">&quot;123455&quot;</span>, <span class="number">3</span> &#125;; <span class="comment">// 只要前面三个字符串</span></span><br><span class="line">std::cout &lt;&lt; str1 &lt;&lt; std::endl;  <span class="comment">// 输出123</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">string str2&#123; <span class="string">&quot;0123456&quot;</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;  <span class="comment">// 从2开始截取3位</span></span><br><span class="line">std::cout &lt;&lt; str2 &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">// 对中文支持的不太好</span></span><br><span class="line">string str3&#123; <span class="string">&quot;你好啊啊啊&quot;</span>, <span class="number">3</span> &#125;;</span><br><span class="line">std::cout &lt;&lt; str3 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">str4</span><span class="params">(<span class="number">6</span>, <span class="string">&#x27;a&#x27;</span>)</span></span>;  <span class="comment">// 6个  a</span></span><br><span class="line"><span class="function">string <span class="title">str5</span><span class="params">(<span class="number">6</span>, <span class="number">65</span>)</span></span>;  <span class="comment">//转成大写的A</span></span><br><span class="line">std::cout &lt;&lt; str4 &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; str5 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接字符串</span></span><br><span class="line">string str6, str7;</span><br><span class="line">str6 = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">str7 = <span class="string">&quot;456&quot;</span>;</span><br><span class="line"></span><br><span class="line">str6 = str7 + <span class="string">&quot; &quot;</span> + <span class="string">&quot;123&quot;</span>;  <span class="comment">// 这里一定要有string 类型的变量在这里</span></span><br><span class="line">std::cout &lt;&lt; str6 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把数字转换成字符串</span></span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">std::cin &gt;&gt; age;</span><br><span class="line"></span><br><span class="line">string st;</span><br><span class="line">st = <span class="string">&quot; 用户的年龄是：&quot;</span>;</span><br><span class="line">str7 = st + std::<span class="built_in">to_string</span>(age);</span><br><span class="line">std::cout &lt;&lt; str7;</span><br></pre></td></tr></table></figure><p><strong>C++ 中字符串拼接（进阶）</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SoftName <span class="string">&quot;EDY&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SoftVersion <span class="string">&quot;2.0&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string str;</span><br><span class="line"></span><br><span class="line"><span class="comment">//str = &quot;1233&quot; + &quot;1222&quot;;</span></span><br><span class="line"><span class="comment">// 不能直接连接两个字符串</span></span><br><span class="line">str = string&#123; <span class="string">&quot;!22&quot;</span> &#125; + <span class="string">&quot;1233&quot;</span>;  <span class="comment">// 把字符串放到临时变量里面就可以了</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//str = &quot;1233&quot; + &quot;bcbc&quot; + string&#123; &quot;!22&quot; &#125;;   error</span></span><br><span class="line"><span class="comment">// 前面两个加法是直接的字符串的字面量</span></span><br><span class="line"><span class="comment">//改进</span></span><br><span class="line">str = <span class="string">&quot;abc&quot;</span> + (<span class="string">&quot;bcd&quot;</span> + string&#123; <span class="string">&quot;123&quot;</span> &#125;); <span class="comment">// 这样就可以了</span></span><br><span class="line"></span><br><span class="line">str += <span class="string">&quot;aka&quot;</span>;  <span class="comment">// 没问题</span></span><br><span class="line"><span class="comment">//str += &quot;aka&quot; + &quot;bka&quot;;    +的优先级大于   +=</span></span><br><span class="line"><span class="comment">// 解决办法如下</span></span><br><span class="line">str += <span class="string">&quot;aka&quot;</span> + string&#123; <span class="string">&quot;bka&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">string strB;</span><br><span class="line"><span class="comment">// 连接</span></span><br><span class="line">strB = <span class="string">&quot;!23&quot;</span><span class="string">&quot;233&quot;</span>;</span><br><span class="line"><span class="comment">// 唯一用途</span></span><br><span class="line">strB = SoftName SoftVersion;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 字符串连接  字符</span></span><br><span class="line">    string strC&#123;<span class="string">&quot;123&quot;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    std::cin &gt;&gt; a;</span><br><span class="line">    str += a;  <span class="comment">// 允许这样连接</span></span><br><span class="line">    <span class="comment">// 注意事项</span></span><br><span class="line">    str += a + <span class="string">&#x27;o&#x27;</span>;  <span class="comment">// 两个字符  是俩常量，可以相加    字符a 与 字符o相加之后再连接</span></span><br><span class="line">    <span class="comment">// 相当于</span></span><br><span class="line">    str += <span class="built_in">char</span>(a + <span class="string">&#x27;o&#x27;</span>);</span><br><span class="line">    <span class="comment">// 字符串不能相加的原因是， 字符串是两个char类型的数组</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//拼接方法</span></span><br><span class="line">    string strD&#123;<span class="string">&quot;123&quot;</span>&#125;;</span><br><span class="line">    strD.<span class="built_in">append</span>(<span class="string">&quot;456&quot;</span>);  <span class="comment">// 在字符串后面拼接上456</span></span><br><span class="line">    strD.<span class="built_in">append</span>(<span class="string">&quot;222&quot;</span>).<span class="built_in">append</span>(<span class="string">&quot;dfddd&quot;</span>);  <span class="comment">// 无限  加append</span></span><br><span class="line">    <span class="comment">// 拼接的时候也可以有选择</span></span><br><span class="line">    strD.<span class="built_in">append</span>(<span class="string">&quot;123455&quot;</span>, <span class="number">2</span>); <span class="comment">// 从2开始拼接   跟字符串初始化用法一样</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>截取字符串</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.<span class="built_in">substr</span>(起始位置,要截取的长度);</span><br><span class="line"></span><br><span class="line">std::string str&#123;<span class="string">&quot;123456&quot;</span>&#125;;</span><br><span class="line">std::string strsub&#123;str.<span class="built_in">substr</span>(<span class="number">1</span>)&#125;;  <span class="comment">// strsub = &quot;23456&quot;</span></span><br><span class="line">std::string strsubA&#123;str.<span class="built_in">substr</span>(<span class="number">1</span>, <span class="number">3</span>)&#125;; <span class="comment">// strsubA = &quot;234&quot;;</span></span><br><span class="line"></span><br><span class="line">string strB;</span><br><span class="line"><span class="comment">// 也可以连着截取，但是要放到一个新的string里面</span></span><br><span class="line">strB = str.<span class="built_in">substr</span>(<span class="number">7</span>).<span class="built_in">substr</span>(<span class="number">3</span>);  <span class="comment">// 提取从索引7开始的子字符串（包括索引 7 的字符）， 直到字符串末尾。.substr(3) 在上一步的基础上，从索引 3 开始提取子字符串 （包括索引3 的字符）， 直到字符串末尾。</span></span><br><span class="line"><span class="comment">// 字符串的索引也是从0开始的</span></span><br><span class="line"><span class="comment">// substr不会改变str的值，而append会改变</span></span><br></pre></td></tr></table></figure><p><strong>计算字符串长度</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string str&#123;<span class="string">&quot;222222&quot;</span>&#125;;</span><br><span class="line"><span class="comment">// 对中文字符串长度的计算还是不准确</span></span><br><span class="line">std::cout &lt;&lt; str.<span class="built_in">length</span>();</span><br></pre></td></tr></table></figure><p>下面是一个正常计算字符串的方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;locale&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置区域为中文   确保宽字符输入/输出流能正确处理中文字符。</span></span><br><span class="line">    <span class="built_in">setlocale</span>(LC_ALL, <span class="string">&quot;chs&quot;</span>);</span><br><span class="line">    <span class="type">wchar_t</span> wstr[<span class="number">255</span>]; <span class="comment">// 定义宽字符数组</span></span><br><span class="line">    std::wcout &lt;&lt; <span class="string">L&quot;请输入一个字符串: &quot;</span>;</span><br><span class="line">    std::wcin.<span class="built_in">getline</span>(wstr, <span class="number">255</span>); <span class="comment">// 使用宽字符输入</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; wstr[i] != <span class="string">L&#x27;\0&#x27;</span>; ++i) &#123; <span class="comment">// 遍历宽字符数组</span></span><br><span class="line">        ++length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::wcout &lt;&lt; <span class="string">L&quot;字符串的长度是: &quot;</span> &lt;&lt; length &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>字符串比较</strong></p><p>1️⃣ 比较相同的内容</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* str_1&#123;(<span class="type">char</span>*)<span class="string">&quot;123456&quot;</span>&#125;;</span><br><span class="line"><span class="type">char</span>* str_2&#123;(<span class="type">char</span>*)<span class="string">&quot;123456&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; (str1 == str2) &lt;&lt; std::endl;  <span class="comment">// 地址相等，进行优化之后指向相同的位置</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* str_1&#123;(<span class="type">char</span>*)<span class="string">&quot;123456&quot;</span>&#125;;</span><br><span class="line"><span class="type">char</span>* str_2 = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">7</span>];</span><br><span class="line">std::cin &gt;&gt; str_2;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; (str1 == str2) &lt;&lt; std::endl;  <span class="comment">// 输入123456  是不相等的</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string str_1&#123;<span class="string">&quot;123456&quot;</span>&#125;;</span><br><span class="line">string str_2;</span><br><span class="line"></span><br><span class="line">std::cin &gt;&gt; str_2;</span><br><span class="line">std::cout &lt;&lt; (str1 == str2) &lt;&lt; std::endl;   <span class="comment">// 手动输入123456   是相等的</span></span><br></pre></td></tr></table></figure><p>2️⃣ 比较不同的内容</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">string str_1&#123;<span class="string">&quot;abcdef&quot;</span>&#125;;</span><br><span class="line">string str_2&#123;<span class="string">&quot;bcdefg&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从第一个字符开始比较，如果比出来大小后面就不比较了</span></span><br><span class="line"><span class="keyword">if</span>(str_1 &gt; str_2)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;大于&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> std::cout &lt;&lt; <span class="string">&quot;小于等于&quot;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string str_1&#123;<span class="string">&quot;abcdef&quot;</span>&#125;;</span><br><span class="line">str<span class="number">1.</span><span class="built_in">compare</span>(<span class="string">&quot;bcdefg&quot;</span>); <span class="comment">// 返回一个int类型的值</span></span><br><span class="line"><span class="comment">// 如果str1比另外一个字符串小返回负数 -1， 如果相等返回 0  如果大于返回 1</span></span><br></pre></td></tr></table></figure><p>3️⃣ 截取一段之后进行比较</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string strA&#123;<span class="string">&quot;abc cdef&quot;</span>&#125;;</span><br><span class="line">strA.<span class="built_in">compare</span>(<span class="number">5</span>,<span class="number">4</span>,<span class="string">&quot;cdef&quot;</span>); <span class="comment">// 截取的是strA   compare(起始位置,参与比较的长度,被比较的字符串);</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string strA&#123;<span class="string">&quot;abc cdef&quot;</span>&#125;;</span><br><span class="line">strA.<span class="built_in">compare</span>(<span class="number">5</span>,<span class="number">4</span>,<span class="string">&quot;cdef ghijklm&quot;</span>, <span class="number">0</span>, <span class="number">4</span>); <span class="comment">// 前面截图的strA， 后面截取的是&quot;cdef ghijklm&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string strA&#123;<span class="string">&quot;username:5620;studentId:655555&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; strA.<span class="built_in">find</span>(<span class="string">&quot;studentId:&quot;</span>); <span class="comment">// 返回字符串的起始位置</span></span><br><span class="line">std::cout &lt;&lt; strA.<span class="built_in">substr</span>(strA.<span class="built_in">find</span>(<span class="string">&quot;studentId:&quot;</span>)); <span class="comment">// 输出  studentId:655555</span></span><br><span class="line">std::cout &lt;&lt; strA.<span class="built_in">substr</span>(strA.<span class="built_in">find</span>(<span class="string">&quot;studentId:&quot;</span>) + <span class="number">10</span>); <span class="comment">//输出655555</span></span><br></pre></td></tr></table></figure><p>补充  find()  方法 的用法</p><p><img src="https://bu.dusays.com/2024/11/21/673ee8f79c446.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.<span class="built_in">find</span>(<span class="string">&quot;sdajklfdkasjlkfjlas&quot;</span>, <span class="number">0</span>, <span class="number">10</span>); <span class="comment">//在字符串 str 中，从位置 0 开始，查找字符串 &quot;sdajklfdkasjlkfjlas&quot; 的前 10 个字符是否存在。</span></span><br></pre></td></tr></table></figure><p>倒着搜索</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示从字符串 str 的 索引 0 位置向前（从右到左查找）寻找目标字符串 &quot;sdajklfdkasjlkfjlas&quot;</span></span><br><span class="line">str.<span class="built_in">rfind</span>(<span class="string">&quot;sdajklfdkasjlkfjlas&quot;</span>, <span class="number">0</span>); </span><br></pre></td></tr></table></figure><p><strong>字符串的应用–小项目</strong></p><p><img src="https://bu.dusays.com/2024/11/21/673ef4d76891d.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string str&#123; <span class="string">&quot;id=user;pas=632105;role=阿森;&quot;</span> &#125;;</span><br><span class="line">string strIn;</span><br><span class="line">string strOut;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;请输入您要查阅的属性：\n&quot;</span>;</span><br><span class="line">std::cin &gt;&gt; strIn;</span><br><span class="line"><span class="type">int</span> lfind = str.<span class="built_in">find</span>(strIn + <span class="string">&quot;=&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (lfind == std::string::npos)</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;查找的属性不存在&quot;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> lend = str.<span class="built_in">find</span>(<span class="string">&quot;;&quot;</span>, lfind);</span><br><span class="line">strOut = str.<span class="built_in">substr</span>(lfind + strIn.<span class="built_in">length</span>() + <span class="number">1</span>, lend - lfind - strIn.<span class="built_in">length</span>() - <span class="number">1</span>);</span><br><span class="line">std::cout &lt;&lt; strOut &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>插入字符串</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法</span></span><br><span class="line">.<span class="built_in">insert</span>();</span><br><span class="line">string id&#123;<span class="string">&quot;id=;&quot;</span>&#125;;</span><br><span class="line">id.<span class="built_in">insert</span>(<span class="number">3</span>,<span class="string">&quot;testId&quot;</span>);</span><br><span class="line">std::cout &lt;&lt; id;</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/11/21/673f1c5e64bea.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法二</span></span><br><span class="line">string id&#123;<span class="string">&quot;id=&quot;</span>&#125;;</span><br><span class="line"><span class="comment">// 从索引插入6个*</span></span><br><span class="line">id.<span class="built_in">insert</span>(<span class="number">3</span>,<span class="number">6</span>,<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">std::cout &lt;&lt; id &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">id.<span class="built_in">insert</span>(<span class="number">3</span>, <span class="string">&quot;testid&quot;</span>);</span><br><span class="line">std::cout &lt;&lt; id;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string id&#123;<span class="string">&quot;id=&quot;</span>&#125;;</span><br><span class="line"><span class="comment">// 3 是从id字符串索引3开始插入，后面的第一个6是从字符串&quot;killertestid&quot;索引6开始插入6个字符到字符串id中</span></span><br><span class="line">id.<span class="built_in">insert</span>(<span class="number">3</span>,<span class="string">&quot;killertestid&quot;</span>, <span class="number">6</span>, <span class="number">6</span>);</span><br><span class="line">std::cout &lt;&lt; id &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string id&#123;<span class="string">&quot;id=&quot;</span>&#125;;</span><br><span class="line"><span class="comment">// 在id字符串索引3开始插入 ，  然后从字符串&quot;killertestid123456&quot;的k开始插入6个</span></span><br><span class="line">id.<span class="built_in">insert</span>(<span class="number">3</span>,<span class="string">&quot;killertestid123456&quot;</span>,<span class="number">6</span>);</span><br></pre></td></tr></table></figure><p><strong>指针数组字符串</strong></p><p>str和 str[0] 不是一个位置，具体跟数组有区别，涉及到运算符重载</p><p>str的地址和str[0]的地址差4</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string str&#123;<span class="string">&quot;12344&quot;</span>&#125;;</span><br><span class="line"><span class="comment">// 不转int会当作字符串来输出</span></span><br><span class="line">std::cout &lt;&lt; (<span class="type">int</span>)&amp;str &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;str[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;str[<span class="number">1</span>];</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">string str&#123;<span class="string">&quot;12345&quot;</span>&#125;;</span><br><span class="line">std::cout &lt;&lt; str[<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; (<span class="type">int</span>)&amp;str &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;str[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;str[<span class="number">1</span>] &lt;&lt; std::endl;</span><br><span class="line">str = str + <span class="string">&quot;534894539823478923&quot;</span>;</span><br><span class="line"><span class="comment">// str  跟 str[0]地址相差就很多了，需要重新分配内存地址</span></span><br><span class="line">std::cout &lt;&lt; (<span class="type">int</span>)&amp;str &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;str[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;str[<span class="number">1</span>] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .c_str() 返回的是 const char*，不能直接通过指针修改字符串内容。</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* baseStr = str.<span class="built_in">c_str</span>();</span><br><span class="line"><span class="comment">// baseStr[0] = &#x27;5&#x27;;   不允许修改</span></span><br><span class="line">std::cout &lt;&lt; (<span class="type">int</span>)&amp;str &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;str[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;str[<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (<span class="type">int</span>)baseStr &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++ 17 之后 .data()方法得到的是一个char* 的指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* dataStr = str.<span class="built_in">data</span>();</span><br><span class="line"><span class="comment">// dataStr[0] = &#x27;5&#x27;;   不允许修改</span></span><br><span class="line">std::cout &lt;&lt; (<span class="type">int</span>)&amp;str &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;str[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;str[<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (<span class="type">int</span>)baseStr &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><ul><li>返回一个 <code>const char*</code> 指针，指向以空字符 <code>\0</code> 结尾的 C 风格字符串。</li><li>返回的字符串数据与 <code>std::string</code> 对象内部保持一致，但不能修改返回值（它是 <code>const</code> 的）。</li></ul><p><strong>字符串替换</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法1</span></span><br><span class="line">.<span class="built_in">replace</span>(要替换的内容的起始位置，要替换的长度，“替换后的内容”);</span><br><span class="line"></span><br><span class="line">string strId&#123;<span class="string">&quot;id=user;&quot;</span>&#125;;</span><br><span class="line"><span class="comment">// 替换从索引 3 开始的 4 个字符为 &quot;zhangsan&quot;</span></span><br><span class="line">strId.replace&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="string">&quot;zhangsan&quot;</span>&#125;;</span><br><span class="line">std::cout &lt;&lt; strId;  <span class="comment">// id=zhangsan</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 语法2</span></span><br><span class="line">.<span class="built_in">replace</span>(要替换的内容的起始位置，要替换的长度，替换后的字符长度，‘字符’);</span><br><span class="line"><span class="comment">// 替换从索引 3 开始的 4 个字符，用 6 个 &#x27;*&#x27; 替换</span></span><br><span class="line">str.<span class="built_in">replace</span>(<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line"><span class="comment">// str的内容为：id=******</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 语法3</span></span><br><span class="line">.<span class="built_in">replace</span>(要替换的内容的起始位置，要替换的长度，<span class="string">&quot;替换后的内容&quot;</span>，替换后内容的长度节选);</span><br><span class="line"><span class="comment">// 替换从索引 3 开始的 4 个字符，用 &quot;zhangsan!pkaq&quot; 的前 8 个字符替换</span></span><br><span class="line">str.<span class="built_in">replace</span>(<span class="number">3</span>,<span class="number">4</span>,<span class="string">&quot;zhangsan!pkaq&quot;</span>,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 语法4</span></span><br><span class="line">.<span class="built_in">replace</span>(要替换的内容的起始位置，要替换的长度，<span class="string">&quot;替换后的内容&quot;</span>，替换后的内容的起始位置，替换后内容的长度节选);</span><br><span class="line"><span class="comment">// 替换从索引 3 开始的 4 个字符，用 &quot;zhangsan!pkaq&quot; 的从第9个字符开始截取，截取4个</span></span><br><span class="line">str.<span class="built_in">replace</span>(<span class="number">3</span>,<span class="number">4</span>,<span class="string">&quot;zhangsan!pkaq&quot;</span>,<span class="number">9</span>，,<span class="number">4</span>);</span><br></pre></td></tr></table></figure><p><strong>删除字符串内容</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法1</span></span><br><span class="line">.<span class="built_in">erase</span>(要删除的起始位置,要删除的起始长度);</span><br><span class="line"></span><br><span class="line">string str&#123;<span class="string">&quot;id=user;&quot;</span>&#125;;</span><br><span class="line">str.<span class="built_in">erase</span>(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line"><span class="comment">// id=;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 语法2</span></span><br><span class="line">.<span class="built_in">erase</span>(要删除的起始位置); <span class="comment">// 从起始位置开始删除所有内容</span></span><br><span class="line">string str&#123;<span class="string">&quot;id=user;&quot;</span>&#125;;</span><br><span class="line">str.<span class="built_in">erase</span>(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// id = </span></span><br><span class="line"></span><br><span class="line">.<span class="built_in">erase</span>();   <span class="comment">//删除字符串所有内容   擦除</span></span><br><span class="line">.<span class="built_in">clear</span>();   <span class="comment">//删除字符串所有内容   清零</span></span><br></pre></td></tr></table></figure><p><strong>字符串（补充）</strong></p><p>计算字符串长度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">string strIn;</span><br><span class="line">std::cin &gt;&gt; strIn;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> length&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; strIn[i]; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 在 ASCII 编码中，单字节字符（如英文、数字）均为非负数（0-127）</span></span><br><span class="line">    <span class="keyword">if</span> (strIn[i] &lt; <span class="number">0</span>) i ++ ;</span><br><span class="line">    length ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这样就能统计出字符个数了</span></span><br><span class="line">std::cout &lt;&lt; length;</span><br></pre></td></tr></table></figure><p>字符串转换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string cIn = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="type">int</span> x = std::<span class="built_in">stoi</span>(cIn); <span class="comment">// 转换成int类型</span></span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/11/21/673f31c813942.png"></p><p>字符串流</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::stringstream;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stringstream strS;</span><br><span class="line">    <span class="comment">// 这是按照16进制来输出的</span></span><br><span class="line">    strS &lt;&lt; <span class="string">&quot;你好&quot;</span> &lt;&lt; <span class="string">&quot;123 [&quot;</span> &lt;&lt; std::hex &lt;&lt; <span class="number">12530</span> &lt;&lt; <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    string strX = strS.<span class="built_in">str</span>();</span><br><span class="line">    std::cout &lt;&lt; strX;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>字符串项目</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Role</span></span><br><span class="line">&#123;</span><br><span class="line">    string Id;</span><br><span class="line">    <span class="type">int</span> Exp;</span><br><span class="line">&#125;*PROLE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string strData = <span class="string">&quot;id=Tomy Clare;exp=9523;id=Sunny;exp=9523;id=DyBaby;exp=25301;id=Simple;exp=25301;id=Bkacs11;exp=2100;id=Dudu;exp=2122;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> istart&#123;&#125;, iend&#123;&#125;, icount&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; strData.<span class="built_in">length</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (strData[i] == <span class="string">&#x27;;&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            icount++;</span><br><span class="line">            i += <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    PROLE pRole = <span class="keyword">new</span> Role[icount / <span class="number">2</span>];</span><br><span class="line">    icount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 查找到id=   则把istart 将更新为 &quot;id=&quot; 首次出现的索引</span></span><br><span class="line">        istart = strData.<span class="built_in">find</span>(<span class="string">&quot;id=&quot;</span>, istart);</span><br><span class="line">        <span class="keyword">if</span> (istart == std::string::npos) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        iend = strData.<span class="built_in">find</span>(<span class="string">&quot;;&quot;</span>, istart + <span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 从istart开始截取，截取长度就是iend-istart-3</span></span><br><span class="line">        pRole[icount].Id = strData.<span class="built_in">substr</span>(istart + <span class="number">3</span>, iend - istart - <span class="number">3</span>);</span><br><span class="line">        istart = iend + <span class="number">1</span>;</span><br><span class="line">        iend = strData.<span class="built_in">find</span>(<span class="string">&quot;;&quot;</span>, istart + <span class="number">4</span>);</span><br><span class="line">        <span class="comment">// 在这里 icount ++ 省去后面再++ 了</span></span><br><span class="line"></span><br><span class="line">        pRole[icount++].Exp = std::<span class="built_in">stoi</span>(strData.<span class="built_in">substr</span>(istart + <span class="number">4</span>, iend - istart - <span class="number">4</span>));</span><br><span class="line">        istart = iend + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 冒泡排序  经典冒泡排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; icount - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; icount - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pRole[j].Exp &lt; pRole[j + <span class="number">1</span>].Exp ||</span><br><span class="line">                (pRole[j].Exp == pRole[j + <span class="number">1</span>].Exp &amp;&amp; pRole[j].Id &gt; pRole[j + <span class="number">1</span>].Id)) &#123;</span><br><span class="line">                Role temp = pRole[j];</span><br><span class="line">                pRole[j] = pRole[j + <span class="number">1</span>];</span><br><span class="line">                pRole[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; icount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; pRole[i].Id &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pRole[i].Exp &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cpp01数组、容器指针</title>
      <link href="/2024/12/11/cpp01%E6%95%B0%E7%BB%84%E3%80%81%E5%AE%B9%E5%99%A8%E6%8C%87%E9%92%88/"/>
      <url>/2024/12/11/cpp01%E6%95%B0%E7%BB%84%E3%80%81%E5%AE%B9%E5%99%A8%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<p><strong>数组</strong>：</p><p>std::array中，可以通过at()来访问数组的内容，如果越界了就会抛出越界异常 </p><p>数组安全：由于数组的本质是向操作系统申请了一块内存，因此越界的数组将会访问到不该访问的地址，这种越界将会造成程序崩溃，BUG错误，更可怕的是，数组越界漏洞，可能会让攻击者拿到操作系统的控制权。</p><p><strong>容器</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;数据类型&gt; 变量名;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; s&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(<span class="number">5</span>)</span></span>;  <span class="comment">// 设置了5个大小的容器</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(<span class="number">5</span>,<span class="number">100</span>)</span></span>;  <span class="comment">// 这个容器拥有五个元素，每个元素的初始值为100</span></span><br></pre></td></tr></table></figure><p>容器的几个新用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">s.<span class="built_in">push_back</span>(值);  <span class="comment">//将值添加到容器末尾</span></span><br><span class="line">s.<span class="built_in">pop_back</span>();  <span class="comment">//将末尾的值删除掉</span></span><br><span class="line">s.<span class="built_in">insert</span>(s.<span class="built_in">begin</span>()<span class="number">+2</span>, <span class="number">2</span>); <span class="comment">// 在指定位置插入元素</span></span><br><span class="line">s.<span class="built_in">assign</span>(<span class="number">10</span>,<span class="number">100</span>); <span class="comment">//将s重新初始化为拥有10个元素  每个元素位100的容器</span></span><br><span class="line">s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>() + <span class="number">2</span>);   <span class="comment">// 删除指定位置的元素</span></span><br><span class="line">s.<span class="built_in">clear</span>(); <span class="comment">// 将容器清空</span></span><br><span class="line">s.<span class="built_in">empty</span>(); <span class="comment">//看看是不是空的</span></span><br></pre></td></tr></table></figure><p><strong>容器例子</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vector 遍历</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; v &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 输出元素值</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*-------------------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">// 使用引用避免拷贝</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;std::string&gt; vec = &#123;<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Charlie&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; name : vec) &#123;  <span class="comment">// 使用引用避免拷贝</span></span><br><span class="line">        name += <span class="string">&quot; (modified)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; name : vec) &#123;  <span class="comment">// 使用常量引用只读访问</span></span><br><span class="line">        std::cout &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历 map 容器</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::map&lt;std::string, <span class="type">int</span>&gt; m = &#123;&#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>&#125;, &#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">30</span>&#125;, &#123;<span class="string">&quot;Eve&quot;</span>, <span class="number">35</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// c++17及以上才可以</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [key, value] : m) &#123;  <span class="comment">// 使用结构化绑定</span></span><br><span class="line">        std::cout &lt;&lt; key &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历数组</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> num : arr) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历unordered_map</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unordered_map&lt;std::string, <span class="type">int</span>&gt; um = &#123;&#123;<span class="string">&quot;One&quot;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&quot;Two&quot;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&quot;Three&quot;</span>, <span class="number">3</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : um) &#123;</span><br><span class="line">        std::cout &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结构化绑定</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// std::pair  通过first second 来访问pair成员</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::pair&lt;<span class="type">int</span>, std::string&gt; p = &#123;<span class="number">1</span>, <span class="string">&quot;Alice&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用结构化绑定</span></span><br><span class="line">    <span class="keyword">auto</span> [id, name] = p;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ID: &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;, Name: &quot;</span> &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 输出  ID: 1, Name: Alice</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// std::tuple</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::tuple&lt;<span class="type">int</span>, <span class="type">double</span>, std::string&gt; t = &#123;<span class="number">1</span>, <span class="number">3.14</span>, <span class="string">&quot;Hello&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用结构化绑定</span></span><br><span class="line">    <span class="keyword">auto</span> [a, b, c] = t;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; c &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历std::map</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::map&lt;std::string, <span class="type">int</span>&gt; m = &#123;&#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>&#125;, &#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">25</span>&#125;, &#123;<span class="string">&quot;Charlie&quot;</span>, <span class="number">35</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [key, value] : m) &#123;  <span class="comment">// 解构键值对</span></span><br><span class="line">        std::cout &lt;&lt; key &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解构数组</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> [x, y, z] = arr;  <span class="comment">// 解构数组</span></span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; z &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解构用户自定义类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">double</span> salary;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person p = &#123;<span class="number">101</span>, <span class="string">&quot;Alice&quot;</span>, <span class="number">75000.0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> [id, name, salary] = p;  <span class="comment">// 解构绑定</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ID: &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;, Name: &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;, Salary: &quot;</span> &lt;&lt; salary &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特殊应用：非聚合类型（涉及重载）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">double</span> salary;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> i, std::string n, <span class="type">double</span> s) : <span class="built_in">id</span>(i), <span class="built_in">name</span>(n), <span class="built_in">salary</span>(s) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">struct</span> <span class="title class_">std</span>::tuple_size&lt;Person&gt;;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">auto</span> std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(<span class="type">const</span> Person&amp;) -&gt; <span class="type">int</span>;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">auto</span> std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(<span class="type">const</span> Person&amp;) -&gt; std::string;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">auto</span> std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(<span class="type">const</span> Person&amp;) -&gt; <span class="type">double</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特化 std::tuple_size 和 std::get</span></span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct</span> <span class="title class_">tuple_size</span>&lt;Person&gt; : std::integral_constant&lt;<span class="type">size_t</span>, <span class="number">3</span>&gt; &#123;&#125;;</span><br><span class="line">    <span class="keyword">template</span> &lt;&gt; <span class="keyword">auto</span> <span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(<span class="type">const</span> Person&amp; p) &#123; <span class="keyword">return</span> p.id; &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;&gt; <span class="keyword">auto</span> <span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(<span class="type">const</span> Person&amp; p) &#123; <span class="keyword">return</span> p.name; &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;&gt; <span class="keyword">auto</span> <span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(<span class="type">const</span> Person&amp; p) &#123; <span class="keyword">return</span> p.salary; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(<span class="number">101</span>, <span class="string">&quot;Bob&quot;</span>, <span class="number">85000.0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> [id, name, salary] = p;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ID: &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;, Name: &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;, Salary: &quot;</span> &lt;&lt; salary &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/11/18/673ab200dc43b.png"></p><p><strong>指针</strong></p><p> 指针语法：数据类型 * 变量名称</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指针必须初始化  指针其实就是存储的别的变量的内存地址</span></span><br><span class="line"><span class="type">int</span>* a;  <span class="comment">//指针是内存地址  建议第一种写法</span></span><br><span class="line"><span class="type">int</span> *b;  <span class="comment">//两种写法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 要操作的内存地址</span></span><br><span class="line"><span class="comment">// 要操作的内存大小</span></span><br><span class="line"><span class="type">int</span>* pa = &amp;a;</span><br></pre></td></tr></table></figure><p><strong>指针</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[]&#123; <span class="number">10001</span>,<span class="number">20001</span>,<span class="number">30001</span>,<span class="number">40001</span> &#125;;</span><br><span class="line"><span class="type">int</span>* ptr&#123; &amp;a[<span class="number">0</span>] &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指针+1是 1 * 数据类型的大小</span></span><br><span class="line">std::cout &lt;&lt; ptr &lt;&lt; std::endl;<span class="comment">//ptr的值就是a[0]的地址</span></span><br><span class="line">std::cout &lt;&lt; &amp;a[<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; *ptr &lt;&lt; std::endl;<span class="comment">//*ptr就是a[0]的值</span></span><br><span class="line">std::cout &lt;&lt; (*ptr)++ &lt;&lt; std::endl;<span class="comment">//先输出*ptr的值  为10001，然后对*ptr  加  1</span></span><br><span class="line">std::cout &lt;&lt; a[<span class="number">0</span>] &lt;&lt; std::endl;  <span class="comment">// a[0]变为10002</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;------------分界线----------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; ptr &lt;&lt; std::endl;<span class="comment">//ptr的值就是a[0]的地址</span></span><br><span class="line">std::cout &lt;&lt; *ptr++ &lt;&lt; std::endl;<span class="comment">//++的优先级高，先对ptr++，在对ptr做解引用的操作</span></span><br><span class="line">std::cout &lt;&lt; a[<span class="number">0</span>] &lt;&lt; std::endl;<span class="comment">// a[0]的值不变</span></span><br><span class="line">std::cout &lt;&lt; *ptr &lt;&lt; std::endl;<span class="comment">//ptr进行加一操作之后，指向a[1],  输出20001</span></span><br><span class="line">std::cout &lt;&lt; ptr &lt;&lt; std::endl;<span class="comment">//ptr的值增加了一个int类型的大小，4个字节</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;------------分界线----------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指针的指针，指针也是个变量，本身也有地址，现在要操作ptr的内存</span></span><br><span class="line"><span class="comment">//不考虑前面进行的操作</span></span><br><span class="line"><span class="type">int</span>** pptr&#123; &amp;ptr &#125;;<span class="comment">//这样定义就是指针的指针</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;数组a[0]的地址为： &quot;</span> &lt;&lt; ptr &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;数组a[0]的地址为： &quot;</span> &lt;&lt; &amp;a[<span class="number">0</span>] &lt;&lt; std::endl;<span class="comment">//这里ptr和&amp;a[0]输出的相同</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;ptr的地址为：&quot;</span> &lt;&lt; pptr &lt;&lt; std::endl;<span class="comment">//这里输出ptr的地址</span></span><br><span class="line">std::cout &lt;&lt; *pptr &lt;&lt; std::endl;<span class="comment">//*pptr解引用pptr，得到ptr的值，即a[0]地址</span></span><br><span class="line">std::cout &lt;&lt; **pptr &lt;&lt; std::endl;<span class="comment">//**pptr进一步解引用，得到a[0]的值</span></span><br><span class="line"></span><br><span class="line">*pptr = &amp;a[<span class="number">1</span>];</span><br><span class="line">std::cout &lt;&lt; *pptr &lt;&lt; std::endl;<span class="comment">//使用*pptr把ptr的值改成a[1]数组的内存地址</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//类似的，可以定义下面这种</span></span><br><span class="line"><span class="type">int</span>*** ppptr&#123; &amp;pptr &#125;;</span><br><span class="line">std::cout &lt;&lt; ***ppptr &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;------------分界线----------------&quot;</span> &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/11/13/6734530db4262.png"></p><p><strong>常量指针</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//const 变量类型*  只能指向一个常量</span></span><br><span class="line"><span class="comment">// 特点，指针的指向可以修改，但是指针指向的值不可以修改</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a&#123; <span class="number">100</span> &#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b&#123; <span class="number">200</span> &#125;;</span><br><span class="line"><span class="type">int</span> c&#123; <span class="number">300</span> &#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* p&#123; &amp;a &#125;;</span><br><span class="line"><span class="comment">// *p = 500;  不可以修改值</span></span><br><span class="line">std::cout &lt;&lt; *p &lt;&lt; std::endl;</span><br><span class="line">p = &amp;b;  <span class="comment">// 可以修改指向</span></span><br><span class="line">p = &amp;c;  <span class="comment">// 常量指针也可以指向非常量变量</span></span><br><span class="line"><span class="comment">// *p = 2000;  常量指针就是不让改</span></span><br></pre></td></tr></table></figure><p><strong>指针常量</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//特点：指针的指向不可以改，指针指向的值可以改（内存中的数据可以更改）</span></span><br><span class="line"><span class="type">int</span> a&#123; <span class="number">100</span> &#125;;</span><br><span class="line"><span class="type">int</span> b&#123; <span class="number">200</span> &#125;;</span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> p&#123; &amp;a &#125;;</span><br><span class="line"><span class="comment">//p = &amp;b;   不能修改指向</span></span><br><span class="line">*p = <span class="number">999</span>;  <span class="comment">//可以修改指针指向的内存空间</span></span><br><span class="line">std::cout &lt;&lt; a &lt;&lt; std::endl; <span class="comment">//  这时候a输出 999；</span></span><br></pre></td></tr></table></figure><p><strong>指向常量的常量指针</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//const 变量类型* const</span></span><br><span class="line"><span class="comment">//特点：指针的指向和指针指向的值都不可以修改 </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a&#123; <span class="number">100</span> &#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b&#123; <span class="number">200</span> &#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> p&#123; &amp;a &#125;;</span><br><span class="line"><span class="comment">//p = &amp;b;  不能修改指向</span></span><br><span class="line"><span class="comment">//*p = 999;  不能修改内存空间里面的值</span></span><br></pre></td></tr></table></figure><p><strong>补充（指针有关的类型转换 ）</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a&#123; <span class="number">100</span> &#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b&#123; <span class="number">200</span> &#125;;</span><br><span class="line"><span class="comment">//int* pa&#123; &amp;a &#125;;   常量</span></span><br><span class="line"><span class="type">int</span>* pa&#123; (<span class="type">int</span>*)&amp;a &#125;;   <span class="comment">//通过转换是可以的</span></span><br><span class="line">*p = <span class="number">9500</span>;<span class="comment">//这种操作是允许的，但是a的值不变</span></span><br><span class="line">std::cout &lt;&lt; *pa &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p><strong>指针数组补充</strong></p><p>指针数组是<strong>一个数组</strong>，数组的每个元素都是指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p[<span class="number">5</span>];</span><br></pre></td></tr></table></figure><p> p 是一个包含5个指针的数组。  每个指针可以指向一个int类型的变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>, c = <span class="number">30</span>;</span><br><span class="line"><span class="type">int</span>* p[<span class="number">3</span>];</span><br><span class="line">p[<span class="number">0</span>] = &amp;a;</span><br><span class="line">p[<span class="number">1</span>] = &amp;b;</span><br><span class="line">p[<span class="number">2</span>] = &amp;c;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过指针数组来访问变量。</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = %d, b = %d, c = %d&quot;</span>, *p[<span class="number">0</span>], *p[<span class="number">1</span>], *p[<span class="number">2</span>]);</span><br><span class="line"><span class="comment">// p[0] 是第一个指针， *p[0] 则访问指针指向的内容。</span></span><br></pre></td></tr></table></figure><p>数组指针 是<strong>一个指针</strong>，它指向一个数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> (*p)[<span class="number">5</span>];</span><br></pre></td></tr></table></figure><p>p 是一个指针，指向包含5个整型元素的数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">int</span> (*p)[<span class="number">5</span>];</span><br><span class="line">p = &amp;a;   <span class="comment">// p 指向 数组 a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样来访问数组 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;First element: %d\n&quot;</span>, (*p)[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Second element: %d\n&quot;</span>, (*p)[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><p>数组指针是一个指针，它指向整个数组。</p><p>使用*p 解引用数组指针，可以获得数组本身， 然后可以通过下标操作访问数组元素。</p><p>数组指针在多维数组操作中非常常用。  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>]&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="type">int</span>* ptrA&#123; a &#125;;</span><br><span class="line"><span class="type">int</span>* ptrB&#123; &amp;a[<span class="number">0</span>] &#125;;   <span class="comment">//从汇编语言得出，a放的就是a[0]的地址</span></span><br><span class="line"><span class="type">int</span>* ptrC&#123; a + <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; ptrC[<span class="number">1</span>] &lt;&lt; std::endl;  <span class="comment">//输出的 是3</span></span><br><span class="line">std::cout &lt;&lt; ptrA[<span class="number">1</span>] &lt;&lt; std::endl;  <span class="comment">//也可以这样访问a[1]</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt;std::endl;  <span class="comment">//输出大小是20  处理a的时候把它当作数组处理</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sizeof</span>(ptrA) &lt;&lt;std::endl; <span class="comment">//输出大小是4</span></span><br><span class="line"><span class="comment">//底层来说a是个指针，明面上还是数组</span></span><br><span class="line"><span class="comment">//指针可以当数组来用，数组可以当指针来读</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//多维数组在内存中不存在，只是我们告诉内存这么访问而已</span></span><br><span class="line"><span class="type">int</span> test[<span class="number">2</span>][<span class="number">5</span>]</span><br><span class="line">&#123;</span><br><span class="line">&#123;<span class="number">1001</span>,<span class="number">1002</span>,<span class="number">1003</span>,<span class="number">1004</span>,<span class="number">1005</span>&#125;,</span><br><span class="line">&#123;<span class="number">2001</span>,<span class="number">2002</span>,<span class="number">2003</span>,<span class="number">2004</span>,<span class="number">2005</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span>* ptest&#123; (<span class="type">int</span>*)test &#125;;</span><br><span class="line">std::cout &lt;&lt; test[<span class="number">1</span>][<span class="number">4</span>] &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; ptest[<span class="number">9</span>] &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> test[<span class="number">2</span>][<span class="number">5</span>]</span><br><span class="line">&#123;</span><br><span class="line">&#123;<span class="number">1001</span>,<span class="number">1002</span>,<span class="number">1003</span>,<span class="number">1004</span>,<span class="number">1005</span>&#125;,</span><br><span class="line">&#123;<span class="number">2001</span>,<span class="number">2002</span>,<span class="number">2003</span>,<span class="number">2004</span>,<span class="number">2005</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* ptestA[<span class="number">5</span>]; <span class="comment">//  指针数组，  5个int类型的指针</span></span><br><span class="line"><span class="built_in">int</span> (*ptest)[<span class="number">5</span>]&#123;test&#125;;<span class="comment">//  首先是一个指针，类型是数组指针，每一行能存储5个数据</span></span><br><span class="line">ptest = ptest + <span class="number">1</span>;</span><br><span class="line">std::cout &lt;&lt; ptest &lt;&lt; std::endl; <span class="comment">//比原来增加了6 * int 的大小，因为ptest是个数组指针，逻辑是6</span></span><br><span class="line">std::cout &lt;&lt; ptest[<span class="number">0</span>][<span class="number">1</span>] &lt;&lt; std::endl; <span class="comment">//数组指针可以使用二维数组的方式访问数据</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sizeof</span>(ptest) &lt;&lt; std::endl;  <span class="comment">//大小是4字节 ，所以ptest就是个指针，不是数组</span></span><br></pre></td></tr></table></figure><p><strong>数组再补充</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> test[<span class="number">2</span>][<span class="number">5</span>]</span><br><span class="line">&#123;</span><br><span class="line">&#123;<span class="number">1001</span>,<span class="number">1002</span>,<span class="number">1003</span>,<span class="number">1004</span>,<span class="number">1005</span>&#125;,</span><br><span class="line">&#123;<span class="number">2001</span>,<span class="number">2002</span>,<span class="number">2003</span>,<span class="number">2004</span>,<span class="number">2005</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; test[<span class="number">0</span>] &lt;&lt; std::endl; <span class="comment">//这是个地址</span></span><br><span class="line"><span class="comment">//a + [] * int</span></span><br></pre></td></tr></table></figure><p><strong>C语言内存分配</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(x * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="type">int</span>* pa = (<span class="type">int</span>*)<span class="built_in">calloc</span>(x, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;------------------------&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="type">int</span>* p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">4</span>);</span><br><span class="line">p = (<span class="type">int</span>*)<span class="built_in">realloc</span>(p, <span class="number">8</span>);  <span class="comment">//重新分配了大小,原来输入的值还在</span></span><br><span class="line"><span class="comment">//原来分配了100，后面更改为50，那内存地址不会变</span></span><br><span class="line"><span class="comment">//原来分配了100，后面改成200，内存地址会变，但是会把原来的内存的内容拷贝到新的内存中</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="built_in">free</span>(pa);</span><br><span class="line"></span><br><span class="line"><span class="comment">//p 和 pa的值成了悬挂指针，</span></span><br><span class="line"><span class="comment">//所以free之后改成p = 0, pa = 0;</span></span><br></pre></td></tr></table></figure><p><strong>C++内存分配</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据类型* 指针变量名称 = new 数据类型;</span></span><br><span class="line"><span class="type">int</span>* pa = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="comment">//数据类型* 指针变量名称 = new 数据类型[数量];</span></span><br><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">---------------------------------------------------</span><br><span class="line">p = <span class="keyword">new</span> <span class="type">int</span>[x];</span><br><span class="line">*p = <span class="number">500</span>;</span><br><span class="line">p[<span class="number">0</span>] = <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//两种释放内存的方式，不要混用</span></span><br><span class="line"><span class="keyword">delete</span> pa;</span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--------------------------------------------------</span><br><span class="line"><span class="comment">//内存复制</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">5</span>]&#123;<span class="number">1001</span>,<span class="number">1002</span>,<span class="number">1003</span>,<span class="number">1004</span>,<span class="number">1005</span>&#125;;</span><br><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(p,a,<span class="number">5</span>*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置内存</span></span><br><span class="line"><span class="comment">//memset 可以指定内存区域每一个字节的值都设置为val,</span></span><br><span class="line"><span class="type">int</span>* pa = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">100</span>];</span><br><span class="line"><span class="comment">//这里就是设置成0 了</span></span><br><span class="line"><span class="built_in">memset</span>(p,<span class="number">0</span>,<span class="number">100</span>*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">meeset</span><span class="params">(<span class="type">void</span>* _dst, <span class="type">int</span> val, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"><span class="comment">// val范围是0x 00 --- 0x ff   如果设置0x1234，那么只会保存34</span></span></span><br><span class="line"><span class="function"><span class="comment">//memset可以将指定内存区域每一个字节都设置为val，_size为要设置的长度（字节）</span></span></span><br></pre></td></tr></table></figure><p>使用动态内存分配风险</p><p>如果释放内存后没有清零，很危险，使用new可能会报错</p><p>重复释放</p><p>内存碎片</p><p>不推荐C语言和C++释放内存的语句混用</p><p><strong>引用</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据类型&amp; 变量名称&#123;引用对象的名称&#125;;</span></span><br><span class="line"><span class="comment">//引用类型一定要初始化，就相当于一个别名</span></span><br><span class="line"><span class="type">int</span> a&#123;<span class="number">500</span>&#125;;</span><br><span class="line"><span class="type">int</span> b&#123;<span class="number">100</span>&#125;;</span><br><span class="line"><span class="type">int</span>&amp; la&#123;a&#125;;</span><br><span class="line">la = <span class="number">500</span>; <span class="comment">// 相当于 a = 500;</span></span><br><span class="line"><span class="comment">//它们所有的地址都是一样的</span></span><br><span class="line"><span class="comment">//引用设置之后就不能更改了</span></span><br><span class="line"></span><br><span class="line">la = b; <span class="comment">// a 的值编程了100</span></span><br></pre></td></tr></table></figure><p><strong>智能指针</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;<span class="type">int</span>[]&gt; intPtr&#123;std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>[]&gt;(<span class="number">5</span>)&#125;;  <span class="comment">// 是有五个这种变量</span></span><br><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; intPtrA&#123;std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">5</span>)&#125;;     <span class="comment">// 把指针初始化为5</span></span><br><span class="line"></span><br><span class="line">intPtr.<span class="built_in">reset</span>();  <span class="comment">// 将指针地址清零，然后把内存空间还给操作系统</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* a = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>];</span><br><span class="line">a = intPtr.<span class="built_in">get</span>();  <span class="comment">// 将intPtr的内存地址赋值给a</span></span><br><span class="line"></span><br><span class="line">a = intPtr.<span class="built_in">release</span>();  <span class="comment">// 把指针设置为0，但还会范围占用内存的地址</span></span><br></pre></td></tr></table></figure><p><strong>智能指针的转移</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;<span class="type">int</span>[]&gt; intPtr&#123;std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>[]&gt;(<span class="number">5</span>)&#125;; </span><br><span class="line">std::unique_ptr&lt;<span class="type">int</span>[]&gt; intPtrA&#123;&#125;;  </span><br><span class="line"></span><br><span class="line">intPtrA = std::<span class="built_in">move</span>(intPtr);  <span class="comment">// intPtr被清零了，失效了，intPtrA指向原来intPtr指向的位置</span></span><br></pre></td></tr></table></figure><p><strong>共享智能指针</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* a&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//语法</span></span><br><span class="line">std::shared_ptr&lt;类型&gt; 变量名称&#123;&#125;;</span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; ptrA&#123;&#125;; <span class="comment">// 设置为空</span></span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; ptrB&#123;std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">5</span>)&#125;; <span class="comment">//将这个指针初始化为5</span></span><br><span class="line"><span class="comment">//std::make_shared不支持数组</span></span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>[]&gt; ptrC&#123;<span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;&#125;;</span><br><span class="line">std::cout &lt;&lt; ptrA &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ptrC[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; *ptrB;</span><br><span class="line"><span class="comment">/*----------------------------------------------------*/</span></span><br><span class="line"><span class="comment">//如何共享</span></span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; ptrA&#123;std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">5</span>)&#125;;</span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; ptrB&#123;ptrA&#125;;</span><br><span class="line"><span class="comment">//两个指针可以指向同一个地方</span></span><br><span class="line">std::cout &lt;&lt; ptrB &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; *ptrB &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; ptrA &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; *ptrA;</span><br><span class="line"></span><br><span class="line"><span class="comment">//假设有  A  B C  三个指针指向这块区域，只有当所有的指针都释放了，才会释放内存空间</span></span><br><span class="line"><span class="comment">// 会有一个计数器，来记录有几个指针指向这块区域</span></span><br><span class="line"><span class="type">long</span> std::shared_ptr.<span class="built_in">use_count</span>(); <span class="comment">// .use_count() 会返回当前指针共有多少个对象调用</span></span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; ptrA.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//会将当前共享指针设置为空，同时如果当前智能指针是最后一个拥有该指针的对象，那么将释放内存。</span></span><br><span class="line">std::shared_ptr.<span class="built_in">reset</span>();</span><br><span class="line"></span><br><span class="line">ptrB.<span class="built_in">reset</span>();</span><br><span class="line">std::cout &lt;&lt; ptrB &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//*ptrB使用不了，因为被释放了</span></span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/11/16/67389b688486f.png"></p><p><strong>指针和结构体</strong></p><p>通过指针访问自定义数据类型（基础部分）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Role</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> HP;</span><br><span class="line">    <span class="type">int</span> MP;</span><br><span class="line">&#125;* PRole;</span><br><span class="line"><span class="comment">// 上面不写*号相当于给Role改了个名字，写了*号就是类型指针的意思</span></span><br><span class="line"><span class="comment">//以前声明指针需要Role*    现在只需要PRole即可</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Role user;</span><br><span class="line">    PRole puser = &amp;user;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  使用指针偏移来访问数据</span></span><br><span class="line">    puser-&gt;HP = <span class="number">50</span>;</span><br><span class="line">    puser-&gt;MP = <span class="number">100</span>;</span><br><span class="line">    user.HP = <span class="number">50</span>;</span><br><span class="line">    user.MP = <span class="number">50</span>;</span><br><span class="line">    std::cout &lt;&lt; (*puser).HP &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; puser-&gt;HP &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>内存对齐问题</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Role</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> op;</span><br><span class="line">    <span class="type">int</span> HP;</span><br><span class="line">    <span class="type">int</span> MP;</span><br><span class="line">    <span class="type">short</span> x;</span><br><span class="line">    <span class="type">short</span> x1;</span><br><span class="line">&#125;* PRole;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Role user;</span><br><span class="line">    PRole puser = &amp;user;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span>(Role);</span><br><span class="line">    <span class="comment">// 注销掉 x1 和不注销 x1 的结果是一样的，这里涉及到内存对齐问题。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内存对齐是指在内存中存储数据时，数据的起始地址按特定的规则对齐，而不是任意的内存地址。</p><ul><li>目的：提高 CPU 访问内存的效率，因为现代 CPU 通常按字节、字或更大单位（如 4 字节或 8 字节）读取内存。</li><li>结果：可能会在数据之间引入填充字节（padding），以满足对齐规则</li></ul><p>对齐原则</p><p>每个成员的地址必须是<strong>对齐系数</strong>的整数倍。</p><ul><li>对齐系数 &#x3D; <strong>成员大小</strong> 或 <strong>默认对齐数</strong>，取较小值。</li></ul><p>结构体总大小必须是<strong>结构体最大对齐系数</strong>的倍数。</p><p><u>指定几个字节对齐</u></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(2)  <span class="comment">// 指定 2 字节对齐</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">short</span> c;</span><br><span class="line">&#125;PackedExample;</span><br><span class="line"><span class="meta">#packma pack(); <span class="comment">// 恢复默认对齐</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//直接输出这个结构体占据的大小</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(PackedExample): %zu\n&quot;</span>, <span class="built_in">sizeof</span>(PackedExample));</span><br></pre></td></tr></table></figure><p><strong>指针安全</strong></p><p>悬挂指针和野指针</p><ol><li><p><strong>悬挂指针</strong>: 悬挂指针产生于指针所指向的内存已被释放或者失效后，指针本身没有及时更新或清空。在该内存释放之后，任何通过这个悬挂指针的引用或操作都是不安全的，因为这块内存可能已经重新分配给了其他的数据。</p><p>示例：当一个指针指向动态分配（比如使用<code>malloc</code>或<code>new</code>）的内存，并且随后该内存被释放掉（使用<code>free</code>或<code>delete</code>），而没有将指针设置为<code>NULL</code>，此时这个指针就变成了悬挂指针。</p></li><li><p><strong>野指针</strong>: 野指针通常是指未初始化的指针，它没有被设置为任何有效的地址。由于它可能指向任意位置，对野指针的解引用是危险的，并且可能会导致难以预测的行为甚至程序崩溃。</p><p>示例：声明了一个指针变量但是没有给它赋予确定的初始值，然后就开始使用这个指针。</p></li></ol><p>尽管两者看似相似，但是产生原因和解决方式有所不同：</p><ul><li><strong>悬挂指针问题</strong>可以通过确保指针在释放关联的内存资源后立即被设为<code>NULL</code>来避免。</li><li><strong>野指针问题</strong>则需要确保每个指针变量在使用前都被明确初始化为一个合法的地址或<code>NULL</code>。</li></ul><p>处理这两种类型的指针时，编程中的最佳实践是始终确保你的指针在声明后得到适当的初始化，在资源被释放之后更新状态，并且在解引用之前检查其有效性。</p><p>指针存在的俩问题：</p><p>1️⃣ 指针没有了，内存空间还在</p><p>2️⃣ 内存空间释放了，指针还有</p><p>野指针（悬挂指针）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 野指针</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>* p;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span>* a = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>];</span><br><span class="line">        p = a;</span><br><span class="line">        a[<span class="number">2</span>] = <span class="number">555</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; p[<span class="number">2</span>]; <span class="comment">// 内存空间还在，没有释放</span></span><br><span class="line">    <span class="comment">// 这就是野指针  （悬挂指针）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改正方法：使用 智能指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p;</span><br><span class="line">&#123;</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>[]&gt; a&#123; std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>[]&gt;(<span class="number">50</span>) &#125;;</span><br><span class="line">    a[<span class="number">2</span>] = <span class="number">250</span>;</span><br><span class="line">    p = a.<span class="built_in">get</span>();</span><br><span class="line">    std::cout &lt;&lt; p[<span class="number">2</span>];  <span class="comment">// 输出250</span></span><br><span class="line">&#125; <span class="comment">// 括号结束后，内存空间会释放掉</span></span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; p[<span class="number">2</span>]; <span class="comment">// 输出-572662307,  说明内存空间被释放了</span></span><br></pre></td></tr></table></figure><p>另外一种情况，存在栈里面，括号  之后栈空间没有被回收（如果分配到函数里面，那么就不会出现这种问题）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    p = a;</span><br><span class="line">    std::cout &lt;&lt; p[<span class="number">0</span>] &lt;&lt; std::endl;  <span class="comment">// 输出1</span></span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; p[<span class="number">0</span>] &lt;&lt; std::endl;  <span class="comment">// 输出1</span></span><br></pre></td></tr></table></figure><p>内存空间释放了，但是指针还在</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>* a = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>];</span><br><span class="line">    p = a;</span><br><span class="line">    std::cout &lt;&lt; p[<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">delete</span>[] a;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; p[<span class="number">0</span>];   <span class="comment">// p指针还在</span></span><br></pre></td></tr></table></figure><p>补充知识：.get()函数</p><p>1️⃣std::shared_ptr<code>和</code>std::unique_ptr    在智能指针中，.get() 用于获取所管理的原始指针。返回指正指针内部所管理的原始指针，但不会更改其所有权或者生命周期管理。</p><p>2️⃣在输入流(std::istream)中，.get()用于从输入流中读取字符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 程序示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">std::istringstream <span class="title">input</span><span class="params">(<span class="string">&quot;HEllo World&quot;</span>)</span></span>;</span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="keyword">while</span> (input.<span class="built_in">get</span>(c))  std::cout &lt;&lt; c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>堆和栈</strong></p><p>堆的本质就是空闲内存，C++中把堆称为自由存储区，只要是你的程序加载后，没有占用空闲的内存，都是自由存储区，我们用new或者malloc申请的一块新内存区域，都是操作系统从堆上操作的。</p><p>栈是程序编译时就已经确定大小的一段内存区域，主要是用于临时变量的存储，栈的效率高于堆，但是容量有限.</p><p><strong>汇编知识（补充）</strong></p><p>在汇编语言中，<code>LEA</code>（Load Effective Address）指令用于将一个内存地址加载到寄存器中，而不是直接访问该内存地址的值。简单来说，<code>LEA</code> 计算内存地址的有效值，并将其存入目标寄存器，而不是从该内存地址加载数据。</p>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>会议记录</title>
      <link href="/2024/12/11/%E4%BC%9A%E8%AE%AE%E8%AE%B0%E5%BD%95/"/>
      <url>/2024/12/11/%E4%BC%9A%E8%AE%AE%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h3 id="2024-11-11-第一次会议"><a href="#2024-11-11-第一次会议" class="headerlink" title="2024.11.11  第一次会议"></a>2024.11.11  第一次会议</h3><p>没有回答好的内容：</p><p>ASCII、Unicode编码，enum 和 enum class的区别</p><ol><li><strong>ASCII、Unicode编码</strong></li></ol><p>ASCII码使用指定的7位或者8位二进制数组合来表示128或256种可能的字符。标准的ASCII码使用7位二进制数(剩下一位二进制位0)来表示所有的大写字母和小写字母，数字0-9、标点符号，以及在美式英语中使用的特殊控制字符。最后一位用于奇偶校验。</p><p>ASCII是单字节编码，无法用来表示中文，所以中国制定了GB2312编码，把中文编进去。</p><p>Unicode：把所有的语言都统一到一套编码里面，这样就不会有乱码的问题。最常用的是用两个字节表示一个字符（偏僻的字符使用4个字节）</p><p>UTF8  可变长编码，把一个Unicode字符根据不同的数字大小编码成1-6字节，常用的英文字母被编码成 1个字节，汉字通常是三个字节，只有生僻字才被编码成4-6个字节。传输的文本含有大量英文，使用UTF-8编码就能节省空间。</p><p><img src="https://bu.dusays.com/2024/11/13/6734516268bb0.png" alt="image-20241112124850995"></p><p><img src="https://bu.dusays.com/2024/11/13/673451626be7b.png"></p><ol start="2"><li><strong>enum 与 enum class</strong></li></ol><p>enum被称为不限定范围的枚举，enum class被称为限定范围的枚举</p><p>1️⃣enum是传统的枚举类型：</p><p>​枚举值可以隐式转换成整数。</p><p>​作用域：enum中的成员是全局的，可能导致名字冲突。两个枚举类型定义了相同的枚举变量名字，就会出现错误。</p><p>​类型安全：不具备严格的类型安全，无意中与整数或其他枚举类型混用。</p><p>2️⃣enum class</p><p>​作用域：enum class中的成员是局部与枚举类型本身的，不会造成名字冲突</p><p>​显示转换：要将enum class 的成员转换成整数，必须使用static_cast</p><p>​类型安全：enum class 更加安全，枚举值不会隐式转换为整数，必须显示转换</p><ol start="3"><li><p>goto什么时候不能跳？</p><p>1️⃣跳转进入其他作用域：<code>goto</code>不能跳转到一个不同作用域的标签。例如，不能从外部作用域跳转进入一个函数内部，或从循环或条件语句外部跳入其内部。</p><p>2️⃣跨越对象的初始化：如果跳转会导致跨越具有非平凡析构函数的对象的初始化，则会出现编译错误。这是因为跳过对象初始化可能导致未定义行为，例如资源未正确分配。</p><p>3️⃣代替结构化控制语句：<code>goto</code>语句通常不应当代替<code>for</code>、<code>while</code>、<code>do-while</code>等结构化控制语句，因为这样会使代码更难理解和维护。应优先使用这些结构化的循环和分支结构。</p><p>4️⃣跨越内存管理代码块，在C++中，管理内存（如<code>new</code>和<code>delete</code>）时不宜使用<code>goto</code>，因为容易导致资源泄露。用<code>goto</code>跳过特定的代码可能导致内存或资源未释放。</p></li></ol><h3 id="2024-11-18-第二次会议"><a href="#2024-11-18-第二次会议" class="headerlink" title="2024.11.18  第二次会议"></a>2024.11.18  第二次会议</h3><p>没有回答好的问题：智能指针、左值右值</p><ol><li><strong>智能指针</strong></li></ol><p>智能指针是C++ 中用于自动管理动态内存的对象。它是一种特殊的类，通过封装普通指针的行为，实现自动资源管理（内存释放），从而避免常见的内存泄露和悬垂指针问题。</p><p>1️⃣ 独占型智能指针 std::unique_ptr</p><p>独占所有权，同一时间只能有一个std::unique_ptr管理某个资源，适用于需要明确表示所有权的场景。<strong>不可复制，但可以转移所有权</strong>。</p><p>示例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; ptr1 = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);  <span class="comment">// 分配内存并赋值</span></span><br><span class="line">    std::cout &lt;&lt; *ptr1 &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//std::unique_ptr&lt;int&gt; ptr2 = ptr1; 错误的  不允许复制</span></span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; ptr2 = std::<span class="built_in">move</span>(ptr1); <span class="comment">// 转移所有权</span></span><br><span class="line">    <span class="keyword">if</span> (!ptr1)</span><br><span class="line">    &#123;</span><br><span class="line">        std::unique_ptr&lt;<span class="type">int</span>&gt; ptr2 = std::<span class="built_in">move</span>(ptr1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2️⃣ std::shared_ptr</p><p>共享所有权，多个std::shared_ptr可以共享同一种资源。适用于多个对象需要访问同一资源的场景。使用计数管理资源。引用计数为0时，资源才会被释放。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; ptr1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">20</span>); <span class="comment">// 分配内存 </span></span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; ptr2 = ptr1; <span class="comment">// 共享所有权</span></span><br><span class="line">    std::cout &lt;&lt; *ptr1 &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; *ptr2 &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    ptr<span class="number">1.</span><span class="built_in">reset</span>(); <span class="comment">// 释放ptr1对资源的引用</span></span><br><span class="line">    <span class="keyword">if</span> (!ptr1)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ptr1 is null, but ptr2 still owns the resource.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3️⃣ std::weak_ptr</p><p>弱引用，不参与引用计数管理。解决std::share_ptr的循环引用的问题。需要使用lock() 方法将 std::weak_ptr 转化为 std::shared_ptr来访问资源。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; sharedPtr = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">30</span>);</span><br><span class="line">    std::weak_ptr&lt;<span class="type">int</span>&gt; weakPtr = sharedPtr;  <span class="comment">// 弱引用, 不增加引用计数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> lockedPtr = weakPtr.<span class="built_in">lock</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; *lockedPtr &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Resource is no longer available.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sharedPtr.<span class="built_in">reset</span>(); <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> lockedPtr = weakPtr.<span class="built_in">lock</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; *lockedPtr &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Resource is no longer available.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>智能指针的<strong>优点</strong>：自动释放内存， 减少new&#x2F;delete带来的麻烦。  避免内存泄露和悬垂指针问题。  代码更简洁、更安全。  <strong>用途</strong>：动态内存分配时，确保资源被独占管理且使用完成后自动释放。管理不需要共享的资源，如文件句柄、单线程对象等。</p><p>注意事项：</p><p>1️⃣ 不要同时使用普通指针和智能指针管理统一资源</p><p>2️⃣ std::shared_ptr 可能带来性能开销 (由于引用计数管理)。</p><p>3️⃣ std::weak_ptr 解决 std::shared_ptr的循环引用问题 。</p><p><strong>循环引用问题</strong> 是指在使用智能指针（尤其是 <code>std::shared_ptr</code>）时，由于两个或多个对象互相引用对方，导致引用计数永远无法降为零，资源无法释放，造成 <strong>内存泄漏</strong> 的问题。</p><ol start="2"><li>左值和右值</li></ol><p>左值（lvalue, locator value）表示了一个占据内存中某个可识别的位置（也就是一个地址）的对象。</p><p>右值（rvalue）则使用排除法来定义。一个表达式不是 左值 就是 右值 。那么，右值是一个 不表示内存中某个可识别位置的对象的表达式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> var;</span><br><span class="line">var = <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>赋值操作需要左操作数是一个左值。var是一个有内存位置的对象，因此它是左值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> = var;</span><br><span class="line">(var + <span class="number">1</span>) = <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>常量 4 和表达式 var +  1 都不是左值，因为它们都是表达式的临时结果，而没有可识的内存位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="number">2</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 错误，foo返回的是一个临时的值。它是一个右值，赋值给它是错误的。</span></span><br><span class="line">    <span class="built_in">foo</span>() = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> globalvar = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">foo</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> globalvar;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>() = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里foo返回一个引用。引用了一个左值，因此可以赋值给它。</p><p>C++ 中函数可以返回左值的功能对实现一些重载的操作符非常重要。下面是重载方括号操作符[]，来实现一些查找访问的操作，如std::map 中的方括号。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;<span class="type">int</span>, <span class="type">float</span>&gt; mymap;</span><br><span class="line">mymap[<span class="number">10</span>] = <span class="number">5.6</span>;</span><br></pre></td></tr></table></figure><p>之所以能赋值给mymap[10], 是因为std::map::operator[] 的重载返回的是一个可赋值的引用。</p><p><strong>可修改的左值</strong></p><p>可以出现在赋值操作左边的值，但是加入const关键字后，这个定义不再成立</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;  <span class="comment">// &#x27;a&#x27; 是左值</span></span><br><span class="line">a = <span class="number">10</span>;   <span class="comment">// 但不可以赋值给它</span></span><br></pre></td></tr></table></figure><p>所以可赋值的左值被称为 可修改左值. C99标准定义可修改左值为:</p><p>可修改左值是特殊的左值，不含有数组类型、不完整类型、const 修饰的类型。如果它是 <code>struct</code> 或 <code>union</code>，它的成员都（递归地）不应含有 const 修饰的类型。</p><p><strong>左值与右值的转换</strong></p><p>左值可以转成右值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;     <span class="comment">// a 是左值</span></span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>;     <span class="comment">// b 是左值</span></span><br><span class="line"><span class="type">int</span> c = a + b; <span class="comment">// + 需要右值，所以 a 和 b 被转换成右值</span></span><br><span class="line">               <span class="comment">// + 返回右值</span></span><br></pre></td></tr></table></figure><p>右值不可以转成左值,因为违反了左值的本质.  但是右值可以通过显式的方法产生左值. </p><p>例如, 一元解引用运算符 ‘*’ 需要一个右值参数, 但返回一个左值结果. </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span>* p = &amp;arr[<span class="number">0</span>];</span><br><span class="line">*(p + <span class="number">1</span>) = <span class="number">10</span>;   <span class="comment">//p + 1是右值,   但*(p + 1) 是左值</span></span><br></pre></td></tr></table></figure><p>相反的,一元去地址操作符’&amp;’ 需要一个左值参数,返回一个右值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> var = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* b_arr = &amp;(var + <span class="number">1</span>);  <span class="comment">// &amp;  需要左值参数</span></span><br><span class="line"><span class="type">int</span>* addr = &amp;var;    <span class="comment">// 正确,  var是左值</span></span><br><span class="line">&amp;var = <span class="number">40</span>;   <span class="comment">//错误, 赋值操作的左操作数需要的是左值</span></span><br></pre></td></tr></table></figure><p>‘&amp;’ 符号还有另一个功能—–定义引用类型.  引用类型又叫做”左值引用”.  因此不能将一个右值赋值给(非常量的) 左值引用:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::string&amp; sref = std::<span class="built_in">string</span>();  <span class="comment">// 错误: 非常量的引用 &#x27;std::string&amp;&#x27; 错误地使用右值 &#x27;std::string&#x27; 初始化</span></span><br></pre></td></tr></table></figure><p><em>常量的</em> 左值引用可以使用右值赋值。因为你无法通过常量的引用修改变量的值，也就不会出现修改了右值的情况。这也使得 C++ 中一个常见的习惯成为可能：函数的参数使用常量引用接收参数，避免创建不必要的临时对象。</p><p><strong>CV限定的右值</strong></p><p>一个非函数、非数组的类型 T 的左值可以转换为右值。 […] 如果 T 不是类类型【译注：类类型即 C++ 中使用类定义的类型，区别与内置类型】，转换后的右值的类型是 T 的 未限定 CV 的版本</p><p>每个类型都有三个对应的CV-限定类型版本: const 限定   volatile 限定 和 const-volatile 限定版本.  有或无CV限定的类型是不同的类型, 但是写法和赋值需求都是相同的.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="type">const</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;A::foo() const\n&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;A::foo()\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">bar</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">A</span>(); &#125;</span><br><span class="line"><span class="function"><span class="type">const</span> A <span class="title">cbar</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">A</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">bar</span>().<span class="built_in">foo</span>();</span><br><span class="line">    <span class="built_in">cbar</span>().<span class="built_in">foo</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main</code> 中的第二个函数调用实际上调用的是 <code>A</code> 中的 <code>foo() const</code> 函数，因为 <code>cbar</code> 返回的类型是 <code>const A</code>，这和 <code>A</code> 是两个不同的类型。这就是上面的引用中最后一句话所表达的意思。另外注意到，<code>cbar</code> 的返回值是一个右值，所以这是一个实际的 CV 限定的右值的例子。</p><p><strong>右值引用</strong></p><p>左值和右值的主要区别是，左值可以被修改，而右值不能。不过，C++11 改变了这一区别。在一些特殊的情况下，我们可以使用右值的引用，并对右值进行修改。</p><p>使用 <code>&amp;&amp;</code> 表示。它专门用于绑定右值，从而使程序可以操作右值（临时对象）。</p><p>用途: 1️⃣ 移动语义, 通过移动右值资源(如动态内存) 避免拷贝, 提升性能. 2️⃣完美转发:保留函数模板中参数的值类别(左值或右值)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string str1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    std::string str2 = std::<span class="built_in">move</span>(str1);   <span class="comment">// std::move 将 str1 转为右值</span></span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str2&quot;</span> &lt;&lt; str2 &lt;&lt; std::endl;  <span class="comment">//输出Hello</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str1&quot;</span> &lt;&lt; str1 &lt;&lt; std::endl;  <span class="comment">// str1 的资源已经被转移, 可能为空</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/11/19/673c83b590a66.png"></p><p>Q: 如何判断一个表达式是左值还是右值?</p><p>1️⃣ 如果能取地址 (&amp; 操作符能成功) , 则为左值</p><p>2️⃣ 如果不能取地址, 但可以用作右侧赋值, 则为右值</p><p>引用右值 主要是为了支持移动语义, 以减少不必要的资源拷贝, 以提高程序效率</p><p>总结 :</p><p> 左值 : 有明确的内存位置, 生命周期可控, 可取地址.</p><p> 右值:  临时值, 生命周期短, 通常不可修改.</p><p> 右值引用：通过&amp;&amp;操作符，允许操作右值，主要用于移动语义和完美转发。</p><h3 id="2024-11-25-第三次会议"><a href="#2024-11-25-第三次会议" class="headerlink" title="2024.11.25 第三次会议"></a>2024.11.25 第三次会议</h3><p>没有回答好的内容： 数组指针、堆栈溢出</p><h4 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a[<span class="number">5</span>]&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="built_in">int</span> (*p)[<span class="number">5</span>] = &amp;a;   <span class="comment">// 数组指针</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">sizeof</span>(*p));   <span class="comment">// </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;a[<span class="number">0</span>]);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>p</code> 指针指向包含五个整型元素的数组指针。注意这里的<code>(*p)</code>表明<code>p</code>是一个指针，而<code>[5]</code>表示它指向的对象是一个包含5个元素的数组。并且将 <code>p</code> 初始化为指向前面定义的数组 <code>a</code> 的地址（通过 <code>&amp;a</code> 取数组 <code>a</code> 的地址来赋值给 <code>p</code>）</p><p>在这里，<code>*p</code> 实际上就是 <code>p</code> 所指向的那个包含 5 个整型元素的数组（因为 <code>p</code> 是指向数组的指针，解引用 <code>*p</code> 就得到它指向的数组本身）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;a[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><p><code>printf(&quot;%p\n&quot;, a);</code>：这里输出数组 <code>a</code> 的首元素地址，前面提到数组名在很多情况下可以代表首元素地址，所以它会输出数组 <code>a</code> 第一个元素在内存中的地址。</p><p><code>printf(&quot;%p\n&quot;, &amp;a);</code>：这里通过 <code>&amp;a</code> 取的是整个数组 <code>a</code> 的地址，虽然数组首元素地址的值和整个数组的地址的值在数值上通常是一样的（在绝大多数常见的实现中），但它们的类型是不同的，一个是指向数组首元素的指针（<code>int*</code> 类型的指针），另一个是指向整个数组的指针（<code>int (*)[5]</code> 类型的指针）。</p><p><code>printf(&quot;%p\n&quot;, &amp;a[0]);</code>：这是取数组 <code>a</code> 的首元素 <code>a[0]</code> 的地址，其效果和直接使用 <code>a</code> （在代表首元素地址这个意义上）是一样的，同样会输出数组 <code>a</code> 第一个元素在内存中的地址。</p><h4 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span>* a[<span class="number">5</span>]&#123; &#125;;  <span class="comment">// 指针数组  包含5个元素，每个元素的类型都是int* </span></span><br><span class="line"><span class="type">int</span>** p = a;   <span class="comment">// </span></span><br><span class="line"><span class="type">int</span>* (*p)[<span class="number">5</span>] = &amp;a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里定义了一个名为 <code>a</code> 的数组，它包含 5 个元素，每个元素的类型都是 <code>int*</code>，也就是指向整型的指针类型。通过使用初始化列表 <code>&#123; &#125;</code>，将这 5 个指针元素初始化为空指针（默认初始值）。本质上，<code>a</code> 是一个可以存放 5 个指向整型变量的指针的数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>** p = a;</span><br></pre></td></tr></table></figure><p>二级指针初始化为<code>a</code>。之所以能这样赋值，是因为数组名 <code>a</code> 在这种情况下会隐式转换为指向数组首元素的指针， 而 <code>a</code> 的首元素类型是 <code>int*</code> ，所以 <code>p</code> 这个二级指针就可以指向 <code>a</code> 数组 （或者说指向 <code>a</code> 数组的首元素，首元素本身也是指针类型）。这意味着通过 <code>p</code> 可以间接操作 <code>a</code> 数组中的指针元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* (*p)[<span class="number">5</span>] = &amp;a;</span><br></pre></td></tr></table></figure><p><code>int* (*p)[5]</code> 表示 <code>p</code> 是一个指针，它指向的是一个包含5个元素的数组，而这个数组中每个元素类型又是 <code>int*</code></p><p>（指向整型的指针）。然后通过 <code>&amp;a</code> 将 <code>p</code> 初始化为指向前面定义的 <code>a</code> 数组的地址。</p><h3 id="2024-12-04-第四次会议"><a href="#2024-12-04-第四次会议" class="headerlink" title="2024.12.04 第四次会议"></a>2024.12.04 第四次会议</h3><p>完成了运算符重载的作业，并且开始QT部分的学习。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 会议内容记录 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
