<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>远程桌面控制（一）</title>
      <link href="/2025/04/07/%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E6%8E%A7%E5%88%B6%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2025/04/07/%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E6%8E%A7%E5%88%B6%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="Cpacket类-（协议包封装）"><a href="#Cpacket类-（协议包封装）" class="headerlink" title="Cpacket类  （协议包封装）"></a>Cpacket类  （协议包封装）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;framework.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(push)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(1)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPacket</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">CPacket</span>():<span class="built_in">sHead</span>(<span class="number">0</span>), <span class="built_in">nLength</span>(<span class="number">0</span>), <span class="built_in">sCmd</span>(<span class="number">0</span>), <span class="built_in">sSum</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"><span class="comment">// 打包</span></span><br><span class="line"><span class="built_in">CPacket</span>(WORD nCmd, <span class="type">const</span> BYTE* pData, <span class="type">size_t</span> nSize);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝构造函数</span></span><br><span class="line"><span class="built_in">CPacket</span>(<span class="type">const</span> CPacket&amp; pack) &#123;</span><br><span class="line">sHead = pack.sHead;   </span><br><span class="line">nLength = pack.nLength;</span><br><span class="line">sCmd = pack.sCmd;</span><br><span class="line">strData = pack.strData;</span><br><span class="line">sSum = pack.sSum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//nSize 表示 输入缓冲区 pData 的数据总长度（字节数）</span></span><br><span class="line">    <span class="comment">// 解包</span></span><br><span class="line"><span class="built_in">CPacket</span>(<span class="type">const</span> BYTE* pData, <span class="type">size_t</span>&amp; nSize) &#123;</span><br><span class="line"><span class="type">size_t</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; i &lt; nSize; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (*(WORD*)(pData + i) == <span class="number">0xFEFF</span>) &#123;</span><br><span class="line">sHead = *(WORD*)(pData + i);</span><br><span class="line">i += <span class="number">2</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i + <span class="number">4</span> + <span class="number">2</span> + <span class="number">2</span> &gt; nSize) &#123; <span class="comment">// 包数据可能不全，或者包头未能全部接收到</span></span><br><span class="line">nSize = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">nLength = *(DWORD*)(pData + i); i += <span class="number">4</span>;</span><br><span class="line"><span class="keyword">if</span> (nLength + i &gt; nSize) &#123;<span class="comment">// 包没有完全接收，就返回，解析失败。</span></span><br><span class="line">nSize = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">sCmd = *(WORD*)(pData + i); i += <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (nLength &gt; <span class="number">4</span>) &#123;</span><br><span class="line"><span class="comment">// 调整数据的大小  让 nLength 减去控制命令和检验和的大小</span></span><br><span class="line">strData.<span class="built_in">resize</span>(nLength - <span class="number">2</span> - <span class="number">2</span>);</span><br><span class="line"><span class="built_in">memcpy</span>((<span class="type">void</span>*)strData.<span class="built_in">c_str</span>(), pData + i, nLength - <span class="number">4</span>);</span><br><span class="line">i += nLength - <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line">sSum = *(WORD*)(pData + i); i += <span class="number">2</span>;</span><br><span class="line">WORD sum = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 让数据&amp;0xFF   得到校验和与包中的校验和进行比较</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; strData.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">sum += <span class="built_in">BYTE</span>(strData[j]) &amp; <span class="number">0xFF</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (sum == sSum) &#123;</span><br><span class="line">nSize = i;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">nSize = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">CPacket</span>()&#123;&#125;</span><br><span class="line">CPacket&amp; <span class="keyword">operator</span>=(<span class="type">const</span> CPacket&amp; pack) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> != &amp;pack)&#123;</span><br><span class="line">sHead = pack.sHead;</span><br><span class="line">nLength = pack.nLength;</span><br><span class="line">sCmd = pack.sCmd;</span><br><span class="line">sSum = pack.sSum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Size</span><span class="params">()</span> </span>&#123; <span class="comment">// 包数据的大小</span></span><br><span class="line"><span class="keyword">return</span> nLength + <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 返回二进制包</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">Data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">strOut.<span class="built_in">resize</span>(nLength + <span class="number">6</span>);  <span class="comment">// 总长度 = 包头(2) + nLength(4) + 数据 + 校验和(2)</span></span><br><span class="line">BYTE* pData = (BYTE*)strOut.<span class="built_in">c_str</span>();</span><br><span class="line">*(WORD*)pData = sHead; pData += <span class="number">2</span>;   <span class="comment">// 写入包头</span></span><br><span class="line">*(DWORD*)(pData) = nLength; pData += <span class="number">4</span>;   <span class="comment">// 写入长度</span></span><br><span class="line">*(WORD*)pData = sCmd; pData += <span class="number">2</span>;     <span class="comment">// 写入命令</span></span><br><span class="line"><span class="comment">// 复制数据</span></span><br><span class="line">        <span class="built_in">memcpy</span>(pData, strData.<span class="built_in">c_str</span>(), strData.<span class="built_in">size</span>()); pData += strData.<span class="built_in">size</span>();</span><br><span class="line">*(WORD*)pData = sSum;    <span class="comment">// 写入校验和</span></span><br><span class="line"><span class="keyword">return</span> strOut.<span class="built_in">c_str</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">WORD sHead;  <span class="comment">// 固定 位0xFEFF</span></span><br><span class="line">DWORD nLength; <span class="comment">// 包长度（从控制命令开始，到和校验结束）</span></span><br><span class="line">WORD sCmd;  <span class="comment">// 控制命令</span></span><br><span class="line">std::string strData;  <span class="comment">// 包数据</span></span><br><span class="line">WORD sSum; <span class="comment">// 和校验</span></span><br><span class="line">std::string strOut; <span class="comment">// 整个包的二进制数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="CServerSocket-类（服务器通信封装）"><a href="#CServerSocket-类（服务器通信封装）" class="headerlink" title="CServerSocket 类（服务器通信封装）"></a>CServerSocket 类（服务器通信封装）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(pop)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CServerSocket</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 使用静态函数的方式访问private的</span></span><br><span class="line">    <span class="comment">// 获取单例</span></span><br><span class="line"><span class="function"><span class="type">static</span> CServerSocket* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 静态函数没有this指针，没办法访问成员变量</span></span><br><span class="line"><span class="comment">// 把成员变量也搞成静态的</span></span><br><span class="line"><span class="keyword">if</span> (m_instance == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">m_instance = <span class="keyword">new</span> <span class="built_in">CServerSocket</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> m_instance;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 初始化监听</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InitSocket</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m_sock == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// ToDo  校验</span></span><br><span class="line">sockaddr_in serv_adr;</span><br><span class="line"><span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_adr));</span><br><span class="line">serv_adr.sin_family = AF_INET;</span><br><span class="line">serv_adr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">serv_adr.sin_port = <span class="built_in">htons</span>(<span class="number">9527</span>);</span><br><span class="line"><span class="comment">// 绑定</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">bind</span>(m_sock, (sockaddr*)&amp;serv_adr, <span class="built_in">sizeof</span>(serv_adr)) == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">listen</span>(m_sock, <span class="number">1</span>) == <span class="number">-1</span>)   <span class="comment">// 允许一个待连接队列</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 接受客户端连接</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">AcceptClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">sockaddr_in client_adr;</span><br><span class="line"><span class="type">int</span> cli_sz = <span class="built_in">sizeof</span>(client_adr);</span><br><span class="line">m_client = <span class="built_in">accept</span>(m_sock, (sockaddr*)&amp;client_adr, &amp;cli_sz);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m_client == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 4096</span></span><br><span class="line">    <span class="comment">// 处理命令</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DealCommand</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m_client == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="comment">//char buffer[1024] = &quot;&quot;;</span></span><br><span class="line"><span class="type">char</span>* buffer = <span class="keyword">new</span> <span class="type">char</span>[BUFFER_SIZE];</span><br><span class="line"><span class="built_in">memset</span>(buffer, <span class="number">0</span>, BUFFER_SIZE);</span><br><span class="line"><span class="type">size_t</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">size_t</span> len = <span class="built_in">recv</span>(m_client, buffer + index, BUFFER_SIZE - index, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (len &lt;= <span class="number">0</span>)   <span class="comment">// 连接错误</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">index += len;</span><br><span class="line">len = index;</span><br><span class="line">m_packet = <span class="built_in">CPacket</span>((BYTE*)buffer, len);   <span class="comment">// 解析数据</span></span><br><span class="line"><span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">memmove</span>(buffer, buffer + len, BUFFER_SIZE - len);</span><br><span class="line">index -= len;</span><br><span class="line"><span class="keyword">return</span> m_packet.sCmd;   <span class="comment">// 返回有效命令</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 原始数据发送</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Send</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pData, <span class="type">int</span> nSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m_client == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">send</span>(m_client, pData, nSize, <span class="number">0</span>) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 发送CPacket封装的包</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Send</span><span class="params">(CPacket&amp; pack)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m_client == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line"><span class="comment">// (const char*)&amp;pack：将 CPacket 对象 pack 的地址强制转换为 const char* 类型</span></span><br><span class="line"><span class="comment">// 表示发送的数据的起始地址。</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">send</span>(m_client, pack.<span class="built_in">Data</span>(), pack.<span class="built_in">Size</span>(), <span class="number">0</span>) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解析包中的文件路径</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetFilePath</span><span class="params">(std::string&amp; strPath)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m_packet.sCmd == <span class="number">2</span>) &#123; <span class="comment">// 控制命令为2代表获取文件列表 只有控制命令为获取文件列表</span></span><br><span class="line">strPath = m_packet.strData;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">CPacket m_packet;  <span class="comment">// 数据包对象</span></span><br><span class="line">SOCKET m_client;   <span class="comment">// 客户端套接字</span></span><br><span class="line">SOCKET m_sock;     <span class="comment">// 服务器套接字</span></span><br><span class="line"><span class="comment">// 赋值和构造都是私有，不允许别人使用</span></span><br><span class="line">CServerSocket&amp; <span class="keyword">operator</span>=(<span class="type">const</span> CServerSocket&amp; ss)&#123;&#125;</span><br><span class="line"><span class="built_in">CServerSocket</span>(<span class="type">const</span> CServerSocket&amp; ss)&#123;</span><br><span class="line">m_sock = ss.m_sock;</span><br><span class="line">m_client = ss.m_client;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 私有构造函数</span></span><br><span class="line"><span class="built_in">CServerSocket</span>() &#123;</span><br><span class="line">m_client = INVALID_SOCKET;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">InitSockEnv</span>() == <span class="literal">false</span>) &#123;</span><br><span class="line"><span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, _T(<span class="string">&quot;无法初始化套接字环境，请检查网络设置&quot;</span>), _T(<span class="string">&quot;初始化错误！&quot;</span>), MB_OK | MB_ICONERROR);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">m_sock = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//私有析构函数</span></span><br><span class="line">~<span class="built_in">CServerSocket</span>() &#123;</span><br><span class="line"><span class="built_in">closesocket</span>(m_sock);</span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Windows 套接字环境初始化</span></span><br><span class="line"><span class="function">BOOL <span class="title">InitSockEnv</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">WSADATA data;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">WSAStartup</span>(<span class="built_in">MAKEWORD</span>(<span class="number">1</span>, <span class="number">1</span>), &amp;data) != <span class="number">0</span>) <span class="comment">// TODO：返回值处理</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">releaseInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m_instance != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">CServerSocket* tmp = m_instance;</span><br><span class="line"><span class="comment">// 指针为空</span></span><br><span class="line">m_instance = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">delete</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把这个成员变量也搞成静态的，这样静态函数就能访问这个成员变量了</span></span><br><span class="line"><span class="comment">//单例实例</span></span><br><span class="line"><span class="type">static</span> CServerSocket* m_instance;</span><br><span class="line"><span class="comment">// 当构造的时候，就调用getInstance()</span></span><br><span class="line"><span class="comment">// 析构的时候就调用releaseInstance()</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CHelper</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">CHelper</span>() &#123;</span><br><span class="line">CServerSocket::<span class="built_in">getInstance</span>();</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">CHelper</span>()</span><br><span class="line">&#123;</span><br><span class="line">CServerSocket::<span class="built_in">releaseInstance</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//辅助类实例</span></span><br><span class="line"><span class="type">static</span> CHelper m_helper;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="单例模式是怎么实现的"><a href="#单例模式是怎么实现的" class="headerlink" title="单例模式是怎么实现的"></a>单例模式是怎么实现的</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CServerSocket</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> CServerSocket* m_instance;</span><br><span class="line">    <span class="type">static</span> CHelper m_helper; <span class="comment">// 辅助类，确保构造和析构</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> CServerSocket* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!m_instance) m_instance = <span class="keyword">new</span> <span class="built_in">CServerSocket</span>();</span><br><span class="line">        <span class="keyword">return</span> m_instance;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">CServerSocket</span>() &#123; ... &#125; <span class="comment">// 私有构造</span></span><br><span class="line">    ~<span class="built_in">CServerSocket</span>() &#123; ... &#125; <span class="comment">// 私有析构</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">CHelper</span> &#123; <span class="comment">// RAII 管理单例生命周期</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">CHelper</span>() &#123; CServerSocket::<span class="built_in">getInstance</span>(); &#125;</span><br><span class="line">        ~<span class="built_in">CHelper</span>() &#123; CServerSocket::<span class="built_in">releaseInstance</span>(); &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>设计思想</strong>：</p><ul><li><strong>禁止用户直接构造</strong>，必须通过 <code>getInstance()</code> 获取唯一对象。</li><li><code>CHelper</code> 辅助类：<ul><li>构造时自动创建 <code>CServerSocket</code> 单例。</li><li>析构时自动释放，防止内存泄漏。</li></ul></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th><strong>模块</strong></th><th><strong>核心功能</strong></th></tr></thead><tbody><tr><td><strong><code>CPacket</code></strong></td><td>协议封装，提供 <strong>打包&#x2F;解包</strong> 能力</td></tr><tr><td><strong><code>CServerSocket</code></strong></td><td>服务器核心，<strong>单例管理</strong>、<strong>收发数据</strong></td></tr><tr><td><strong>单例模式</strong></td><td>确保全局唯一服务器实例</td></tr><tr><td><strong>字节对齐 (<code>#pragma pack</code>)</strong></td><td>保证数据包严格对齐，避免解析错误</td></tr></tbody></table><p><strong>适用场景</strong>：</p><ul><li>小型客户端-服务器通信（如文件传输、远程控制等）。</li><li>可扩展性较强，<code>sCmd</code> 可用于扩展不同业务逻辑。</li></ul><h2 id="CServerSocket-单例实现与-CPacket-打包构造函数"><a href="#CServerSocket-单例实现与-CPacket-打包构造函数" class="headerlink" title="CServerSocket 单例实现与 CPacket 打包构造函数"></a><code>CServerSocket</code> 单例实现与 <code>CPacket</code> 打包构造函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServerSocket.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ServerSocket.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">////CServerSocket server;</span></span><br><span class="line">CServerSocket* CServerSocket::m_instance = <span class="literal">NULL</span>;  <span class="comment">// 静态成员初始化</span></span><br><span class="line">CServerSocket::CHelper CServerSocket::m_helper;   </span><br><span class="line"><span class="comment">//指针没有对象，是全局的</span></span><br><span class="line">CServerSocket* pserver = CServerSocket::<span class="built_in">getInstance</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打包</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">CPacket::CPacket</span><span class="params">(WORD nCmd, <span class="type">const</span> BYTE* pData, <span class="type">size_t</span> nSize)</span> </span>&#123;</span><br><span class="line">sHead = <span class="number">0xFEFF</span>;    <span class="comment">// 固定协议标识符</span></span><br><span class="line">nLength = nSize + <span class="number">4</span>;   <span class="comment">// +4 = sCmd(2) + sSum(2)</span></span><br><span class="line">sCmd = nCmd;     <span class="comment">// 存储业务命令</span></span><br><span class="line">strData.<span class="built_in">resize</span>(nSize);</span><br><span class="line"><span class="built_in">memcpy</span>((<span class="type">void</span>*)strData.<span class="built_in">c_str</span>(), pData, nSize);</span><br><span class="line">sSum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; strData.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">sSum += <span class="built_in">BYTE</span>(strData[j]) &amp; <span class="number">0xFF</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第一部分：CServerSocket-单例模式实现"><a href="#第一部分：CServerSocket-单例模式实现" class="headerlink" title="第一部分：CServerSocket 单例模式实现"></a>第一部分：<code>CServerSocket</code> 单例模式实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CServerSocket* CServerSocket::m_instance = <span class="literal">NULL</span>;  <span class="comment">// 静态成员初始化</span></span><br><span class="line">CServerSocket::CHelper CServerSocket::m_helper;   <span class="comment">// RAII辅助对象</span></span><br><span class="line">CServerSocket* pserver = CServerSocket::<span class="built_in">getInstance</span>(); <span class="comment">// 全局访问点</span></span><br></pre></td></tr></table></figure><h4 id="设计模式解析"><a href="#设计模式解析" class="headerlink" title="设计模式解析"></a>设计模式解析</h4><ol><li><p><strong>单例控制</strong></p><ul><li><code>m_instance</code> 作为静态指针，保证全进程唯一实例</li><li>通过 <code>getInstance()</code> 获取唯一实例，首次调用时构造对象</li></ul></li><li><p><strong>RAII</strong>助手类 (<code>CHelper</code>)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CHelper</span> &#123;<span class="keyword">public</span>:    <span class="built_in">CHelper</span>() &#123; CServerSocket::<span class="built_in">getInstance</span>(); &#125;  <span class="comment">// 构造时触发单例创建    ~CHelper() &#123; CServerSocket::releaseInstance(); &#125; // 析构时释放单例&#125;;</span></span><br></pre></td></tr></table></figure><ul><li><strong>构造阶段</strong>：程序启动时，全局 <code>m_helper</code> 的构造自动触发单例创建</li><li><strong>析构阶段</strong>：程序退出时，自动调用 <code>releaseInstance()</code> 释放资源</li></ul></li><li><p><strong>全局访问点</strong></p><ul><li><p><code>pserver</code> 提供全局统一访问入口</p></li><li><p>使用示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pserver-&gt;<span class="built_in">InitSocket</span>();  <span class="comment">// 任何地方都可直接使用</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><p><img src="https://bu.dusays.com/2025/04/07/67f3df51097fb.png"></p><h3 id="第二部分：CPacket-打包构造函数"><a href="#第二部分：CPacket-打包构造函数" class="headerlink" title="第二部分：CPacket 打包构造函数"></a>第二部分：<code>CPacket</code> 打包构造函数</h3><h4 id="构造函数原型"><a href="#构造函数原型" class="headerlink" title="构造函数原型"></a>构造函数原型</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CPacket::<span class="built_in">CPacket</span>(WORD nCmd, <span class="type">const</span> BYTE* pData, <span class="type">size_t</span> nSize) </span><br></pre></td></tr></table></figure><h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><table><thead><tr><th>参数</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>nCmd</code></td><td><code>WORD</code></td><td>协议命令字（2字节）</td></tr><tr><td><code>pData</code></td><td><code>const BYTE*</code></td><td>负载数据指针</td></tr><tr><td><code>nSize</code></td><td><code>size_t</code></td><td>负载数据长度</td></tr></tbody></table><h2 id="主程序"><a href="#主程序" class="headerlink" title="主程序"></a>主程序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RemoveCtrl.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;framework.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;RemoveCtrl.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ServerSocket.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;direct.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> new DEBUG_NEW</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">//#pragma comment(linker, &quot;/subsystem:windows /entry:WinMainCRTStartup&quot; )</span></span><br><span class="line"><span class="comment">//#pragma comment(linker, &quot;/subsystem:windows /entry:mainCRTStartup&quot; )</span></span><br><span class="line"><span class="comment">//#pragma comment(linker, &quot;/subsystem:console /entry:WinMainCRTStartup&quot; )</span></span><br><span class="line"><span class="comment">//#pragma comment(linker, &quot;/subsystem:console /entry:mainCRTStartup&quot; )</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 唯一的应用程序对象</span></span><br><span class="line"></span><br><span class="line">CWinApp theApp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将给定的二进制数据以十六进制格式打印出来，并将输出发送到调试器（通过OutputDebugStringA）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dump</span><span class="params">(BYTE* pData, <span class="type">size_t</span> nSize)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    std::string strOut;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; nSize; i++) &#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">8</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; (i % <span class="number">16</span> == <span class="number">0</span>)) strOut += <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="built_in">snprintf</span>(buf, <span class="built_in">sizeof</span>(buf), <span class="string">&quot;%02X &quot;</span>, pData[i] &amp; <span class="number">0xFF</span>);</span><br><span class="line">        strOut += buf;</span><br><span class="line">    &#125;</span><br><span class="line">    strOut += <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="built_in">OutputDebugStringA</span>(strOut.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MakeDriverInfo</span><span class="params">()</span> </span>&#123; <span class="comment">// 1 =&gt; A   2 =&gt; B  3 =&gt; C</span></span><br><span class="line">    std::string result;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">26</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//查看每个驱动器是否存在（通过_chdrive函数）</span></span><br><span class="line">        <span class="keyword">if</span> (_chdrive(i) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//将存在的驱动字母（如A、B、C）拼接成一个字符串，用逗号分隔。</span></span><br><span class="line">            <span class="keyword">if</span> (result.<span class="built_in">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">result += <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">            result += <span class="string">&#x27;A&#x27;</span> + i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后调用 CServerSocket::getInstance()-&gt;Send(CPacket()) 发送数据包。</span></span><br><span class="line">    <span class="comment">//CServerSocket::getInstance()-&gt;Send(CPacket(1,(BYTE*)result.c_str(),result.size()));</span></span><br><span class="line">    <span class="function">CPacket <span class="title">pack</span><span class="params">(<span class="number">1</span>, (BYTE*)result.c_str(), result.size())</span></span>;</span><br><span class="line">    <span class="built_in">Dump</span>((BYTE*)pack.<span class="built_in">Data</span>(), pack.<span class="built_in">Size</span>());</span><br><span class="line"><span class="comment">//CServerSocket::getInstance()-&gt;Send(pack);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;RemoteCtrl.h&quot;</span></span></span><br><span class="line"><span class="comment">/*结构体和类十分相似  区别是结构体默认是public   类默认是private*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">file_info</span>&#123;</span><br><span class="line">    <span class="built_in">file_info</span>() &#123;</span><br><span class="line">        IsInvalid = <span class="number">0</span>;</span><br><span class="line">        IsDirectory = <span class="number">-1</span>;</span><br><span class="line">        HasNext = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">memset</span>(szFileName, <span class="number">0</span>, <span class="built_in">sizeof</span>(szFileName));</span><br><span class="line">    &#125;</span><br><span class="line">    BOOL IsInvalid; <span class="comment">// 是否有效</span></span><br><span class="line">    BOOL HasNext; <span class="comment">// 是否还有后续    0   否  1 是</span></span><br><span class="line">    <span class="type">char</span> szFileName[<span class="number">256</span>]; <span class="comment">// 文件名 </span></span><br><span class="line">    BOOL IsDirectory;  <span class="comment">// 是否为目录  0 否 1  是 </span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;FILEINFO, *PFILEINFO;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> nRetCode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    HMODULE hModule = ::<span class="built_in">GetModuleHandle</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hModule != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 初始化 MFC 并在失败时显示错误  </span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">AfxWinInit</span>(hModule, <span class="literal">nullptr</span>, ::<span class="built_in">GetCommandLine</span>(), <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> 在此处为应用程序的行为编写代码。</span></span><br><span class="line">            <span class="built_in">wprintf</span>(<span class="string">L&quot;错误: MFC 初始化失败\n&quot;</span>);</span><br><span class="line">            nRetCode = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 套接字初始化</span></span><br><span class="line">       </span><br><span class="line">            <span class="comment">// 观察文件</span></span><br><span class="line">            <span class="type">int</span> nCmd = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">switch</span> (nCmd)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// 查看磁盘分区</span></span><br><span class="line">                <span class="built_in">MakeDriverInfo</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="built_in">MakeDirectoryInfo</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 更改错误代码以符合需要</span></span><br><span class="line">        <span class="built_in">wprintf</span>(<span class="string">L&quot;错误: GetModuleHandle 失败\n&quot;</span>);</span><br><span class="line">        nRetCode = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nRetCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 木马远控 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-数学知识</title>
      <link href="/2025/03/31/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
      <url>/2025/03/31/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h3 id="这部分内容有下面几块"><a href="#这部分内容有下面几块" class="headerlink" title="这部分内容有下面几块"></a>这部分内容有下面几块</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、 数论</span><br><span class="line">2、 组合计数</span><br><span class="line">3、 高斯消元</span><br><span class="line">4、 简单博弈论</span><br></pre></td></tr></table></figure><h3 id="一、数论"><a href="#一、数论" class="headerlink" title="一、数论"></a>一、数论</h3><h4 id="1、质数"><a href="#1、质数" class="headerlink" title="1、质数"></a>1、质数</h4><h5 id="1、判断质数"><a href="#1、判断质数" class="headerlink" title="1、判断质数"></a>1、判断质数</h5><p>质数又称素数。一个大于1的自然数，除了1和它自身外，不能被其他自然数整除的数叫做质数；否则称为合数（规定1既不是质数也不是合数）。</p><p><strong>说明</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">·试除法</span><br><span class="line">·判断条件的选择</span><br><span class="line">i &lt; n和i &lt;= n / 2时间复杂度都是O(n), 过高</span><br><span class="line">i * i &lt;= n虽然时间复杂度是O(n^½ ), 但i * i可能会溢出</span><br><span class="line">因此最好的判别条件是i &lt;= n / i，时间复杂度是O(n^½ )</span><br></pre></td></tr></table></figure><h5 id="2、分解质因数"><a href="#2、分解质因数" class="headerlink" title="2、分解质因数"></a>2、分解质因数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )              <span class="comment">// 注意循环条件</span></span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i, cnt ++ ;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="number">1</span> &lt;&lt; endl;    <span class="comment">// 至多存在一个大于sqrt(n)的质因子</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">·试除法</span><br><span class="line">·数学知识：n 最多包含一个大于√n的质因子。例如6 = 2 * 3，,6 = 2.44949，存在一个大于√6的质因子 3</span><br><span class="line">·判别质数用 i &lt;= n / i条件</span><br><span class="line">·最好时间复杂度O(logn), 最坏的时间复杂度O(n^½)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> coding日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-图论</title>
      <link href="/2025/03/19/%E5%9B%BE%E8%AE%BA/"/>
      <url>/2025/03/19/%E5%9B%BE%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<p>———————————————————–还没整理好——————————————————————————–</p><h3 id="图论有哪些部分？"><a href="#图论有哪些部分？" class="headerlink" title="图论有哪些部分？"></a>图论有哪些部分？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1、 深度优先搜索  DFS</span><br><span class="line">2、 宽度优先搜索  BFS</span><br><span class="line">3、 树与图的存储</span><br><span class="line">4、 树与图的深度优先遍历</span><br><span class="line">5、 树与图的宽途优先遍历</span><br><span class="line">6、 拓扑排序</span><br><span class="line">7、 单源最短路径</span><br><span class="line">8、 多源最短路径</span><br><span class="line">9、 最小生成树</span><br><span class="line">10、二分图</span><br></pre></td></tr></table></figure><p><strong>DFS  和  BFS</strong></p><table><thead><tr><th align="center"></th><th align="center">数据结构</th><th align="center">空间</th><th align="center">特点</th></tr></thead><tbody><tr><td align="center">DFS</td><td align="center">stack</td><td align="center">O(h)</td><td align="center">不具有最短性</td></tr><tr><td align="center">BFS</td><td align="center">queue</td><td align="center">O(2^h)</td><td align="center">最短路径</td></tr></tbody></table><br><br><h3 id="DFS例题"><a href="#DFS例题" class="headerlink" title="DFS例题"></a>DFS例题</h3><p>给定一个整数 n ，将数字 1 ∼ n 排成一排，将会有很多种排列方法。</p><p>现在，请你按照字典序将所有的排列方法输出。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>共一行，包含一个整数 n。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>按字典序输出所有排列方案，每个方案占一行。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1 ≤ n ≤ 7</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">1 3 2</span><br><span class="line">2 1 3</span><br><span class="line">2 3 1</span><br><span class="line">3 1 2</span><br><span class="line">3 2 1</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> path[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cout &lt;&lt; path[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (st[i]) <span class="keyword">continue</span>; <span class="comment">// 如果数字 i 已经被使用，跳过当前循环</span></span><br><span class="line">        path[u] = i;</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(u + <span class="number">1</span>);</span><br><span class="line">        st[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="n-皇后问题"><a href="#n-皇后问题" class="headerlink" title="n-皇后问题"></a>n-皇后问题</h4><p>n−皇后问题是指将 n 个皇后放在 n×n 的国际象棋棋盘上，使得皇后不能相互攻击到，即任意两个皇后都不能处于同一行、同一列或同一斜线上。</p><p><img src="https://bu.dusays.com/2025/03/19/67da6b856f730.png"></p><p>现在给定整数 n，请你输出所有的满足条件的棋子摆法。</p><p><strong>输入格式</strong></p><p>共一行，包含整数 n。</p><p><strong>输出格式</strong></p><p>每个解决方案占 n 行，每行输出一个长度为 n 的字符串，用来表示完整的棋盘状态。</p><p>其中 <code>.</code> 表示某一个位置的方格状态为空，<code>Q</code> 表示某一个位置的方格上摆着皇后。</p><p>每个方案输出完成后，输出一个空行。</p><p><strong>注意：行末不能有多余空格。</strong></p><p>输出方案的顺序任意，只要不重复且没有遗漏即可。</p><p><strong>数据范围</strong></p><p>1 ≤ n ≤ 9</p><p><strong>输入样例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.Q..</span><br><span class="line">...Q</span><br><span class="line">Q...</span><br><span class="line">..Q.</span><br><span class="line"></span><br><span class="line">..Q.</span><br><span class="line">Q...</span><br><span class="line">...Q</span><br><span class="line">.Q..</span><br></pre></td></tr></table></figure><p><strong>方法一、已知每一行就一个皇后，不需要每个格子都遍历</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">bool</span> col[N], dg[N], udg[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">puts</span>(g[i]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!col[i] &amp;&amp; !dg[u + i] &amp;&amp; !udg[n - u  + i])</span><br><span class="line">        &#123;</span><br><span class="line">            g[u][i] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            col[i] = dg[u + i] = udg[n - u  + i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(u + <span class="number">1</span>);</span><br><span class="line">            col[i] = dg[u + i] = udg[n - u  + i] = <span class="literal">false</span>;</span><br><span class="line">            g[u][i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n ; j ++ )</span><br><span class="line">            g[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们检查棋盘是按行来检查的，其中u就是控制棋盘的行，i是控制列的。</p><p>(u, i)就是棋盘中的坐标，在一条对角线上 u + i 的值是不变的，所以只要有一个u + i 设置为true，那么就表示这条对角线已经有皇后了。</p><p>同理，反对角线的值都是n - u + i…</p><p><strong>按照格子枚举</strong></p><p>一行行的遍历 ，到头之后再设置到新的 一行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">bool</span> row[N], col[N],dg[N], udg[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (y == n) y = <span class="number">0</span>, x ++ ;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (x == n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">puts</span>(g[i]);</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 不放皇后</span></span><br><span class="line">    g[x][y] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(x, y + <span class="number">1</span>, s);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 放皇后</span></span><br><span class="line">    <span class="keyword">if</span> (!row[x] &amp;&amp; !col[y] &amp;&amp; !dg[x + y] &amp;&amp; !udg[x - y + n])</span><br><span class="line">    &#123;</span><br><span class="line">        row[x] = col[y] = dg[x + y] = udg[x - y + n] = <span class="literal">true</span>;</span><br><span class="line">        g[x][y] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(x, y + <span class="number">1</span>, s + <span class="number">1</span>);</span><br><span class="line">        g[x][y] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        row[x] = col[y] = dg[x + y] = udg[x - y + n] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p>所有边的权重都是1的时候，才用BFS</p><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p>给定一个 n×m 的二维整数数组，用来表示一个迷宫，数组中只包含 0 或 1，其中 0 表示可以走的路，1 表示不可通过的墙壁。</p><p>最初，有一个人位于左上角 (1,1) 处，已知该人每次可以向上、下、左、右任意一个方向移动一个位置。</p><p>请问，该人从左上角移动至右下角 (n,m) 处，至少需要移动多少次。</p><p>数据保证 (1,1) 处和 (n,m) 处的数字为 0，且一定至少存在一条通路。</p><p><strong>输入格式</strong></p><p>第一行包含两个整数 n 和 m。</p><p>接下来 n 行，每行包含 m 个整数（0 或 1），表示完整的二维数组迷宫。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示从左上角移动至右下角的最少移动次数。</p><p><strong>数据范围</strong></p><p>1 ≤ n, m ≤ 100 </p><p><strong>输入样例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5 5</span><br><span class="line">0 1 0 0 0</span><br><span class="line">0 1 0 1 0</span><br><span class="line">0 0 0 0 0</span><br><span class="line">0 1 1 1 0</span><br><span class="line">0 0 0 1 0</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> g[N][N], d[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;PII&gt; q;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">    d[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = t.first + dx[i], y = t.second + dy[i];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; m &amp;&amp; g[x][y] == <span class="number">0</span> &amp;&amp; d[x][y] == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                d[x][y] = d[t.first][t.second] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> d[n <span class="number">-1</span>][m - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )</span><br><span class="line">            cin &gt;&gt; g[i][j];</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><h3 id="树与图的深度优先遍历"><a href="#树与图的深度优先遍历" class="headerlink" title="树与图的深度优先遍历"></a>树与图的深度优先遍历</h3><p>无向图是一种特殊的有向图，搞两条边就可以了</p><p>有向图：邻接矩阵(二维数组)、邻接表(单链表)</p><br><br><h3 id="树与图的广度（宽度）优先遍历"><a href="#树与图的广度（宽度）优先遍历" class="headerlink" title="树与图的广度（宽度）优先遍历"></a>树与图的广度（宽度）优先遍历</h3><br><br><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>有向无环图—&gt;拓扑图<br>分为入度和出度，如果入度为0，说明没有任何点指向当前节点，就是把所有入度为0的点入队</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> que</span><br><span class="line">&#123;</span><br><span class="line">t = 队头;</span><br><span class="line">枚举t的所有出边t-&gt;j</span><br><span class="line">删掉t-&gt;j, d[j] -- ;</span><br><span class="line"><span class="keyword">if</span> d[j] = <span class="number">0</span></span><br><span class="line">d[j]入队</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><h3 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h3><h4 id="1️⃣-单源最短路"><a href="#1️⃣-单源最短路" class="headerlink" title="1️⃣ 单源最短路"></a>1️⃣ 单源最短路</h4><h5 id="1、所有边权都是整数（朴素Dijkstra算法-O-n²-堆优化版的Dijkstra算法-O-mlogn-）"><a href="#1、所有边权都是整数（朴素Dijkstra算法-O-n²-堆优化版的Dijkstra算法-O-mlogn-）" class="headerlink" title="1、所有边权都是整数（朴素Dijkstra算法  O(n²)        堆优化版的Dijkstra算法  O(mlogn)）"></a>1、所有边权都是整数（朴素Dijkstra算法  O(n²)        堆优化版的Dijkstra算法  O(mlogn)）</h5><p><strong>例题</strong></p><p>给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环，所有边权均为非负值。</p><p>请你求出 1 号点到 n 号点的最短距离，如果无法从 1 号点走到 n 号点，则输出 −1。</p><p><strong>输入格式</strong></p><p>第一行包含整数 n 和 m。</p><p>接下来 m 行每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示 1 号点到 nn 号点的最短距离。</p><p>如果路径不存在，则输出 −1。</p><p><strong>数据范围</strong></p><p>1≤n,m≤1.5×10^5<br>图中涉及边长均不小于 0，且不超过 10000<br>数据保证：如果最短路存在，则最短路的长度不超过 10^9.</p><p><strong>输入样例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2 2</span><br><span class="line">2 3 1</span><br><span class="line">1 3 4</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], w[N], idx;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;</span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> ver = t.second, distance = t.first;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[ver]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[ver] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[ver] + w[i];</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">dijkstra</span>());</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2、存在负权边（Bellman-Ford-O-nm-SPFA-O-m-最坏O-nm-）"><a href="#2、存在负权边（Bellman-Ford-O-nm-SPFA-O-m-最坏O-nm-）" class="headerlink" title="2、存在负权边（Bellman-Ford   O(nm)     SPFA O(m),  最坏O(nm)）"></a>2、存在负权边（Bellman-Ford   O(nm)     SPFA O(m),  最坏O(nm)）</h5><p><strong>例题</strong></p><p>给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环， <strong>边权可能为负数</strong>。</p><p>请你求出从 1 号点到 n 号点的最多经过 k 条边的最短距离，如果无法从 1 号点走到 n 号点，输出 <code>impossible</code>。</p><p>注意：图中可能 <strong>存在负权回路</strong> 。</p><p><strong>输入格式</strong></p><p>第一行包含三个整数 n,m,k。</p><p>接下来 m 行，每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。</p><p>点的编号为 1∼n。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示从 1 号点到 n 号点的最多经过 k 条边的最短距离。</p><p>如果不存在满足条件的路径，则输出 <code>impossible</code>。</p><p><strong>数据范围</strong></p><p>1≤n,k≤500，<br>1≤m≤10000,<br>1≤x,y≤n，<br>任意边长的绝对值不超过 10000。</p><p><strong>输入样例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 3 1</span><br><span class="line">1 2 1</span><br><span class="line">2 3 1</span><br><span class="line">1 3 3</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, M = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">int</span> last[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bellman_ford</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    </span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(last, dist, <span class="keyword">sizeof</span> dist);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> e = edges[j];</span><br><span class="line">            dist[e.b] = <span class="built_in">min</span>(dist[e.b], last[e.a] + e.c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        edges[i] = &#123;a, b, c&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">bellman_ford</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (dist[n] &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dist[n]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2️⃣ 多源最短路</p><p>​Floyd算法   O(n³)</p><h4 id="朴素Dijkstra算法（不能存在负权边）"><a href="#朴素Dijkstra算法（不能存在负权边）" class="headerlink" title="朴素Dijkstra算法（不能存在负权边）"></a>朴素Dijkstra算法（不能存在负权边）</h4><p>1️⃣ dist[1] &#x3D; 0,  dist[i] &#x3D;  +♾️           s:当前 已经确定最短距离的点</p><p>2️⃣ for(i: 0 - n)   </p><p>​t&lt;-不在s中的，距离最近的点</p><p>​s&lt;-t   用t更新其它点的距离</p><p>稠密图：邻接矩阵   稀疏图：邻接表</p><p>使用有向图的方法解决无向图的问题</p><p>堆优化版的Dijkstra算法</p><p>存储方式改成邻接表的形式</p><h4 id="Bellman-Ford算法-（有负环-可以用这个）"><a href="#Bellman-Ford算法-（有负环-可以用这个）" class="headerlink" title="Bellman-Ford算法 （有负环  可以用这个）"></a>Bellman-Ford算法 （有负环  可以用这个）</h4><p>​for()   n次</p><p>​for（所有边）  a, b   w    w是   a-&gt; b  的距离</p><p>​dist[b] &#x3D; min (dist[b], dist[a] + w);</p><p>三角不等式  ：dist[b] &lt;&#x3D; dist[a] + w</p><p>​</p><h4 id="SPFA算法（没有负环就可以用这个）"><a href="#SPFA算法（没有负环就可以用这个）" class="headerlink" title="SPFA算法（没有负环就可以用这个）"></a>SPFA算法（没有负环就可以用这个）</h4><p>把起点放到队列里面去</p><p>while queue不空</p><p>​1️⃣ t&lt;-q.front;</p><p>​q.pop();</p><p>​2️⃣更新t的所有出边   t-&gt;（W）   b</p><p>​queue&lt;-b</p><h5 id=""><a href="#" class="headerlink" title=""></a></h5><p>dist[N]最短距离</p><p>cnt[N] 边数</p><p>dist[x]  &#x3D; dist[t] + w[i];</p><p>cnt[x] &#x3D; cnt[t] + 1;</p><p>cnt[x] &gt;&#x3D; n;   经过了n + 1个点</p><p><strong>求最短路径</strong></p><p>给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环， <strong>边权可能为负数</strong>。</p><p>请你求出 1 号点到 n 号点的最短距离，如果无法从 1 号点走到 n 号点，则输出 <code>impossible</code>。</p><p>数据保证不存在负权回路。</p><p><strong>输入格式</strong></p><p>第一行包含整数 n 和 m。</p><p>接下来 m 行每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示 1 号点到 n 号点的最短距离。</p><p>如果路径不存在，则输出 <code>impossible</code>。</p><p><strong>数据范围</strong></p><p>1≤n,m≤10^5，<br>图中涉及边长绝对值均不超过 10000。</p><p><strong>输入样例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2 5</span><br><span class="line">2 3 -3</span><br><span class="line">1 3 4</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    st[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">spfa</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (t == <span class="number">0x3f3f3f3f</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, t);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h4><p>邻接矩阵来存储</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k ++ )</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k] + d[k, j]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// d[i][j]存的是i,j最短的长度</span></span><br></pre></td></tr></table></figure><br><p>给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环，边权可能为负数。</p><p>再给定 k 个询问，每个询问包含两个整数 x 和 y，表示查询从点 x 到点 y 的最短距离，如果路径不存在，则输出 <code>impossible</code>。</p><p>数据保证图中不存在负权回路。</p><p><strong>输入格式</strong></p><p>第一行包含三个整数 n,m,k。</p><p>接下来 m 行，每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。</p><p>接下来 k 行，每行包含两个整数 x,y，表示询问点 x 到点 y 的最短距离。</p><p><strong>输出格式</strong></p><p>共 k 行，每行输出一个整数，表示询问的结果，若询问两点间不存在路径，则输出 <code>impossible</code>。</p><p><strong>数据范围</strong></p><p>1≤n≤200,<br>1≤k≤n^2<br>1≤m≤20000,<br>图中涉及边长绝对值均不超过 10000。</p><p><strong>输入样例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3 3 2</span><br><span class="line">1 2 1</span><br><span class="line">2 3 2</span><br><span class="line">1 3 1</span><br><span class="line">2 1</span><br><span class="line">1 3</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">impossible</span><br><span class="line">1</span><br></pre></td></tr></table></figure><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">210</span>, INF = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, Q;</span><br><span class="line"><span class="type">int</span> d[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">                d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;Q);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span>(i == j) d[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> d[i][j] = INF;</span><br><span class="line">    <span class="comment">// 边读入  以及   邻接矩阵更新      </span></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        d[a][b] = <span class="built_in">min</span>(d[a][b], c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">floyd</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (Q -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> t = d[a][b];</span><br><span class="line">        <span class="keyword">if</span> (t &gt; INF / <span class="number">2</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><p>1️⃣ Prim算法</p><p>​稀疏图：朴素版 O(n²)</p><p>​稠密图：堆优化版  O(mlogn)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dist[i]&lt;- +♾️</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n ; i ++ )</span><br><span class="line">    t&lt;- 找到集合外距离最近的点      <span class="comment">// 一共n次操作   这步就是O(n)</span></span><br><span class="line">    用 t 更新其它点到集合的距离</span><br><span class="line">    st[t]  = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>2️⃣克鲁斯卡尔算法（Kruskal）   O(mlogm)</p><p>一般来说  ，稠密图   朴素版Prim算法    稀疏图   克鲁斯卡尔算法</p><pre><code>现将所有边按照权重从小到大排序O(mlogm)</code></pre><p>​</p><p>​枚举每条边 a, b    权重  c     O(m)</p><p>​if(a, b)不连通</p><p>​将这条边加入集合</p><h3 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h3><p>就是顶点集V可分割为<strong>两个互不相交的子集</strong>，并且<strong>图中每条边依附的两个顶点都分属于这两个互不相交的子集</strong>，两个<strong>子集内的顶点不相邻</strong>。（不一定是连通图）</p><p><img src="https://bu.dusays.com/2025/03/31/67ea4102de5f4.png"></p><p>1️⃣  染色法  O(m + n)</p><p>判断是不是二分图   当且仅当途中不含奇数环（边的数量是奇数）</p><p>对每一个点进行<strong>染色操作</strong>，只用黑白两种颜色；</p><ul><li>💡如果图中存在奇数环（构成环的顶点数量是奇数），那一定不是二分图），下图可以看到，依次选一个点，进行染色（原则是相邻的点要染于该点不同色），奇数环的染色结果会出现矛盾。；【必要性】</li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/2f0207e017a82c1b9ece3fab96f46e09.png" alt="在这里插入图片描述"></p><p>💡如果不含奇数环，一定是二分图【充分性】<br>如果没有奇数环，那么剩下的点的关系就是：偶数环or单链。这两种情况都能保证同一条边上相邻顶点在不同集合中，所以也是成立的；</p><p><img src="https://bu.dusays.com/2025/03/31/67ea42f9a1f97.png"></p><p>💡总结</p><p>用dfs和bfs两种方式去实现,对图进行遍历并染色；由于上面原理可知，二分图一定不含奇数环，不含奇数环的图一定为二分图</p><p>所以，只要在染色过程中不存在矛盾（这里用黑白进行染色，即一个点不能即为黑色，又为红色），整个图遍历完成之后，所有顶点都顺利染上色。就说明这是一个二分图！</p><p>2️⃣ 匈牙利算法 O(mn)     实际运行时间一般远小于O(mn)</p><p>什么是二分图的最大匹配？<br>💡匹配（本质是一个边的集合！）<br>给定一个二分图S，在S的一个子图M中，M的边集{E}中的任意两条边都不依附于同一个顶点，则称M是一个匹配。</p><p>💡极大匹配<br>极大匹配是指在当前已完成的匹配下,无法再通过增加未完成匹配的边的方式来增加匹配的边数。（也就是说，再加入任意一条不在匹配集合中的边，该边肯定有一个顶点已经在集合中的边中了）</p><p>💡最大匹配<br>所有极大匹配当中边数最大的一个匹配</p><p>💡最大匹配问题<br>选择这样的边数最大的子集称为图的最大匹配问题</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> coding日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-stl</title>
      <link href="/2025/03/18/stl/"/>
      <url>/2025/03/18/stl/</url>
      
        <content type="html"><![CDATA[<p>s</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">vector：变长数组， 倍增的思想</span><br><span class="line">size()</span><br><span class="line">empty()</span><br><span class="line">clear()</span><br><span class="line">front()/back()</span><br><span class="line">push_back()/pop_back()</span><br><span class="line">begin() / end()</span><br><span class="line">[]  支持比较运算 </span><br><span class="line"></span><br><span class="line">pair&lt;int, int&gt;</span><br><span class="line">first 第一个元素</span><br><span class="line">second 第二个元素</span><br><span class="line">支持比较运算，以 first 为第一关键字， 以 second 为第二关键字()</span><br><span class="line"></span><br><span class="line">string：字符串，substr()，c_str()</span><br><span class="line">size()</span><br><span class="line">empty()</span><br><span class="line">clear()</span><br><span class="line"></span><br><span class="line">queue, 队列, push(),front(), pop()</span><br><span class="line">push()  队尾插入一个元素 </span><br><span class="line">front() 返回头元素</span><br><span class="line">back() 返回队尾元素</span><br><span class="line">pop()  弹出队头元素</span><br><span class="line"></span><br><span class="line">priority_queue, 优先队列, 默认是大根堆</span><br><span class="line">push()   插入一个元素</span><br><span class="line">top()    返回堆顶元素</span><br><span class="line">pop() 弹出堆顶元素</span><br><span class="line"></span><br><span class="line">stack(), 栈</span><br><span class="line">push()   插入一个元素</span><br><span class="line">top()    返回堆顶元素</span><br><span class="line">pop() 弹出堆顶元素</span><br><span class="line"></span><br><span class="line">deque, 双端队列</span><br><span class="line">size()</span><br><span class="line">empty()</span><br><span class="line">clear()</span><br><span class="line">front()/back()</span><br><span class="line">push_back()/pop_back()</span><br><span class="line">push_front()/pop_front()</span><br><span class="line">begin() / end()</span><br><span class="line"></span><br><span class="line">set, map, multiset, multimap, 基于平衡二叉树(红黑树), 动态维护有序序列</span><br><span class="line">size()</span><br><span class="line">empty()</span><br><span class="line">clear()</span><br><span class="line">begin()/ end() ++, -- 返回前驱后继</span><br><span class="line"></span><br><span class="line">set/multiset</span><br><span class="line">insert()</span><br><span class="line">find()</span><br><span class="line">count()</span><br><span class="line">erase()</span><br><span class="line">(1) 输入是一个数x，删除所有x O(k + logn)</span><br><span class="line">(2) 输入是一个迭代器   删除这个迭代器</span><br><span class="line">lower_bound()/upper_bound()</span><br><span class="line">返回大于等于x最小的数    返回大于x最小的数   不存在返回</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">unordered_set, unordered_map, unordered_multiset,unordered_multimap, 哈希表</span><br><span class="line">bitset, 压位</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> coding日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-哈希表</title>
      <link href="/2025/03/16/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
      <url>/2025/03/16/%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>1、 存储结构</p><p>把一个有非常大值域的 x   直接取模，由于数值很多，取完模之后可能发生冲突，所有有了下面两种处理冲突的方法。</p><p>1️⃣开放寻址法</p><p>2️⃣ 拉链法</p><p>2、字符串哈希方式</p><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p>维护一个集合，支持如下几种操作：</p><ol><li><code>I x</code>，插入一个整数 x；</li><li><code>Q x</code>，询问整数 x 是否在集合中出现过；</li></ol><p>现在要进行 N 次操作，对于每个询问操作输出对应的结果。</p><p><strong>输入格式</strong></p><p>第一行包含整数 N，表示操作数量。</p><p>接下来 N 行，每行包含一个操作指令，操作指令为 <code>I x</code>，<code>Q x</code> 中的一种。</p><p><strong>输出格式</strong></p><p>对于每个询问指令 <code>Q x</code>，输出一个询问结果，如果 x 在集合中出现过，则输出 <code>Yes</code>，否则输出 <code>No</code>。</p><p>每个结果占一行。</p><p><strong>数据范围</strong></p><p>1 ≤ N ≤ 10^5<br>−10^9 ≤ x ≤ 10^9</p><p><strong>输入样例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line">I <span class="number">1</span></span><br><span class="line">I <span class="number">2</span></span><br><span class="line">I <span class="number">3</span></span><br><span class="line">Q <span class="number">2</span></span><br><span class="line">Q <span class="number">5</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br></pre></td></tr></table></figure><p><strong>开放寻址法</strong></p><p>一维数组的长度要开到题目的两到三倍，冲突概率很低。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200003</span>, null = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">while</span> (h[t] != null &amp;&amp; h[t] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        t ++ ;</span><br><span class="line">        <span class="comment">// 到头了，就回到第一个位置</span></span><br><span class="line">        <span class="keyword">if</span> (t == N) t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, op, &amp;x);</span><br><span class="line">        <span class="comment">// 插入操作，直接找有没有这个元素，没有的话，直接找个空白的地方插入</span></span><br><span class="line">        <span class="keyword">if</span> (*op == <span class="string">&#x27;I&#x27;</span>) h[<span class="built_in">find</span>(x)] = x;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (h[<span class="built_in">find</span>(x)] == null) <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>拉链法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100003</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> e[N], ne[N], h[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = h[k];</span><br><span class="line">    h[k] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[k]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        <span class="keyword">if</span> (e[i] == x)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, op, &amp;x);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (*op == <span class="string">&#x27;I&#x27;</span>) <span class="built_in">insert</span>(x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(x)) <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">头节点（索引为 h[k]） -&gt; 节点1 -&gt; 节点2 -&gt; ...</span><br><span class="line">新头节点（new_node） -&gt; 原头节点 -&gt; 节点1 -&gt; 节点2 -&gt; ...</span><br></pre></td></tr></table></figure><br><br><h4 id="哈希字符串"><a href="#哈希字符串" class="headerlink" title="哈希字符串"></a>哈希字符串</h4><p><strong>解题思路</strong>：<br>在哈希表中，要查找一个元素，能通过 哈希函数 计算出其对应的 哈希值，直接查询。<br>在理想的情况下，元素与其哈希值 一 一对应。</p><p>在字符串哈希中，对于给定的字符串 ( 子串 ) ，也能求出其对应的哈希值。</p><p>若两个字符串 ( 子串 ) 的 哈希值完全相同，则就能断定两个字符串 ( 子串 ) 完全相同。</p><p><strong>字符串哈希具体实现</strong></p><p>注意：① 不能映射成0   ② 假定Rp足够好，不存在冲突</p><p><strong>题目</strong></p><p>给定一个长度为 n 的字符串，再给定 m 个询问，每个询问包含四个整数 l1,r1,l2,r2，请你判断 [l1,r1][l1,r1] 和 [l2,r2][l2,r2] 这两个区间所包含的字符串子串是否完全相同。</p><p>字符串中只包含大小写英文字母和数字。</p><p><strong>输入格式</strong></p><p>第一行包含整数 n 和 m ，表示字符串长度和询问次数。</p><p>第二行包含一个长度为 n 的字符串，字符串中只包含大小写英文字母和数字。</p><p>接下来 m 行，每行包含四个整数 l1, r1, l2, r2，表示一次询问所涉及的两个区间。</p><p>注意，字符串的位置从 1 开始编号。</p><p><strong>输出格式</strong></p><p>对于每个询问输出一个结果，如果两个字符串子串完全相同则输出 <code>Yes</code>，否则输出 <code>No</code>。</p><p>每个结果占一行。</p><p><strong>数据范围</strong></p><p>1 ≤ n , m ≤ 10^5</p><p><strong>输入样例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">8 3</span><br><span class="line">aabbaabb</span><br><span class="line">1 3 5 7</span><br><span class="line">1 3 6 8</span><br><span class="line">1 2 1 2</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">Yes</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通方法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, P = <span class="number">131</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line">ULL p[N], h[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        h[i] = h[i - <span class="number">1</span>] * P + str[i];</span><br><span class="line">        p[i] = p[i - <span class="number">1</span>] * P;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l1, r1, l2, r2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;l1, &amp;r1, &amp;l2, &amp;r2);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">get</span>(l1, r1) == <span class="built_in">get</span>(l2, r2)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> coding日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-堆</title>
      <link href="/2025/03/16/%E5%A0%86/"/>
      <url>/2025/03/16/%E5%A0%86/</url>
      
        <content type="html"><![CDATA[<h4 id="如何手写一个堆？"><a href="#如何手写一个堆？" class="headerlink" title="如何手写一个堆？"></a>如何手写一个堆？</h4><p>1、 插入一个数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">heap[ ++ size] = x;</span><br><span class="line">up[size];</span><br></pre></td></tr></table></figure><p>2、 求集合中的最小值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">heap[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>3、 删除最小值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">heap[<span class="number">1</span>] = heap[size];</span><br><span class="line">size -- ;</span><br><span class="line"><span class="built_in">down</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>4、 删除任意一个元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">heap[k] = heap[size];</span><br><span class="line">size -- ;</span><br><span class="line"><span class="built_in">down</span>(k);</span><br><span class="line"><span class="built_in">up</span>(k);</span><br></pre></td></tr></table></figure><p>5、 修改任意一个元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">heap[k] = x;</span><br><span class="line"><span class="built_in">down</span>(k);</span><br><span class="line"><span class="built_in">up</span>(k);</span><br></pre></td></tr></table></figure><p><strong>堆是一个完全二叉树</strong></p><br><p><strong>小根堆</strong>：根节点就是最小值，   每个点都满足小于左右两个点</p><p><strong>存储</strong>：使用一维数组来存储， 一号点是根节点，x的左儿子  2x，  右儿子 是  2x + 1</p><br><p><strong>堆的两种操作</strong></p><p>1、 down   2、 up</p><h4 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h4><p>输入一个长度为 n 的整数数列，从小到大输出前 m 小的数。</p><p><strong>输入格式</strong></p><p>第一行包含整数 n 和 m。</p><p>第二行包含 n 个整数，表示整数数列。</p><p><strong>输出格式</strong></p><p>共一行，包含 m 个整数，表示整数数列中前 m 小的数。</p><p><strong>数据范围</strong></p><p>1 ≤ m ≤ n ≤ 10^5<br>1 ≤ 数列中元素 ≤ 10^9</p><p><strong>输入样例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">1</span> <span class="number">3</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N  = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> &lt;= cnt &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t]) t = u * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> + <span class="number">1</span> &lt;= cnt &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u != t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[u], h[t]);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  虽然这道题不需要up,这里也给出up操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (u / <span class="number">2</span> &amp;&amp; h[u / <span class="number">2</span>] &gt; h[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[u / <span class="number">2</span>], h[u]);</span><br><span class="line">        u /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;h[i]);</span><br><span class="line">    cnt = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span>; i; i -- ) <span class="built_in">down</span>(i);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, h[<span class="number">1</span>]);</span><br><span class="line">        h[<span class="number">1</span>] = h[cnt -- ];</span><br><span class="line">        <span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h4><p>维护一个集合，初始时集合为空，支持如下几种操作：</p><ol><li><code>I x</code>，插入一个数 xx；</li><li><code>PM</code>，输出当前集合中的最小值；</li><li><code>DM</code>，删除当前集合中的最小值（数据保证此时的最小值唯一）；</li><li><code>D k</code>，删除第 kk 个插入的数；</li><li><code>C k x</code>，修改第 k 个插入的数，将其变为 x；</li></ol><p>现在要进行 N 次操作，对于所有第 2 个操作，输出当前集合的最小值。</p><p><strong>输入格式</strong></p><p>第一行包含整数 NN。</p><p>接下来 NN 行，每行包含一个操作指令，操作指令为 <code>I x</code>，<code>PM</code>，<code>DM</code>，<code>D k</code> 或 <code>C k x</code> 中的一种。</p><p><strong>输出格式</strong></p><p>对于每个输出指令 <code>PM</code>，输出一个结果，表示当前集合中的最小值。</p><p>每个结果占一行。</p><p><strong>数据范围</strong></p><p>1 ≤ N ≤ 10^5<br>−10^9 ≤ x ≤ 10^9<br>数据保证合法。</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span></span><br><span class="line">I <span class="number">-10</span></span><br><span class="line">PM</span><br><span class="line">I <span class="number">-10</span></span><br><span class="line">D <span class="number">1</span></span><br><span class="line">C <span class="number">2</span> <span class="number">8</span></span><br><span class="line">I <span class="number">6</span></span><br><span class="line">PM</span><br><span class="line">DM</span><br></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">-10</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ph[k] 表示第 k 个插入的元素在堆数组中的下标</span></span><br><span class="line"><span class="comment">// hp[k] 表示堆数组 h 中第 k 个位置的元素是第几个插入的。</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N], ph[N], hp[N], cnt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里传入的是下标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(ph[hp[a]], ph[hp[b]]);</span><br><span class="line">    swap[hp[a], hp[b]];</span><br><span class="line">    <span class="built_in">swap</span>(h[a], h[b]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> &lt;= cnt &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t]) t = u * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> + <span class="number">1</span> &lt;= cnt &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u != t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 交换下标即可</span></span><br><span class="line">        <span class="built_in">heap_swap</span>(u, t);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (u / <span class="number">2</span> &amp;&amp; h[u] &lt; h[u / <span class="number">2</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, u / <span class="number">2</span>);</span><br><span class="line">         u /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">5</span>];</span><br><span class="line">        <span class="type">int</span> k, x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(op, <span class="string">&quot;I&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">            cnt ++ ;</span><br><span class="line">            m ++ ;</span><br><span class="line">            ph[m] = cnt, hp[cnt] = m;</span><br><span class="line">            h[cnt] = x;</span><br><span class="line">            <span class="built_in">up</span>(cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(op, <span class="string">&quot;PM&quot;</span>)) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, h[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(op, <span class="string">&quot;DM&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">heap_swap</span>(<span class="number">1</span>, cnt);</span><br><span class="line">            cnt -- ;</span><br><span class="line">            <span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">&quot;D&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">            k = ph[k];</span><br><span class="line">            <span class="built_in">heap_swap</span>(k, cnt);</span><br><span class="line">            cnt -- ;</span><br><span class="line">            <span class="built_in">up</span>(k);</span><br><span class="line">            <span class="built_in">down</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;k, &amp;x);</span><br><span class="line">            k = ph[k];</span><br><span class="line">            h[k] = x;</span><br><span class="line">            <span class="built_in">up</span>(k);</span><br><span class="line">            <span class="built_in">down</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> coding日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KMP算法</title>
      <link href="/2025/03/16/KMP%E7%AE%97%E6%B3%95/"/>
      <url>/2025/03/16/KMP%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> coding日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-并查集</title>
      <link href="/2025/03/16/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
      <url>/2025/03/16/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h4 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h4><p>1、 将两个集合合并。</p><p>2、 询问两个元素是否在一个集合当中。</p><p><strong>基本原理</strong>：每个集合用一棵树来表示。树根的编号就是整个集合的编号。每个节点存储它的父节点，p[x]表示x的父节点。</p><p><strong>问题1</strong>：如何判断树根 ： if(p[x] &#x3D;&#x3D; x)</p><p><strong>问题2</strong>：如何求x的集合编号： while (p[x] !&#x3D; x) x &#x3D; p[x];</p><p><strong>问题3</strong>： 如何合并两个集合： px是x的集合编号，py是y的集合编号，让p[x] &#x3D; y，  这样就完成合并了。</p><h4 id="合并集合"><a href="#合并集合" class="headerlink" title="合并集合"></a>合并集合</h4><p>一共有 nn 个数，编号是 1∼n1∼n，最开始每个数各自在一个集合中。</p><p>现在要进行 mm 个操作，操作共有两种：</p><ol><li><code>M a b</code>，将编号为 a 和 b 的两个数所在的集合合并，如果两个数已经在同一个集合中，则忽略这个操作；</li><li><code>Q a b</code>，询问编号为 a  和 b 的两个数是否在同一个集合中；</li></ol><p><strong>输入格式</strong></p><p>第一行输入整数 n 和 m。</p><p>接下来 m 行，每行包含一个操作指令，指令为 <code>M a b</code> 或 <code>Q a b</code> 中的一种。</p><p><strong>输出格式</strong></p><p>对于每个询问指令 <code>Q a b</code>，都要输出一个结果，如果 a 和 b 在同一集合内，则输出 <code>Yes</code>，否则输出 <code>No</code>。</p><p>每个结果占一行。</p><p><strong>数据范围</strong></p><p>1≤n,m≤10^5</p><p><strong>输入样例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">4 5</span><br><span class="line">M 1 2</span><br><span class="line">M 3 4</span><br><span class="line">Q 1 2</span><br><span class="line">Q 1 3</span><br><span class="line">Q 3 4</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">Yes</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">// 返回祖宗节点 + 路径压缩</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i ++ ) p[i] = i;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (m -- ) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>, op, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">if</span> (*op == <span class="string">&#x27;M&#x27;</span>) p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>路径压缩逻辑</strong>：</p><ul><li><code>if (p[x] != x)</code>：这是一个条件判断语句，<code>p</code> 是一个数组，<code>p[x]</code> 表示元素 <code>x</code> 的父节点。如果 <code>p[x]</code> 不等于 <code>x</code>，说明 <code>x</code> 不是它所在集合的祖宗节点（因为祖宗节点的父节点是它本身）。</li><li><code>p[x] = find(p[x]);</code>：如果 <code>x</code> 不是祖宗节点，那么递归调用 <code>find</code> 函数查找 <code>p[x]</code> 的祖宗节点，并将 <code>x</code> 的父节点直接设置为这个祖宗节点。这样，在后续查找 <code>x</code> 或其子孙节点的祖宗节点时，就可以直接找到，避免了重复查找，实现了路径压缩。</li></ul><h4 id="连通块中点的数量"><a href="#连通块中点的数量" class="headerlink" title="连通块中点的数量"></a>连通块中点的数量</h4><p>给定一个包含 n个点（编号为 1∼n）的无向图，初始时图中没有边。</p><p>现在要进行 m 个操作，操作共有三种：</p><ol><li><code>C a b</code>，在点 a 和点 b 之间连一条边，a 和 b 可能相等；</li><li><code>Q1 a b</code>，询问点 a 和点 b 是否在同一个连通块中，a 和 b 可能相等；</li><li><code>Q2 a</code>，询问点 a 所在连通块中点的数量；</li></ol><p><strong>输入格式</strong></p><p>第一行输入整数 n 和 m。</p><p>接下来 m 行，每行包含一个操作指令，指令为 <code>C a b</code>，<code>Q1 a b</code> 或 <code>Q2 a</code> 中的一种。</p><p><strong>输出格式</strong></p><p>对于每个询问指令 <code>Q1 a b</code>，如果 a 和 b 在同一个连通块中，则输出 <code>Yes</code>，否则输出 <code>No</code>。</p><p>对于每个询问指令 <code>Q2 a</code>，输出一个整数表示点 a 所在连通块中点的数量</p><p>每个结果占一行。</p><p><strong>数据范围</strong></p><p>1≤n,m≤10^5</p><p><strong>输入样例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">5</span></span><br><span class="line">C <span class="number">1</span> <span class="number">2</span></span><br><span class="line">Q1 <span class="number">1</span> <span class="number">2</span></span><br><span class="line">Q2 <span class="number">1</span></span><br><span class="line">C <span class="number">2</span> <span class="number">5</span></span><br><span class="line">Q2 <span class="number">5</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> p[N], cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">// 返回祖宗节点 + 路径压缩</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i ++ ) </span><br><span class="line">    &#123;</span><br><span class="line">p[i] = i;</span><br><span class="line">        cnt[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (m -- ) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">5</span>];</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (op[<span class="number">0</span>] == <span class="string">&#x27;C&#x27;</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b)) <span class="keyword">continue</span>;</span><br><span class="line">            cnt[<span class="built_in">find</span>(b)] += cnt[<span class="built_in">find</span>(a)];</span><br><span class="line">            p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op[<span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cnt[<span class="built_in">find</span>(a)]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="食物链"><a href="#食物链" class="headerlink" title="食物链"></a>食物链</h4><p>动物王国中有三类动物 A,B,C这三类动物的食物链构成了有趣的环形。</p><p>A 吃 B，B吃 C，C吃A。</p><p>现有 N 个动物，以 1∼N 编号。</p><p>每个动物都是 A,B,C中的一种，但是我们并不知道它到底是哪一种。</p><p>有人用两种说法对这 N 个动物所构成的食物链关系进行描述：</p><p>第一种说法是 <code>1 X Y</code>，表示 X 和 Y 是同类。</p><p>第二种说法是 <code>2 X Y</code>，表示 X 吃 Y。</p><p>此人对 N 个动物，用上述两种说法，一句接一句地说出 K 句话，这 K 句话有的是真的，有的是假的。</p><p>当一句话满足下列三条之一时，这句话就是假话，否则就是真话。</p><ol><li>当前的话与前面的某些真的话冲突，就是假话；</li><li>当前的话中 X 或 Y 比 N 大，就是假话；</li><li>当前的话表示 X 吃 X，就是假话。</li></ol><p>你的任务是根据给定的 N 和 K 句话，输出假话的总数。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行是两个整数 N 和 K，以一个空格分隔。</p><p>以下 K 行每行是三个正整数 D，X，Y两数之间用一个空格隔开，其中 DD 表示说法的种类。</p><p>若 D&#x3D;1，则表示 X 和 Y 是同类。</p><p>若 D&#x3D;2，则表示 X 吃 Y。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>只有一个整数，表示假话的数目。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1 ≤ N ≤ 50000,<br>0 ≤ K ≤ 100000</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">100 7</span><br><span class="line">1 101 1 </span><br><span class="line">2 1 2</span><br><span class="line">2 2 3 </span><br><span class="line">2 3 3 </span><br><span class="line">1 1 3 </span><br><span class="line">2 3 1 </span><br><span class="line">1 5 5</span><br></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">50010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> p[N], d[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="built_in">find</span>(p[x]);</span><br><span class="line">        d[x] += d[p[x]];</span><br><span class="line">        p[x] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t, x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;t, &amp;x, &amp;y);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (x &gt; n || y &gt; n) res ++ ;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> px = <span class="built_in">find</span>(x), py = <span class="built_in">find</span>(y);</span><br><span class="line">            <span class="keyword">if</span>(t == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (px == py &amp;&amp; (d[x] - d[y]) % <span class="number">3</span>) res ++ ;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (px != py)</span><br><span class="line">                &#123;</span><br><span class="line">                    p[px] = py;</span><br><span class="line">                    d[px] = d[y] - d[x];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (px == py &amp;&amp; (d[x] - d[y] - <span class="number">1</span>) % <span class="number">3</span>) res ++ ;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(px != py)</span><br><span class="line">                &#123;</span><br><span class="line">                    p[px] = p[y];</span><br><span class="line">                    d[px] = d[y] + <span class="number">1</span> - d[x];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> coding日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt09TCP-IP网络通信</title>
      <link href="/2025/03/13/Qt09TCP-IP%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"/>
      <url>/2025/03/13/Qt09TCP-IP%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<p>TCP&#x2F;IP通信（即SOCKET通信）是通过网线将<strong>服务器Server端</strong>和<strong>客户机Client端</strong>进行连接，在遵循ISO&#x2F;OSI模型的四层层级构架的基础上通过TCP&#x2F;IP协议建立的通讯。控制器可以设置为服务器端或客户端。</p><p>关于TCP&#x2F;IP协议可详看：<a href="https://zhuanlan.zhihu.com/p/33889997">TCP&#x2F;IP协议详解 - 知乎 (zhihu.com)</a></p><p> 总的来说，TCP&#x2F;IP通讯有两个部分：</p><ul><li><strong>客户端</strong>和<strong>服务器</strong></li><li><strong>QTcpServer（监听套接字）<strong>和</strong>QTcpSocket（通讯套接字）</strong></li></ul><p>监听套接字，顾名思义，监听关于各种通讯的状态，一旦进行通讯，监听套接字会启动通讯套接字，进行通讯</p><p>客户端使用connectToHost函数主动连接服务器后，服务器会触发newConnectio这个槽函数，并进行取出QTcpServer（监听套接字），将相关内容取出并赋给QTcpSocket（通讯套接字）。<br>客户端向服务器发送数据，触发readyRead（），进行处理，彼此传递时，原理都是这样的。</p><p><strong>对双方来说都起作用的部分：</strong></p><ol><li>一旦建立连接，就会触发connected，服务器特殊一点，触发的是newConnectio</li><li>互传数据也是一样的，一旦接受到，就会触发readyread</li></ol><p>服务器中，需要监听套接字以及通讯套接字，监听套接字用于监听客户端是否给服务器发送请求</p><p>本篇博文做了初步的学习与尝试，编写了一个客户端和服务器基于窗口通信以及文件传输的小例程。</p><h3 id="一，客户端"><a href="#一，客户端" class="headerlink" title="一，客户端"></a><font color="FF0000">一，客户端</font></h3><p>客户端的代码比服务器稍简单，总的来说，使用QT中的<strong>QTcpSocket类</strong>与服务器进行通信只需要以下5步：</p><p><strong>（1）创建QTcpSocket套接字对象</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket = new QTcpSocket(this);</span><br></pre></td></tr></table></figure><p><strong>（2）使用这个对象连接服务器</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QString ip = ui.lineEdit_ip-&gt;text();//获取ip</span><br><span class="line">int port = ui.lineEdit_2-&gt;text().toInt();//获取端口数据</span><br><span class="line">socket-&gt;connectToHost(ip, port);</span><br></pre></td></tr></table></figure><p><strong>（3）使用write函数向服务器发送数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QByteArray data = ui.lineEdit_3-&gt;text().toUtf8();//获取lineEdit控件中的数据并发送给服务器</span><br><span class="line">socket-&gt;write(data);</span><br></pre></td></tr></table></figure><p> <strong>（4）当socket接收缓冲区有新数据到来时，会发出readRead()信号，因此为该信号添加槽函数以读取数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> connect(socket, &amp;QTcpSocket::readyRead, this, &amp;QTcpClinet::ReadData);</span><br><span class="line">void QTcpClinet::ReadData()</span><br><span class="line">&#123;</span><br><span class="line">    QByteArray buf = socket-&gt;readAll();</span><br><span class="line">    ui.textEdit-&gt;append(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（5）断开与服务器的连接（关于close()和disconnectFromHost()的区别，可以按F1看帮助）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket-&gt;disconnectFromHost();</span><br></pre></td></tr></table></figure><p><strong>客户端例程：（新建一个qt项目QTcpClinet（客户机））</strong></p><ul><li><strong>ui界面</strong></li></ul><p><img src="https://bu.dusays.com/2025/03/13/67d2dbe2f1a93.png"></p><p>本地回路ip：127.0.0.1 可以连接到本地ip（电脑内部循环的ip）</p><p>如果要和局域网其他ip连接 -&gt; 在运行（win+R）+cmd+ipconfig -&gt;ipv4地址 查看本机ip</p><ul><li><strong>QTcpClinet.h</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;QtWidgets/QWidget&gt;</span><br><span class="line">#include &quot;ui_QTcpClinet.h&quot;</span><br><span class="line">#include&quot;QTcpSocket.h&quot;</span><br><span class="line">#pragma execution_character_set(&quot;utf-8&quot;)</span><br><span class="line">class QTcpClinet : public QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    QTcpClinet(QWidget *parent = Q_NULLPTR);</span><br><span class="line">    ~QTcpClinet();</span><br><span class="line">public slots:</span><br><span class="line">    void on_btn_connect_clicked();</span><br><span class="line">    void ReadData();</span><br><span class="line">    void on_btn_push_clicked();</span><br><span class="line">private:</span><br><span class="line">    Ui::QTcpClinetClass ui;</span><br><span class="line">    QTcpSocket* socket;//创建socket指针</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>QTcpClinet.cpp</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;QTcpClinet.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">QTcpClinet::<span class="built_in">QTcpClinet</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    ui.<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    socket = <span class="keyword">new</span> <span class="built_in">QTcpSocket</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QTcpClinet::~<span class="built_in">QTcpClinet</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;socket;<span class="comment">//回收内存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTcpClinet::on_btn_connect_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ui.btn_connect-&gt;<span class="built_in">text</span>()==<span class="built_in">tr</span>(<span class="string">&quot;连接服务器&quot;</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    QString ip = ui.lineEdit_ip-&gt;<span class="built_in">text</span>();<span class="comment">//获取ip</span></span><br><span class="line">    <span class="type">int</span> port = ui.lineEdit_2-&gt;<span class="built_in">text</span>().<span class="built_in">toInt</span>();<span class="comment">//获取端口数据</span></span><br><span class="line">    <span class="comment">//取消已有的连接</span></span><br><span class="line">    socket-&gt;<span class="built_in">abort</span>();</span><br><span class="line">    <span class="comment">//连接服务器</span></span><br><span class="line">    socket-&gt;<span class="built_in">connectToHost</span>(ip, port);</span><br><span class="line">    <span class="type">bool</span> isconnect = socket-&gt;<span class="built_in">waitForConnected</span>();<span class="comment">//等待直到连接成功</span></span><br><span class="line">    <span class="comment">//如果连接成功</span></span><br><span class="line">    <span class="keyword">if</span> (isconnect)</span><br><span class="line">    &#123;</span><br><span class="line">        ui.textEdit-&gt;<span class="built_in">append</span>(<span class="string">&quot;The connection was successful!!&quot;</span>);</span><br><span class="line">        ui.btn_push-&gt;<span class="built_in">setEnabled</span>(<span class="literal">true</span>);<span class="comment">//按钮使能</span></span><br><span class="line">        <span class="comment">//修改按键文字</span></span><br><span class="line">        ui.btn_connect-&gt;<span class="built_in">setText</span>(<span class="string">&quot;断开服务器连接&quot;</span>);</span><br><span class="line">        <span class="comment">//接收缓冲区（服务器）信息</span></span><br><span class="line">        <span class="built_in">connect</span>(socket, &amp;QTcpSocket::readyRead, <span class="keyword">this</span>, &amp;QTcpClinet::ReadData);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ui.textEdit-&gt;<span class="built_in">append</span>(<span class="string">&quot;The connection falied!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">//断开连接</span></span><br><span class="line">      socket-&gt;<span class="built_in">disconnectFromHost</span>();</span><br><span class="line">      ui.btn_connect-&gt;<span class="built_in">setText</span>(<span class="string">&quot;连接服务器&quot;</span>);</span><br><span class="line">      ui.btn_push-&gt;<span class="built_in">setEnabled</span>(<span class="literal">false</span>);<span class="comment">//关闭发送按钮使能</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收缓冲区信息函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTcpClinet::ReadData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QByteArray buf = socket-&gt;<span class="built_in">readAll</span>();</span><br><span class="line">    ui.textEdit-&gt;<span class="built_in">append</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//发送按钮事件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTcpClinet::on_btn_push_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QByteArray data = ui.lineEdit_3-&gt;<span class="built_in">text</span>().<span class="built_in">toUtf8</span>();<span class="comment">//获取lineEdit控件中的数据并发送给服务器</span></span><br><span class="line">    socket-&gt;<span class="built_in">write</span>(data);</span><br><span class="line">    <span class="comment">//判断是否写入成功</span></span><br><span class="line">    <span class="type">bool</span> iswrite = socket-&gt;<span class="built_in">waitForBytesWritten</span>();</span><br><span class="line">    <span class="keyword">if</span> (iswrite)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//写入成功</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//没有写入成功</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二，服务器（需要一直运行哦）"><a href="#二，服务器（需要一直运行哦）" class="headerlink" title="二，服务器（需要一直运行哦）"></a><font color="FF0000">二，服务器（需要一直运行哦）</font></h3><p>服务器除了使用到了<strong>QTcpSocket类</strong>，还需要用到<strong>QTcpSever类</strong>。即便如此，也只是比客户端复杂一点点，用到了6个步骤：</p><p><strong>（1）创建QTcpSever对象</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server = new QTcpServer(this);</span><br></pre></td></tr></table></figure><p><strong>（2）侦听一个端口，使得客户端可以使用这个端口访问服务器</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server-&gt;listen(QHostAddress::Any, 6677);//监听所有ip和6677端口</span><br></pre></td></tr></table></figure><p><strong>（3）当服务器被客户端访问时，会发出newConnection()信号，因此为该信号添加槽函数，并用一个QTcpSocket对象接受客户端访问</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">connect(server, &amp;QTcpServer::newConnection, this, &amp;TcpServer::ClientConnect);</span><br><span class="line">void TcpServer::ClientConnect()</span><br><span class="line">&#123;</span><br><span class="line">    //解析所有客户连接</span><br><span class="line">    while (server-&gt;hasPendingConnections())</span><br><span class="line">    &#123;</span><br><span class="line">        //连接上后通过socket（QTcpSocket对象）获取连接信息</span><br><span class="line">        socket = server-&gt;nextPendingConnection();</span><br><span class="line">        QString str = QString(&quot;[ip:%1,port:%2]&quot;).arg(socket-&gt;peerAddress().toString()).arg(socket-&gt;peerPort());//监听客户端是否有消息发送</span><br><span class="line">        connect(socket, &amp;QTcpSocket::readyRead, this, &amp;TcpServer::ReadData1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（4）使用socket的write函数向客户端发送数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket-&gt;write(data);</span><br></pre></td></tr></table></figure><p><strong>（5）当socket接收缓冲区有新数据到来时，会发出readRead()信号，因此为该信号添加槽函数以读取数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//监听客户端是否有消息发送</span><br><span class="line">connect(socket, &amp;QTcpSocket::readyRead, this, &amp;TcpServer::ReadData1);</span><br><span class="line">//获取客户端向服务器发送的信息</span><br><span class="line">void TcpServer::ReadData1()</span><br><span class="line">&#123;</span><br><span class="line">    QByteArray buf = socket-&gt;readAll();//readAll最多接收65532的数据</span><br><span class="line">    QString str = QString(&quot;[ip:%1,port:%2]&quot;).arg(socket-&gt;peerAddress().toString()).arg(socket-&gt;peerPort());</span><br><span class="line">    ui.textEdit_server-&gt;append(str +QString(buf));</span><br><span class="line">    //socket-&gt;write(&quot;ok&quot;);//服务器接收到信息后返回一个ok</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（6）取消侦听</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server-&gt;close();</span><br></pre></td></tr></table></figure><p> <strong>服务器例程：（添加一个新的qt项目TcpServer（服务器））</strong></p><ul><li><strong>ui界面</strong></li></ul><p><img src="https://bu.dusays.com/2025/03/13/67d2dc19a7d8f.png"></p><ul><li><strong>TcpServer.h</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;QtWidgets/QWidget&gt;</span><br><span class="line">#include&quot;ui_TcpServer.h&quot;</span><br><span class="line">#include&quot;qtcpserver.h&quot;</span><br><span class="line">#include&quot;qtcpsocket.h&quot;</span><br><span class="line"></span><br><span class="line">class TcpServer : public QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    TcpServer(QWidget *parent = Q_NULLPTR);</span><br><span class="line">    ~TcpServer();</span><br><span class="line">public slots:</span><br><span class="line">    void on_btn_server_clicked();</span><br><span class="line">    void on_btn_listen_clicked();</span><br><span class="line">private:</span><br><span class="line">    Ui::TcpServerClass ui;</span><br><span class="line">    QTcpServer* server;</span><br><span class="line">    QTcpSocket* socket;//一个客户端对应一个socket</span><br><span class="line">    void ClientConnect();</span><br><span class="line">    void ReadData1();</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>TcpServer.cpp</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;TcpServer.h&quot;</span><br><span class="line">#include&quot;qstring.h&quot;</span><br><span class="line">#include&quot;qdebug.h&quot;</span><br><span class="line">#pragma execution_character_set(&quot;utf-8&quot;)</span><br><span class="line">TcpServer::TcpServer(QWidget *parent)</span><br><span class="line">    : QWidget(parent)</span><br><span class="line">&#123;</span><br><span class="line">    ui.setupUi(this);</span><br><span class="line">    server = new QTcpServer(this);</span><br><span class="line">   //客户机连接信号槽</span><br><span class="line">    connect(server, &amp;QTcpServer::newConnection, this, &amp;TcpServer::ClientConnect);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TcpServer::~TcpServer()</span><br><span class="line">&#123;</span><br><span class="line">    server-&gt;close();</span><br><span class="line">    server-&gt;deleteLater();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TcpServer::on_btn_listen_clicked()</span><br><span class="line">&#123;</span><br><span class="line">    if (ui.btn_listen-&gt;text()==&quot;侦听&quot;)</span><br><span class="line">    &#123;</span><br><span class="line">        //从输入框获取端口号</span><br><span class="line">        int port = ui.lineEdit_port-&gt;text().toInt();</span><br><span class="line">        //侦听指定端口的所有ip</span><br><span class="line">        if (!server-&gt;listen(QHostAddress::Any, port))</span><br><span class="line">        &#123;</span><br><span class="line">            //若出错，则输出错误信息</span><br><span class="line">            qDebug() &lt;&lt; server-&gt;errorString();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //修改按键文字</span><br><span class="line">        ui.btn_listen-&gt;setText(&quot;取消侦听&quot;);    </span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        socket-&gt;abort();</span><br><span class="line">        //取消侦听</span><br><span class="line">        server-&gt;close();</span><br><span class="line">        //修改按键文字</span><br><span class="line">        ui.btn_listen-&gt;setText(&quot;侦听&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TcpServer::ClientConnect()</span><br><span class="line">&#123;</span><br><span class="line">    //解析所有客户连接</span><br><span class="line">    while (server-&gt;hasPendingConnections())</span><br><span class="line">    &#123;</span><br><span class="line">        //连接上后通过socket获取连接信息</span><br><span class="line">        socket = server-&gt;nextPendingConnection();</span><br><span class="line">        QString str = QString(&quot;[ip:%1,port:%2]&quot;).arg(socket-&gt;peerAddress().toString()).arg(socket-&gt;peerPort());</span><br><span class="line">        //提示连接成功</span><br><span class="line">        ui.textEdit_server-&gt;append(str+&quot;Connect to the server&quot;);</span><br><span class="line">        //复选框选项为连接服务器的ip</span><br><span class="line">        ui.comboBox-&gt;addItem(str);</span><br><span class="line">        //将socket地址放入combobox属性内</span><br><span class="line">        //ui.comboBox-&gt;setItemData(ui.comboBox-&gt;count()-1, QVariant((int)socket));</span><br><span class="line">        //监听客户端是否有消息发送</span><br><span class="line">        connect(socket, &amp;QTcpSocket::readyRead, this, &amp;TcpServer::ReadData1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//获取客户端向服务器发送的信息</span><br><span class="line">void TcpServer::ReadData1()</span><br><span class="line">&#123;</span><br><span class="line">    QByteArray buf = socket-&gt;readAll();//readAll最多接收65532的数据</span><br><span class="line">    QString str = QString(&quot;[ip:%1,port:%2]&quot;).arg(socket-&gt;peerAddress().toString()).arg(socket-&gt;peerPort());</span><br><span class="line">    ui.textEdit_server-&gt;append(str +QString(buf));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//服务器向客户端发送信息</span><br><span class="line">void TcpServer::on_btn_server_clicked()</span><br><span class="line">&#123;</span><br><span class="line">  if(ui.comboBox-&gt;count()== 0)return;</span><br><span class="line">  //QTcpSocket* skt=  (QTcpSocket*)ui.comboBox-&gt;itemData(ui.comboBox-&gt;currentIndex()).value&lt;int&gt;();</span><br><span class="line">  socket-&gt;write(ui.lineEdit1-&gt;text().toUtf8());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：write中需要写入char类型的元素或QByteArray类型的元素</p><p><img src="https://bu.dusays.com/2025/03/13/67d2dc2f4307e.png"></p><p><strong>效果展示：</strong></p><p><img src="https://bu.dusays.com/2025/03/13/67d2dc5b93345.gif"></p><h3 id="三，TCP-IP文件传输"><a href="#三，TCP-IP文件传输" class="headerlink" title="三，TCP&#x2F;IP文件传输"></a><font color="FF0000">三，TCP&#x2F;IP文件传输</font></h3><p>上文实现了消息的传输，由于<strong>socket-&gt;readAll();（readAll最多接收65532的数据）</strong>，因此对于大文件的传输用此方法是不可取的。</p><p><strong>TCP&#x2F;IP文件传输的思路：</strong></p><ol><li>客户端和服务器连接</li><li>客户端选择文件，并发送文件给服务器（发送的是文件的帧头，格式：文件名&amp;大小）</li><li>服务器触发readyRead，然后解析文件帧头（获取文件名和大小），并返回客户端一个ok消息</li><li>客户端触发readyRead，然后发送文件数据，通过progressBar显示进度</li><li>服务器再次触发readyRead，接收文件数据，并保存（通过ishead判断接收的是文件帧头还是文件数据）</li></ol><p><strong>代码实现：</strong></p><p>新建服务器项目（TcpServer）</p><ul><li><strong>TcpServer.h</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">#include &lt;QtWidgets/QWidget&gt;</span><br><span class="line">#include &quot;ui_TcpServer.h&quot;</span><br><span class="line">#include&quot;qtcpserver.h&quot;</span><br><span class="line">#include&quot;qtcpsocket.h&quot;</span><br><span class="line">#pragma execution_character_set(&quot;utf-8&quot;)</span><br><span class="line">class TcpServer : public QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    TcpServer(QWidget *parent = Q_NULLPTR);</span><br><span class="line">    void hasConnect();</span><br><span class="line">private:</span><br><span class="line">    Ui::TcpServerClass ui;</span><br><span class="line">    QTcpServer* server;</span><br><span class="line">    QTcpSocket* socket;</span><br><span class="line">    bool ishead;</span><br><span class="line">    QString fileName;</span><br><span class="line">    int fileSize;//接收文件的总大小</span><br><span class="line">    int recvSize;//当前接收文件的大小</span><br><span class="line">    QByteArray filebuf;//当前接收的文件数据</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>TcpServer.cpp</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;TcpServer.h&quot;</span><br><span class="line">#include&quot;qfile.h&quot;</span><br><span class="line">TcpServer::TcpServer(QWidget *parent)</span><br><span class="line">    : QWidget(parent)</span><br><span class="line">&#123;</span><br><span class="line">    ishead = true;</span><br><span class="line">    ui.setupUi(this);</span><br><span class="line">    server = new QTcpServer(this);</span><br><span class="line">    //监听1122端口的ip</span><br><span class="line">    server-&gt;listen(QHostAddress::Any, 1122);</span><br><span class="line">    //如果有用户连接触发槽函数</span><br><span class="line">    connect(server, &amp;QTcpServer::newConnection, this, &amp;TcpServer::hasConnect);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TcpServer::hasConnect()</span><br><span class="line">&#123;</span><br><span class="line">    while (server-&gt;hasPendingConnections()&gt;0)//判断当前连接了多少人</span><br><span class="line">    &#123;</span><br><span class="line">        //用socket和我们的客户端连接，一个客户端对应一个套接字socket</span><br><span class="line">        socket = server-&gt;nextPendingConnection();</span><br><span class="line">        //服务器界面上输出客户端信息</span><br><span class="line">        ui.textEdit-&gt;append(QString(&quot;%1：新用户连接&quot;).arg(socket-&gt;peerPort()));</span><br><span class="line">        //如果客户端发送信息过来了，触发匿名函数</span><br><span class="line">        connect(socket, &amp;QTcpSocket::readyRead, [=]() &#123;</span><br><span class="line">            QByteArray buf = socket-&gt;readAll();</span><br><span class="line">            //用一个标志位ishead判断是头还是数据位</span><br><span class="line">            if (ishead)</span><br><span class="line">            &#123;</span><br><span class="line">                //如果是头，解析头（文件名，文件大小）</span><br><span class="line">                QString str = QString(buf);</span><br><span class="line">                ui.textEdit-&gt;append(str);</span><br><span class="line">                QStringList strlist = str.split(&quot;&amp;&quot;);</span><br><span class="line">                fileName = strlist.at(0);//解析帧头文件名</span><br><span class="line">                fileSize = strlist.at(1).toInt();//解析帧头文件大小</span><br><span class="line">                ishead = false;//下次接收到的文件就是我们的数据</span><br><span class="line">                recvSize = 0;</span><br><span class="line">                filebuf.clear();</span><br><span class="line">                socket-&gt;write(&quot;ok&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                //根据文件名和文件大小接收和保存文件</span><br><span class="line">                filebuf.append(buf);</span><br><span class="line">                recvSize += buf.size();//每接收一次文件，当前文件大小+1</span><br><span class="line">                //当接收文件大小等于总文件大小，即文件数据接收完毕</span><br><span class="line">                if (recvSize&gt;=fileSize)</span><br><span class="line">                &#123;</span><br><span class="line">                    //保存文件</span><br><span class="line">                    QFile file(ui.lineEdit-&gt;text() + fileName);</span><br><span class="line">                    file.open(QIODevice::WriteOnly);</span><br><span class="line">                    file.write(filebuf);</span><br><span class="line">                    file.close();</span><br><span class="line">                    ishead = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建客户端项目（QTcpClient）</p><ul><li><strong>QTcpClient.h</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;QtWidgets/QWidget&gt;</span><br><span class="line">#include&quot;ui_QTcpClient.h&quot;</span><br><span class="line">#include&quot;qtcpsocket.h&quot;</span><br><span class="line">#pragma execution_character_set(&quot;utf-8&quot;)</span><br><span class="line">class QTcpClient : public QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    QTcpClient(QWidget *parent = Q_NULLPTR);</span><br><span class="line">public slots:</span><br><span class="line">    void on_btn_connect_clicked();</span><br><span class="line">    void on_btn_choose_clicked();</span><br><span class="line">    void on_btn_open_clicked();</span><br><span class="line">    </span><br><span class="line">private:</span><br><span class="line">    Ui::QTcpClientClass ui;</span><br><span class="line">    QTcpSocket* socket;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>QTcpClient.cpp</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;QTcpClient.h&quot;</span><br><span class="line">#include&quot;qfiledialog.h&quot;</span><br><span class="line">#include&quot;qfileinfo.h&quot;</span><br><span class="line">QTcpClient::QTcpClient(QWidget *parent)</span><br><span class="line">    : QWidget(parent)</span><br><span class="line">&#123;</span><br><span class="line">    ui.setupUi(this);</span><br><span class="line">    socket = new QTcpSocket(this);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">void QTcpClient::on_btn_connect_clicked()</span><br><span class="line">&#123;</span><br><span class="line">    QString ip = ui.lineEdit_ip-&gt;text();//获取ip</span><br><span class="line">    int port = ui.lineEdit_port-&gt;text().toInt();//获取端口数据</span><br><span class="line">    socket-&gt;connectToHost(ip, port);//连接服务器</span><br><span class="line">    //等待连接成功</span><br><span class="line">    if (socket-&gt;waitForConnected())</span><br><span class="line">    &#123;</span><br><span class="line">        ui.textEdit-&gt;append(&quot;&lt;font color=&#x27;green&#x27;&gt;连接服务器成功！&lt;/font&gt;&quot;);    </span><br><span class="line">        ui.btn_open-&gt;setEnabled(true);</span><br><span class="line">        </span><br><span class="line">        //如果服务器发送信息到客户端，触发匿名函数</span><br><span class="line">        connect(socket, &amp;QTcpSocket::readyRead, [=]() &#123;</span><br><span class="line">            //读取服务器发送的信息（即缓冲区信息）</span><br><span class="line">            QByteArray buf = socket-&gt;readAll();</span><br><span class="line">            if (buf==&quot;ok&quot;)</span><br><span class="line">            &#123;</span><br><span class="line">                QFile file = (ui.label_path-&gt;text());</span><br><span class="line">                if (!file.open(QIODevice::ReadWrite))</span><br><span class="line">                &#123;</span><br><span class="line">                    //读取文件失败</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                qint64 currentlen = 0;//当前已经发送的大小</span><br><span class="line">                qint64 allLength = file.size();//总文件大小</span><br><span class="line">                do</span><br><span class="line">                &#123;</span><br><span class="line">                    char data[1024];</span><br><span class="line">                    qint64 msize = file.read(data, 1024);//读文件放入打他数组中，返回读取到的大小</span><br><span class="line">                    socket-&gt;write(data, msize);//把读取到的data数据发送给服务器</span><br><span class="line">                    currentlen += msize;//实时获取当前发送的文件大小</span><br><span class="line">                    ui.progressBar-&gt;setValue(currentlen *100 / allLength);//更新界面进度条</span><br><span class="line">                &#125; while (currentlen &lt; allLength);//当发送文件等于文件大小时，发送完毕，循环结束</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        ui.textEdit-&gt;append(&quot;&lt;font color=&#x27;red&#x27;&gt;连接服务器失败！&lt;/font&gt;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//选择文件事件</span><br><span class="line">void QTcpClient::on_btn_choose_clicked()</span><br><span class="line">&#123;</span><br><span class="line">    QString path = QFileDialog::getOpenFileName(this, &quot;打开文件&quot;, &quot;&quot;, &quot;(*.*)&quot;);</span><br><span class="line">    ui.label_path-&gt;setText(path);</span><br><span class="line">&#125;</span><br><span class="line">//发送文件事件</span><br><span class="line">void QTcpClient::on_btn_open_clicked()</span><br><span class="line">&#123;</span><br><span class="line">    QFileInfo info(ui.label_path-&gt;text());</span><br><span class="line">    //用QFileInfo：：fileName，size获取文件名和大小 格式：文件名&amp;大小</span><br><span class="line">    //服务器用该格式解析文件名和大小</span><br><span class="line">    QString head = QString(&quot;%1&amp;%2&quot;).arg(info.fileName()).arg(info.size());</span><br><span class="line">    //将该格式发送给服务器 toUtf8：QString转QByteArray或char类型</span><br><span class="line">    socket-&gt;write(head.toUtf8()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果展示：</strong></p><p><img src="https://bu.dusays.com/2025/03/13/67d2dc9a83bfe.gif"></p><br><br><br><p><span style="color: red; font-size: 20px;">转载自：<a href="https://www.cnblogs.com/xyf327">唯有自己强大</a>          如有侵权，在下方评论  立刻删除。</span></p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt学习 </tag>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt08项目打包和发布</title>
      <link href="/2025/03/13/Qt08%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E5%92%8C%E5%8F%91%E5%B8%83/"/>
      <url>/2025/03/13/Qt08%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E5%92%8C%E5%8F%91%E5%B8%83/</url>
      
        <content type="html"><![CDATA[<p>打包整体思路：</p><ul><li>将编译后的exe可执行文件及其各种依赖dll、lib、图标、配置文件等先打包放到一个目录中</li><li>对其进行打包发布（两种方式）：</li></ul><ol><li>利用VS的插件Microsoft Visual Studio Installer Projects安装程序打包插件进行打包</li><li>利用Enigma Virtual Box(单文件封装工具) 进行打包</li></ol><h3 id="一，将编译后的exe可执行文件及其各种依赖dll、lib、图标、配置文件等先打包放到一个目录中"><a href="#一，将编译后的exe可执行文件及其各种依赖dll、lib、图标、配置文件等先打包放到一个目录中" class="headerlink" title="一，将编译后的exe可执行文件及其各种依赖dll、lib、图标、配置文件等先打包放到一个目录中"></a><font color="FF0000">一，将编译后的exe可执行文件及其各种依赖dll、lib、图标、配置文件等先打包放到一个目录中</font></h3><p><strong>（1）dumpbin指令查看可执行文件的dll依赖包</strong></p><p>在VS开发人员命令提示符（vs界面-&gt;工具-&gt;命令行-&gt;开发者命令提示）中执行<strong>dumpbin &#x2F;dependents 程序路径 ：dumpbin&#x2F;dependents C:\Users\WFD\Desktop\GCtest\Debug\GCtest</strong></p><p><img src="https://bu.dusays.com/2025/03/13/67d2d919ca716.png"></p><p><strong>（2）windeployqt.exe指令自动将qt依赖包复制过来</strong></p><p> 1️⃣先打开 Qt 的命令行（用的32位）</p><p><img src="https://bu.dusays.com/2025/03/13/67d2d931dc01c.png"></p><p>2️⃣使用“cd&#x2F;d 路径” 命令进入到包含.exe 文件的文件夹。</p><p>3️⃣ Qt 命令行执行 windeployqt 工具，输入： “windeployqt ***.exe” ，就可以将qt依赖包复制到该文件夹中</p><p><img src="https://bu.dusays.com/2025/03/13/67d2d94c54e1f.png"></p><p><img src="https://bu.dusays.com/2025/03/13/67d2d95753bae.png"></p><p><strong>（3）非Qt依赖库的添加</strong></p><p><strong>要注意release版本与debug版本所需要的依赖是不一样的，需要分别打包！！！</strong></p><ul><li><strong>方法一</strong></li></ul><p>在通过vs的dumpbin指令查询到可执行文件的dll依赖包后，使用eyerything软件根据位置去寻找dll文件。</p><p>下载地址：<a href="http://www.voidtools.com/">http://www.voidtools.com/</a></p><p><img src="https://bu.dusays.com/2025/03/13/67d2d99b229d6.png"></p><ul><li><strong>方法二</strong></li></ul><p>如果动态库有很多那么复制起来很麻烦（比如上面Qtcore.dll查找到很多路径，但是不知道用哪个），可以使用window的批处理：</p><p>通过观察程序运行时Vs输出窗口中加载的dll库：</p><p><img src="https://bu.dusays.com/2025/03/13/67d2d9b78f0fc.png"></p><ul><li><strong>方法三</strong></li></ul><p>使用Dependency Wallker 打开***.exe 查找不存在的.dll，其中黄色的问号标识是不存在的。Dependency Wallker可以递归显示可执行文件（exe）和动态库（dll）调用的动态库。</p><p>打开**.exe文件之后各个节点可能是展开的很乱，可以右击任意节点选择“折叠所有(L)”,然后再单击根节点的加号展开就是如图所示的样式，这样很清晰。</p><p><img src="https://bu.dusays.com/2025/03/13/67d2d9d63494d.png"></p><p>在全部添加完依赖库后，点击exe运行文件就可以本机运行了。或者将该文件夹全部发送给用户也可运行。</p><p>那么如何只使用一个exe文件就完成程序的运行呢？</p><p><strong>🙄这就要用到下面要说的打包和发布了。</strong></p><h3 id="二，利用VS的插件Microsoft-Visual-Studio-Installer-Projects安装程序打包插件进行打包"><a href="#二，利用VS的插件Microsoft-Visual-Studio-Installer-Projects安装程序打包插件进行打包" class="headerlink" title="二，利用VS的插件Microsoft Visual Studio Installer Projects安装程序打包插件进行打包"></a><font color="FF0000">二，利用VS的插件Microsoft Visual Studio Installer Projects安装程序打包插件进行打包</font></h3><p>安装过程不再详述参见：<a href="https://www.cnblogs.com/wuyubing/p/12378014.html">Installer Projects插件的安装</a></p><p> <strong>（1）新建安装项目</strong></p><p>解决方案-&gt;新建项目-&gt;setup project</p><p><img src="https://bu.dusays.com/2025/03/13/67d2d9ff7680d.png"></p><p>进入文件系统：(setup1-&gt;view-&gt;文件系统）</p><p><img src="https://bu.dusays.com/2025/03/13/67d2da14e0621.png"></p><p> <strong>（2）添加文件</strong></p><p>Application Folder-&gt;add-&gt;文件（在此添加相关的依赖资源）</p><p><img src="https://bu.dusays.com/2025/03/13/67d2da26840fa.png"></p><p> 将exe所在目录下的所有文件添加到该处</p><p> <strong>（3）添加项目输出</strong></p><p>Application Folder-&gt;add-&gt;项目输出（主程序入口）</p><p><img src="https://bu.dusays.com/2025/03/13/67d2da3facb0a.png"></p><p>对主输出创建快捷方式，并将其拖动到User‘s Desktop内</p><p><img src="https://bu.dusays.com/2025/03/13/67d2da4f4073b.png"></p><p><strong>（4）打包发布</strong></p><p> 对setup1项目进行重新生成，即生成安装程序</p><p><img src="https://bu.dusays.com/2025/03/13/67d2da5f3f9fd.png"></p><h3 id="三，利用Enigma-Virtual-Box-单文件封装工具-进行打包"><a href="#三，利用Enigma-Virtual-Box-单文件封装工具-进行打包" class="headerlink" title="三，利用Enigma Virtual Box(单文件封装工具) 进行打包"></a><font color="FF0000">三，利用Enigma Virtual Box(单文件封装工具) 进行打包</font></h3><p>Enigma 虚拟文件打包系统可以将程序和配套文件打包成一个可执行文件，而没有任何效率的损失，配套文件也不会被释放至硬盘。（同时支持X86和X64二进制文件）。</p><p>如图：</p><p><img src="https://bu.dusays.com/2025/03/13/67d2da99e4610.png"></p><p><img src="https://bu.dusays.com/2025/03/13/67d2daa7c6d41.png"></p><p>将生成的GCtest_boxed文件复制到要运行的设备上即可（可以单独运行）</p><br><br><br><p><span style="color: red; font-size: 20px;">转载自：<a href="https://www.cnblogs.com/xyf327">唯有自己强大</a>          如有侵权，在下方评论  立刻删除。</span></p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt07鼠标事件</title>
      <link href="/2025/03/13/Qt07%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6/"/>
      <url>/2025/03/13/Qt07%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>个人认为，事件机制是Qt最难以理解且最为精妙的一部分。事件主要分为两种：</p><ol><li><strong>在与用户交互时发生</strong>。比如按下鼠标（mousePressEvent），敲击键盘（keyPressEvent）等。</li><li><strong>系统自动发生</strong>，比如计时器事件（timerEvent）等。</li></ol><p>在发生事件时（比如说上面说的按下鼠标），就会产生一个QEvent对象（这里是QMouseEvent，为QEvent的子类），这个QEvent对象会传给当前组件的event函数。如果当前组件没有安装<strong>事件过滤器</strong>（这个后面会提到），则会被event函数发放到相应的xxxEvent函数中（这里是mousePressEvent函数）。</p><p>需要区分的是：<strong>事件与信号并不相同。</strong></p><p>比如：鼠标单击按钮，鼠标事件（QMouseEvent），而按钮本身发射clicked（）信号。一般而言我们只需要关注单击信号，不用考虑鼠标事件。但是当我们要对该按钮做额外操作，不想通过信号处理，此时事件就是一个很好的选择。关闭事件（QCloseEvent）是一个常用的事件。</p><hr><h3 id="一，事件"><a href="#一，事件" class="headerlink" title="一，事件"></a><font color="FF0000">一，事件</font></h3><p>Qt 中所有事件类都继承于 QEvent。在事件对象创建完毕后，Qt 将这个事件对象传递给 QObject 的 event()函数。event()函数并不直接处理事件，而是按照事件对象的类型分派给特定的事件处理函数（eventhandler）。</p><p><img src="https://bu.dusays.com/2025/03/13/67d29bf3e8d89.png"></p><p>信号是通过connect（）来绑定槽函数处理响应，那么事件是怎么处理的呢？</p><p><strong>处理事件有5种常用的方法：</strong></p><ol><li>重新实现部件的paintEvent（）、mousePressEvent()等事件处理函数。这是最常用的一种方法，不过只能用来处理特定部件的特定事件（即需要新建类去实现）</li><li>重新实现notify（）函数。这个函数的功能强大，提供了完全的控制，可以再事件过滤器得到事件之间就获得他们。但是，它一次只能处理一个事件。</li><li>向QApplication对象上安装事件过滤器。因为一个程序只有一个QApplication对象，实现的功能和notify（）函数相同，优点是可以同时处理多个事件。</li><li>重新实现event（）函数。QObject类的event（）函数可以在事件达到默认事件处理函数之前获得该事件。</li><li>在对象上安装事件过滤器。使用事件过滤器可以再一个界面类中同时处理不同子部件的事件（在本类中实现）</li></ol><p>实际编程中最常用的是方法（1），其次是方法（5）。方法2要继承QApplication类，方法3需要全局的事件过滤器，减缓事件的传递。</p><p><strong>鼠标事件：</strong></p><p>常用的鼠标事件：（本篇处理事件用的是方法一：重写鼠标事件）</p><ul><li>void mousePressEvent(QMouseEvent *event);      &#x2F;&#x2F;单击</li><li>void mouseReleaseEvent(QMouseEvent *event);    &#x2F;&#x2F;释放</li><li>void mouseDoubleClickEvent(QMouseEvent *event); &#x2F;&#x2F;双击</li><li>void mouseMoveEvent(QMouseEvent *event);      &#x2F;&#x2F;移动</li><li>void wheelEvent(QWheelEvent *event);           &#x2F;&#x2F;滑轮</li></ul><p><strong>鼠标事件使用的时候，加头文件： #include <QMouseEvent></strong></p><p><strong>重写事件框架：</strong></p><p><strong>1️⃣鼠标按下事件</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::mousePressEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果是鼠标左键按下   </span></span><br><span class="line">    <span class="keyword">if</span>(event-&gt;<span class="built_in">button</span>() == Qt::LeftButton)&#123;</span><br><span class="line">        ···</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是鼠标右键按下</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(event-&gt;<span class="built_in">button</span>() == Qt::RightButton)&#123;</span><br><span class="line">       ···</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2️⃣鼠标移动事件</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::mouseMoveEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这里必须使用buttons()</span></span><br><span class="line">    <span class="keyword">if</span>(event-&gt;<span class="built_in">buttons</span>() &amp; Qt::LeftButton)&#123;  <span class="comment">//进行的按位与</span></span><br><span class="line">       ···</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下，触发事件需要点击一下，才能触发。可设置为自动触发:<strong>setMouseTracking(true);</strong> </p><p><strong>3️⃣鼠标释放事件</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::mouseReleaseEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4️⃣鼠标双击事件</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::mouseDoubleClickEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果是鼠标左键按下</span></span><br><span class="line">    <span class="keyword">if</span>(event-&gt;<span class="built_in">button</span>() == Qt::LeftButton)&#123;</span><br><span class="line">      </span><br><span class="line">        ···</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5️⃣滚轮事件</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::wheelEvent</span><span class="params">(QWheelEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 当滚轮远离使用者时</span></span><br><span class="line">    <span class="keyword">if</span>(event-&gt;<span class="built_in">delta</span>() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        ···</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//当滚轮向使用者方向旋转时</span></span><br><span class="line">        ···</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实例演示</strong>（在label控件中，移动鼠标获取实时位置，并显示在界面上）</p><ul><li><strong>创建mylabel类，基类设置为QLabel</strong></li></ul><p><img src="https://bu.dusays.com/2025/03/13/67d29c1584eb6.png"></p><p>这里用了类似自定义控件的方法，对Mylabel类进行封装。设置基类QLabel 是为了在ui界面中提升label控件（即将label控件和Mylabel关联，提升时候必须二者基类相同）</p><ul><li>在mylabel.h中声明鼠标事件</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;qlabel.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mylabel</span> : <span class="keyword">public</span> QLabel</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">mylabel</span>(QWidget* parent = <span class="number">0</span>);</span><br><span class="line">    ~<span class="built_in">mylabel</span>();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//鼠标移动事件</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mouseMoveEvent</span><span class="params">(QMouseEvent* event)</span></span>;</span><br><span class="line">    <span class="comment">//鼠标按下事件</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mousePressEvent</span><span class="params">(QMouseEvent* event)</span></span>;</span><br><span class="line">    <span class="comment">//鼠标释放事件</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mouseReleaseEvent</span><span class="params">(QMouseEvent* event)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>在mylabel.cpp中重写事件</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mylabel.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;QMouseEvent&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mylabel::<span class="built_in">mylabel</span>(QWidget* parent) :<span class="built_in">QLabel</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">mylabel::~<span class="built_in">mylabel</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//鼠标移动显示坐标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mylabel::mouseMoveEvent</span><span class="params">(QMouseEvent* event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event-&gt;<span class="built_in">buttons</span>() &amp; Qt::LeftButton)  <span class="comment">//进行的按位与（只有左键点击移动才满足）</span></span><br><span class="line">    &#123; </span><br><span class="line">        QString str = <span class="built_in">QString</span>(<span class="string">&quot;Move:(X:%1,Y:%2)&quot;</span>).<span class="built_in">arg</span>(event-&gt;<span class="built_in">x</span>()).<span class="built_in">arg</span>(event-&gt;<span class="built_in">y</span>());</span><br><span class="line">         <span class="keyword">this</span>-&gt;<span class="built_in">setText</span>(str);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//鼠标按下显示“ok，mouse is press”</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mylabel::mousePressEvent</span><span class="params">(QMouseEvent* event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">setText</span>(<span class="string">&quot;Ok, mouse is press&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//鼠标释放清除显示</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mylabel::mouseReleaseEvent</span><span class="params">(QMouseEvent* event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">setText</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在主函数（QTest.cpp）中声明mylabel的类对象（即声明一个mylabel类的label控件）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qtest.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">QTest::<span class="built_in">QTest</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    ui.<span class="built_in">setupUi</span>(<span class="keyword">this</span>);    <span class="comment">//声明mylabel类的控件</span></span><br><span class="line">    mylabel* label1 = <span class="keyword">new</span> <span class="built_in">mylabel</span>(<span class="keyword">this</span>);</span><br><span class="line">    label1-&gt;<span class="built_in">setGeometry</span>(<span class="built_in">QRect</span>(<span class="number">130</span>, <span class="number">100</span>, <span class="number">271</span>, <span class="number">161</span>));    <span class="comment">//设置边框</span></span><br><span class="line">    label1-&gt;<span class="built_in">setFrameShape</span>(QFrame::Panel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2025/03/13/67d29c2b5a2ed.png"></p><p> 另外，当调用<strong>setMouseTracking(true)</strong>;时（即设置鼠标状态为自动触发），需要将鼠标移动事件的if语句去掉（因为不需要点击触发了）</p><p><strong>修改maylabel.cpp事件：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mylabel.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;QMouseEvent&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mylabel::<span class="built_in">mylabel</span>(QWidget* parent) :<span class="built_in">QLabel</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//设置鼠标状态（自动触发）</span></span><br><span class="line">    <span class="built_in">setMouseTracking</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">mylabel::~<span class="built_in">mylabel</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//鼠标移动显示坐标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mylabel::mouseMoveEvent</span><span class="params">(QMouseEvent* event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   QString str = <span class="built_in">QString</span>(<span class="string">&quot;Move:(X:%1,Y:%2)&quot;</span>).<span class="built_in">arg</span>(event-&gt;<span class="built_in">x</span>()).<span class="built_in">arg</span>(event-&gt;<span class="built_in">y</span>());</span><br><span class="line">   <span class="keyword">this</span>-&gt;<span class="built_in">setText</span>(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//鼠标按下显示“ok，mouse is press”</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mylabel::mousePressEvent</span><span class="params">(QMouseEvent* event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">setText</span>(<span class="string">&quot;Ok, mouse is press&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//鼠标释放清除显示</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mylabel::mouseReleaseEvent</span><span class="params">(QMouseEvent* event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">setText</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果展示：</strong></p><p><img src="https://bu.dusays.com/2025/03/13/67d29c4cbb6f7.gif"></p><p><strong>😒这里用的是代码创建label控件，那么能不能用ui界面编辑然后在对label控件提升呢？</strong></p><p>答案是可以的，但是需要注意的是：<strong>此处不能选择全局包含</strong></p><p><img src="https://bu.dusays.com/2025/03/13/67d29c64cf2e2.png"></p><p> <strong>否则会出现：</strong></p><p><img src="https://bu.dusays.com/2025/03/13/67d29c7542d19.png"></p><p>我想其中的原因主要是因为：</p><p>本实例是新建了一个mylabel类，而不是像<a href="https://www.cnblogs.com/xyf327/p/15097726.html">QT常用控件（三）——自定义控件封装 - 唯有自己强大 - 博客园 (cnblogs.com)</a>这篇博文中直接新添加了一个设计师界面类（即包含ui .h .cpp)。当选择全局包含时，就包含了主类。</p><p>其实也有解决的办法：需要在提升界面的头文件处，将工程目录下自定义控件的地址放于此处</p><p><img src="https://bu.dusays.com/2025/03/13/67d29c8d1fe53.png"></p><h3 id="二，事件的分发：event函数"><a href="#二，事件的分发：event函数" class="headerlink" title=" 二，事件的分发：event函数"></a><font color="FF0000"> 二，事件的分发：event函数</font></h3><p>上面提到的xxxEvent函数，称为事件处理器（event handler）。而event函数的作用就在于事件的分发。如果想在事件的分发之前就进行一些操作，比如监听（<strong>阻塞</strong>）鼠标按下事件。</p><p> 如果希望在事件分发之前做一些操作，就可以重写这个 event()函数了。比如我们希望阻塞鼠标按下事件，那么我们就在新建的Mylabel类中重写event()函数（<strong>该类的父类是QLabel</strong>）</p><ul><li><strong>在Mylabel.h中声明event事件</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;qlabel.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mylabel</span> : <span class="keyword">public</span> QLabel</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Mylabel</span><span class="params">(QWidget* parent = <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//鼠标按下事件</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mousePressEvent</span><span class="params">(QMouseEvent* event)</span></span>; </span><br><span class="line">    <span class="comment">//鼠标释放事件</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mouseReleaseEvent</span><span class="params">(QMouseEvent* event)</span></span>;</span><br><span class="line">    <span class="comment">//声明event事件</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">event</span><span class="params">(QEvent* e)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>在Mylabel.cpp中重写event事件。</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Mylabel.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;QMouseEvent&quot;</span></span></span><br><span class="line"></span><br><span class="line">Mylabel::<span class="built_in">Mylabel</span>(QWidget* parent) :<span class="built_in">QLabel</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重写鼠标按下事件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Mylabel::mousePressEvent</span><span class="params">(QMouseEvent* event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setText</span>(<span class="built_in">QString</span>(<span class="string">&quot;mouse is press x:%1,y:%2&quot;</span>).<span class="built_in">arg</span>(event-&gt;<span class="built_in">x</span>()).<span class="built_in">arg</span>(event-&gt;<span class="built_in">y</span>()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重写鼠标释放事件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Mylabel::mouseReleaseEvent</span><span class="params">(QMouseEvent* event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setText</span>(<span class="string">&quot;mouse is release &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重写event事件</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Mylabel::event</span><span class="params">(QEvent* e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果鼠标按下，再事件分发中做拦截</span></span><br><span class="line">    <span class="keyword">if</span> (e-&gt;<span class="built_in">type</span>()==QEvent::MouseButtonPress)</span><br><span class="line">    &#123;        <span class="comment">//静态转换（将QEvent的对象转换为QMouseEvent对象）</span></span><br><span class="line">        QMouseEvent* event = <span class="built_in">static_cast</span>&lt;QMouseEvent*&gt;(e);</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">setText</span>(<span class="built_in">QString</span>(<span class="string">&quot;event mouse is press x:%1,y:%2&quot;</span>).<span class="built_in">arg</span>(event-&gt;<span class="built_in">x</span>()).<span class="built_in">arg</span>(event-&gt;<span class="built_in">y</span>()));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//返回ture，说明用户自己处理事件，不往下分发（即拦截上面的按下事件）</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> QLabel::<span class="built_in">event</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2025/03/13/67d29cb547ab2.png"></p><p>点击鼠标可以看到，触发的是event的事件（即阻塞了mousePressEvent的事件）。<strong>特别需要注意的是：在将不需要阻塞分发的时候，需要分发给父类的event函数处理。即（return QLable::event(e)；)</strong></p><p>由此可以见，event()是一个集中处理不同类型的事件的地方。如果你不想重写一大堆事件处理器，就可以重写这个 event()函数，通过 QEvent::type()判断不同的事件。鉴于重写 event()函数需要十分小心注意父类的同名函数的调用，一不留神就可能出现问题，所以一般还是建议只重写事件处理器（当然，也必须记得是不是应该调用父类的同名处理器）。</p><h3 id="三，事件过滤器（Even-Filter）"><a href="#三，事件过滤器（Even-Filter）" class="headerlink" title="三，事件过滤器（Even Filter）"></a><strong>三，事件过滤器（Even Filter）</strong></h3><p> 某些应用场景下，需要拦截某个组件发生的事件，让这个事件不再向其他组件进行传播，这时候可以为这个组件或其父组件安装一个事件过滤器，<strong>该过滤器在event分发之前进行拦截。</strong></p><p><strong>事件的过滤有两个步骤：</strong></p><p>1️⃣对QObject组件安装过滤器（<strong>调用installEvenFilter函数</strong>）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QObject::installEventFilter</span> <span class="params">( QObject * filterObj )</span></span>;</span><br></pre></td></tr></table></figure><p>参数filterobj 是指谁为组件安装过滤器（一般是父类）</p><ul><li>这个函数接受一个 QObject *类型的参数。记得刚刚我们说的，eventFilter()函数是 QObject 的一个成员函数，因此，任意 QObject 都可以作为事件过滤器（问题在于，如果你没有重写 eventFilter()函数，这个事件过滤器是没有任何作用的，因为默认什么都不会过滤）。已经存在的过滤器则可以通过**QObject::removeEventFilter()**函数移除。 </li><li>我们可以向一个对象上面安装多个事件处理器 ，只要调用多次installEventFilter()函数。如果一个对象存在多个事件过滤器，那么，最后一个安装的会第一个执行，也就是后进先执行的顺序。</li></ul><p>2️⃣事件过滤器的重写（<strong>evenFilter函数</strong>）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">QObject::eventFilter</span> <span class="params">( QObject * watched, QEvent * event )</span></span>;</span><br></pre></td></tr></table></figure><p>可以看到，函数有两个参数，一个为具体发生事件的组件，一个为发生的事件（产生的QEvent对象）。当事件是我们感兴趣的类型，可以就地进行处理，并令其不再转发给其他组件。函数的返回值也是bool类型，作用跟even函数类似，返回true为不再转发，false则让其继续被处理。</p><p><strong>实例</strong>：通过事件过滤器阻塞上面代码中的鼠标按下事件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qtest.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;qmouseevent&quot;</span></span></span><br><span class="line"></span><br><span class="line">QTest::<span class="built_in">QTest</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    ui.<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//第一步：给label添加过滤器</span></span><br><span class="line">    ui.label-&gt;<span class="built_in">installEventFilter</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二步：重写过滤事件</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QTest::eventFilter</span><span class="params">(QObject* obj, QEvent* e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == ui.label)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果鼠标按下，再事件分发中做拦截</span></span><br><span class="line">        <span class="keyword">if</span> (e-&gt;<span class="built_in">type</span>() == QEvent::MouseButtonPress)</span><br><span class="line">        &#123;</span><br><span class="line">            QMouseEvent* event = <span class="built_in">static_cast</span>&lt;QMouseEvent*&gt;(e);</span><br><span class="line">            ui.label-&gt;<span class="built_in">setText</span>(<span class="built_in">QString</span>(<span class="string">&quot;eventfilter mouse is press x:%1,y:%2&quot;</span>).<span class="built_in">arg</span>(event-&gt;<span class="built_in">x</span>()).<span class="built_in">arg</span>(event-&gt;<span class="built_in">y</span>()));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//返回ture，说明用户自己处理事件，不往下分发（即拦截上面的按下事件）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> QWidget::<span class="built_in">eventFilter</span>(obj, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重写鼠标按下事件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTest::mousePressEvent</span><span class="params">(QMouseEvent* event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ui.label-&gt;<span class="built_in">setText</span>(<span class="built_in">QString</span>(<span class="string">&quot;mouse is press x:%1,y:%2&quot;</span>).<span class="built_in">arg</span>(event-&gt;<span class="built_in">x</span>()).<span class="built_in">arg</span>(event-&gt;<span class="built_in">y</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重写事件分发</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QTest::event</span><span class="params">(QEvent* e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果鼠标按下，再事件分发中做拦截</span></span><br><span class="line">    <span class="keyword">if</span> (e-&gt;<span class="built_in">type</span>() == QEvent::MouseButtonPress)</span><br><span class="line">    &#123;</span><br><span class="line">        QMouseEvent* event = <span class="built_in">static_cast</span>&lt;QMouseEvent*&gt;(e);</span><br><span class="line">        ui.label-&gt;<span class="built_in">setText</span>(<span class="built_in">QString</span>(<span class="string">&quot;event mouse is press x:%1,y:%2&quot;</span>).<span class="built_in">arg</span>(event-&gt;<span class="built_in">x</span>()).<span class="built_in">arg</span>(event-&gt;<span class="built_in">y</span>()));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//返回ture，说明用户自己处理事件，不往下分发（即拦截上面的按下事件）</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> QWidget::<span class="built_in">event</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><p><img src="https://bu.dusays.com/2025/03/13/67d29ccad815a.png"></p><p>可以看到在过滤器事件中就监听了鼠标按压（即阻塞了后面的事件分发和鼠标按压）</p><h3 id="按钮长按事件"><a href="#按钮长按事件" class="headerlink" title="按钮长按事件"></a><font color="FF0000">按钮长按事件</font></h3><p>最近在做qt项目，需要对button按钮添加一个长按事件（比如点击按钮，开始运动。松开按钮，运动停止）。查了些许资料，（差点误把QPushButton的press信号和长按事件混淆）在此记录一下经验。</p><h4 id="setAutoRepeat"><a href="#setAutoRepeat" class="headerlink" title="setAutoRepeat"></a><font color="FF0000">setAutoRepeat</font></h4><p>以前一直以为QPushButton不支持长按，才发现还有这个功能。用起来很简单：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QPushButton *pBtnSub = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="keyword">this</span>);</span><br><span class="line">pBtnSub = <span class="built_in">setAutoRepeat</span>(<span class="literal">true</span>);  <span class="comment">//启动长按</span></span><br><span class="line">pBtnSub = <span class="built_in">setAutoRepeatDelay</span>(<span class="number">400</span>);  <span class="comment">// 触发长按时间</span></span><br><span class="line">pBtnSub = <span class="built_in">setAutoRepeatInterval</span>(<span class="number">50</span>);  <span class="comment">// 长按时click信号间隔</span></span><br><span class="line"><span class="built_in">connect</span>(pBtnSub,&amp;QPushButton::clicked,[&amp;]&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;send&quot;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>MouseEvent中没有repeat这个东西的，所以一个按钮被鼠标点击还能连续触发，那基本就是一个定时器做出来的。</p><p><strong>所以应该说是鼠标按下Delay时间后会启动一个多次触发的TimerEvent（定时器），由timeOut再次触发click槽。</strong></p><h4 id="QPushButton-点击信号分析"><a href="#QPushButton-点击信号分析" class="headerlink" title="QPushButton 点击信号分析"></a><font color="FF0000">QPushButton 点击信号分析</font></h4><p>再来分析一下QPushButton的点击信号。QPushButton有三个很重要的信号跟点击有关：</p><ul><li>pressed</li><li>clicked</li><li>toggled</li></ul><p>表面上看，pressed和clicked都会在点击按钮时触发，它们有什么区别呢？toggled好像有时候触发，有时候不触发，到底怎么回事呢？下面就一起聊一下这三个信号</p><p><strong>😊验证过程就不放了，直接给结论吧！</strong></p><p>首先，这三个信号都是从QAbstractButton继承来的，也就是说，下面情况对QAbstractButton的所有子类都适用</p><p><strong>结论：</strong></p><ol><li>pressed最先执行，相当于按下操作</li><li>按下之后，按钮状态发生变化，触发toggled</li><li>clicked最后执行，相当于弹起操作</li></ol><br><br><br><p><span style="color: red; font-size: 20px;">转载自：<a href="https://www.cnblogs.com/xyf327">唯有自己强大</a>          如有侵权，在下方评论  立刻删除。</span></p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt06定时器</title>
      <link href="/2025/03/13/Qt06%E5%AE%9A%E6%97%B6%E5%99%A8/"/>
      <url>/2025/03/13/Qt06%E5%AE%9A%E6%97%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>Qt中有两种方法来使用定时器，一种是定时器事件，另一种是使用信号和槽。</p><p>常使用信号和槽（代码看起来比较整洁）但是当使用多个定时器的时候最好用定时器事件来处理。 </p><h3 id="定时器方式一：定时器事件"><a href="#定时器方式一：定时器事件" class="headerlink" title="定时器方式一：定时器事件"></a><font color="FF0000">定时器方式一：定时器事件</font></h3><p><strong>需要</strong>： #include <QTimerEvent></p><p><strong>方式</strong>：</p><ul><li>利用对void timerEvent(QTimerEvent* e)事件的重写。</li><li>启动定时器 int QObject::startTimer ( int interval ) ;</li></ul><p>开启一个定时器，返回值为int类型。他的参数interval是毫秒级别。当开启成功后会返回这个定时器的ID, 并且每隔interval 时间后会进入timerEvent 函数。直到定时器被杀死（killTimer）</p><ul><li>timerEvent的返回值是定时器的唯一标识。可以和e-&gt;timerId比较</li><li>void killTimer(int id); &#x2F;&#x2F;停止 ID 为 id 的计时器，ID 由 startTimer()函数返回</li></ul><p><strong>实例</strong>：在两个label中自动计数，一个间隔为1秒，一个为2秒。</p><ul><li><strong>在头文件中先声明void timerEvent(QTimerEvent* e)事件</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtWidgets/QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_Qtcontrol.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Qtcontrol</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Qtcontrol</span>(QWidget *parent = Q_NULLPTR);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//重写定时器事件</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">timerEvent</span><span class="params">(QTimerEvent* e)</span></span>;</span><br><span class="line">    <span class="type">int</span> ID1;</span><br><span class="line">    <span class="type">int</span> ID2;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::QtcontrolClass ui;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>在源文件中实现</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Qtcontrol.h&quot;</span></span></span><br><span class="line">Qtcontrol::<span class="built_in">Qtcontrol</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    ui.<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//启动定时器</span></span><br><span class="line"> ID1=   <span class="built_in">startTimer</span>(<span class="number">1000</span>);<span class="comment">//启动定时器事件,创建一个定时器并返回定时器ID</span></span><br><span class="line"><span class="comment">//参数：单位毫秒---每隔n毫秒时间，就执行一次定时器事件</span></span><br><span class="line"><span class="comment">//返回值：定时器ID号</span></span><br><span class="line"> ID2 = <span class="built_in">startTimer</span>(<span class="number">2000</span>);<span class="comment">//两秒启动一次</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Qtcontrol::timerEvent</span><span class="params">(QTimerEvent* e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e-&gt;<span class="built_in">timerId</span>()==ID1)</span><br><span class="line">    &#123;</span><br><span class="line">   <span class="type">static</span> <span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">    ui.label-&gt;<span class="built_in">setText</span>(QString::<span class="built_in">number</span>(num++));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e-&gt;<span class="built_in">timerId</span>()==ID2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">        ui.label_2 -&gt;<span class="built_in">setText</span>(QString::<span class="built_in">number</span>(num++));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于所有的事件都重写在了timerEvent中，因此当需要多个定时器时，可以用定时器的ID去对应timerEvent中的事件。</p><h3 id="定时器方式二：QTimer类（信号与槽）"><a href="#定时器方式二：QTimer类（信号与槽）" class="headerlink" title="定时器方式二：QTimer类（信号与槽）"></a><font color="FF0000">定时器方式二：QTimer类（信号与槽）</font></h3><p><strong>需要</strong> ： #include <QTimer></p><p><strong>方式：</strong></p><ol><li>利用定时器类QTimer</li><li>创建定时器对象 QTimer *timer&#x3D;new QTimer(this)</li><li>启动定时器timer-&gt;start( 500） &#x2F;&#x2F;参数：每隔n毫秒发送一个信号（timeout）</li><li>用connect连接信号和槽函数（自定义槽）</li><li>暂停 timer-&gt;stop</li></ol><p><strong>实例</strong>：启动label 每隔0.5秒计时</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Qtcontrol.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;qtimer.h&quot;</span></span></span><br><span class="line">Qtcontrol::<span class="built_in">Qtcontrol</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    ui.<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">QTimer* timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//启动定时器</span></span><br><span class="line">timer-&gt;<span class="built_in">start</span>(<span class="number">500</span>);<span class="comment">//每隔0.5秒会发一个信号</span></span><br><span class="line"><span class="built_in">connect</span>(timer, &amp;QTimer::timeout, [=]() &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">    ui.label-&gt;<span class="built_in">setText</span>(QString::<span class="built_in">number</span>(num++));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><br><p><span style="color: red; font-size: 20px;">转载自：<a href="https://www.cnblogs.com/xyf327">唯有自己强大</a>          如有侵权，在下方评论  立刻删除。</span></p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt05多线程和线程池</title>
      <link href="/2025/03/13/Qt05%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2025/03/13/Qt05%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="一，-最简单的多线程QtConcurrent-run"><a href="#一，-最简单的多线程QtConcurrent-run" class="headerlink" title=" 一， 最简单的多线程QtConcurrent::run()"></a><font color="FF0000"> 一， 最简单的多线程QtConcurrent::run()</font></h3><ul><li><strong>其函数原型如下：</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QFuture&lt;T&gt; <span class="title">QtConcurrent::run</span><span class="params">(Function function, ...)</span></span></span><br><span class="line"><span class="function">QFuture&lt;T&gt; <span class="title">QtConcurrent::run</span><span class="params">(QThreadPool *pool, Function function, ...)</span></span></span><br></pre></td></tr></table></figure><p>参数function需要外部函数：（或者lambda函数），后面也可跟外部函数的参数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">func</span><span class="params">(QString str)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>QtConcurrent :: run（）也接受指向成员函数的指针</strong>。第一个参数必须是一个const引用或一个指向该类实例的指针。const成员函数一般传递 常量引用 (const reference)，而非常量成员函数一般传递 指针 (pointer)</p><ul><li><strong>在VS环境中需要引用：</strong> <strong>#include”QtConcurrent&#x2F;qtconcurrentrun.h”</strong></li></ul><p>简单的说，QtConcurrent::run()函数会在一个单独的线程中执行，并且该线程取自全局QThreadPool，该函数的返回值通过QFuture API提供。<br>请注意：该函数可能不会立即运行; 函数只有在线程可用时才会运行。通过QtConcurrent::run()返回的QFuture不支持取消、暂停，返回的QFuture只能用于查询函数的运行&#x2F;完成状态和返回值。</p><ul><li><strong>实例：实现多线程耗时操作（调用成员函数）</strong></li></ul><p>在主程序threadtest.h中声明成员函数（并添加引用）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtWidgets/QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_threadtest.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;workThread.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;qthread.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;QtConcurrent/qtconcurrentrun.h&quot;</span><span class="comment">//QtConcurrent引用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> execution_character_set(<span class="string">&quot;utf-8&quot;</span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Threadtest</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Threadtest</span>(QWidget *parent = Q_NULLPTR);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::ThreadtestClass ui;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span>;<span class="comment">//成员函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在主程序threadtest.cpp中调用成员函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;threadtest.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;qdebug.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Threadtest::<span class="built_in">Threadtest</span>(QWidget* parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    ui.<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">connect</span>(ui.btn_start, &amp;QPushButton::clicked, [=]()</span><br><span class="line">        &#123;        <span class="comment">//将成员函数放入参数中（成员函数需要引用指针）</span></span><br><span class="line">            QtConcurrent::<span class="built_in">run</span>(<span class="keyword">this</span>, &amp;Threadtest::work);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Threadtest::work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;子线程运行：&quot;</span> &lt;&lt; QThread::<span class="built_in">currentThreadId</span>();</span><br><span class="line">    QThread::<span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;子线程结束：&quot;</span> &lt;&lt; QThread::<span class="built_in">currentThreadId</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击按钮即可触发子线程运行。</p><p><img src="https://bu.dusays.com/2025/03/13/67d2d70d1e369.png"></p><ul><li><strong>实例：实现多线程耗时操作（调用外部函数，带参数）</strong></li></ul><p>在主程序threadtest.h中声明外部函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtWidgets/QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_threadtest.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;workThread.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;qthread.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;QtConcurrent/qtconcurrentrun.h&quot;</span><span class="comment">//QtConcurrent引用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> execution_character_set(<span class="string">&quot;utf-8&quot;</span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Threadtest</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Threadtest</span>(QWidget *parent = Q_NULLPTR);  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::ThreadtestClass ui;</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">func</span><span class="params">(QString str)</span></span>;<span class="comment">//外部函数</span></span><br></pre></td></tr></table></figure><p>在主程序threadtest.cpp中调用外部函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;threadtest.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;qdebug.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Threadtest::<span class="built_in">Threadtest</span>(QWidget* parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    ui.<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">connect</span>(ui.btn_start, &amp;QPushButton::clicked, [=]()</span><br><span class="line">        &#123;</span><br><span class="line">            QtConcurrent::<span class="built_in">run</span>(func,<span class="built_in">QString</span>(<span class="string">&quot;extern&quot;</span>));</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(QString str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;子线程运行：&quot;</span> &lt;&lt; QThread::<span class="built_in">currentThreadId</span>()&lt;&lt; str;</span><br><span class="line">    QThread::<span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;子线程结束：&quot;</span> &lt;&lt; QThread::<span class="built_in">currentThreadId</span>()&lt;&lt; str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2025/03/13/67d2d72cb57a3.png"></p><h3 id="二，线程池"><a href="#二，线程池" class="headerlink" title="二，线程池"></a><font color="FF0000">二，线程池</font></h3><h4 id="2-1-线程池原理"><a href="#2-1-线程池原理" class="headerlink" title="2.1 线程池原理"></a><font color="FF0000">2.1 线程池原理</font></h4><p>我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题：如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。</p><p>那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务呢？</p><p><strong>线程池</strong>是一种多线程处理形式，<strong>处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务</strong>。线程池线程都是后台线程。每个线程都使用默认的堆栈大小，以默认的优先级运行，并处于多线程单元中。如果某个线程在托管代码中空闲（如正在等待某个事件）, 则线程池将插入另一个辅助线程来使所有处理器保持繁忙。如果所有线程池线程都始终保持繁忙，但队列中包含挂起的工作，则线程池将在一段时间后创建另一个辅助线程但线程的数目永远不会超过最大值。超过最大值的线程可以排队，但他们要等到其他线程完成后才启动。</p><p><img src="https://bu.dusays.com/2025/03/13/67d2d7749a097.png"></p><h4 id="2-2-QRunnable"><a href="#2-2-QRunnable" class="headerlink" title="2.2 QRunnable"></a><font color="FF0000">2.2 QRunnable</font></h4><p>在 Qt 中使用线程池需要先创建任务，添加到线程池中的每一个任务都需要是一个 QRunnable 类型，因此在程序中需要创建子类继承 QRunnable 这个类，然后重写 run() 方法，在这个函数中编写要在线程池中执行的任务，并将这个子类对象传递给线程池，这样任务就可以被线程池中的某个工作的线程处理掉了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在子类中必须要重写的函数, 里边是任务的处理流程</span></span><br><span class="line">[pure <span class="keyword">virtual</span>] <span class="function"><span class="type">void</span> <span class="title">QRunnable::run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数设置为 true: 这个任务对象在线程池中的线程中处理完毕, 这个任务对象就会自动销毁</span></span><br><span class="line"><span class="comment">// 参数设置为 false: 这个任务对象在线程池中的线程中处理完毕, 对象需要程序猿手动销毁</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QRunnable::setAutoDelete</span><span class="params">(<span class="type">bool</span> autoDelete)</span></span>;</span><br><span class="line"><span class="comment">// 获取当前任务对象的析构方式,返回true-&gt;自动析构, 返回false-&gt;手动析构</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QRunnable::autoDelete</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p>例如：创建一个要添加到线程池中的任务类，处理方式如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyWork</span> : <span class="keyword">public</span> QObject, <span class="keyword">public</span> QRunnable</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyWork</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 任务执行完毕,该对象自动销毁</span></span><br><span class="line">        <span class="built_in">setAutoDelete</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">MyWork</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在上面的示例中 MyWork 类是一个多重继承，如果需要在这个任务中使用 Qt 的信号槽机制进行数据的传递就必须继承 QObject 这个类，如果不使用信号槽传递数据就可以不继承了，只继承 QRunnable 即可。</strong></p><h4 id="2-3-QThreadPool"><a href="#2-3-QThreadPool" class="headerlink" title="2.3 QThreadPool"></a><font color="FF0000">2.3 QThreadPool</font></h4><p>Qt 中的 QThreadPool 类管理了一组 QThreads, 里边还维护了一个任务队列。QThreadPool 管理和回收各个 QThread 对象，以帮助减少使用线程的程序中的线程创建成本。每个Qt应用程序都有一个全局 QThreadPool 对象，可以通过调用 globalInstance() 来访问它。也可以单独创建一个 QThreadPool 对象使用。</p><p>线程池常用的 API 函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取和设置线程中的最大线程个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxThreadCount</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setMaxThreadCount</span><span class="params">(<span class="type">int</span> maxThreadCount)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给线程池添加任务, 任务是一个 QRunnable 类型的对象</span></span><br><span class="line"><span class="comment">// 如果线程池中没有空闲的线程了, 任务会放到任务队列中, 等待线程处理</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QThreadPool::start</span><span class="params">(QRunnable * runnable, <span class="type">int</span> priority = <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="comment">// 如果线程池中没有空闲的线程了, 直接返回值, 任务添加失败, 任务不会添加到任务队列中</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QThreadPool::tryStart</span><span class="params">(QRunnable * runnable)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池中被激活的线程的个数(正在工作的线程个数)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QThreadPool::activeThreadCount</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试性的将某一个任务从线程池的任务队列中删除, 如果任务已经开始执行就无法删除了</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QThreadPool::tryTake</span><span class="params">(QRunnable *runnable)</span></span>;</span><br><span class="line"><span class="comment">// 将线程池中的任务队列里边没有开始处理的所有任务删除, 如果已经开始处理了就无法通过该函数删除了</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QThreadPool::clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在每个Qt应用程序中都有一个全局的线程池对象, 通过这个函数直接访问这个对象</span></span><br><span class="line"><span class="function"><span class="type">static</span> QThreadPool * <span class="title">QThreadPool::globalInstance</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>一般情况下，我们不需要在 Qt 程序中创建线程池对象，直接使用 Qt 为每个应用程序提供的线程池全局对象即可。得到线程池对象之后，调用 start() 方法就可以将一个任务添加到线程池中，这个任务就可以被线程池内部的线程池处理掉了，使用线程池比自己创建线程的这种多种多线程方式更加简单和易于维护。</p><p><strong>具体的使用方式如下：</strong></p><ul><li><strong>mywork.h</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyWork</span> :<span class="keyword">public</span> QRunnable</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyWork</span><span class="params">()</span></span>;</span><br><span class="line">    ~<span class="built_in">MyWork</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>mywork.cpp</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MyWork::<span class="built_in">MyWork</span>() : <span class="built_in">QRunnable</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 任务执行完毕,该对象自动销毁</span></span><br><span class="line">    <span class="built_in">setAutoDelete</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyWork::run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 业务处理代码</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>mainwindow.cpp</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent) :</span><br><span class="line">    <span class="built_in">QMainWindow</span>(parent),</span><br><span class="line">    <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程池初始化，设置最大线程池数</span></span><br><span class="line">    QThreadPool::<span class="built_in">globalInstance</span>()-&gt;<span class="built_in">setMaxThreadCount</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="comment">// 添加任务</span></span><br><span class="line">    MyWork* task = <span class="keyword">new</span> MyWork;</span><br><span class="line">    QThreadPool::<span class="built_in">globalInstance</span>()-&gt;<span class="built_in">start</span>(task);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此看见，线程池的操作和QThread的run重写类似。<strong>使用线程池可以最大限度的利用线程，减少资源的浪费</strong></p><p><strong>比如我们需要同时处理三个事件</strong>：生成随机数，冒泡排序，快速排序（先生成随机数，然后再对其同时进行冒泡排序和快速排序）</p><p>用QThread的run重写的话，需要开启三个线程。</p><p>但是用线程池的话，它可以根据事件的长短，（将生成随机数和冒泡排序放在同一个线程去处理）只需要开启两个线程即可。</p><br><br><br><p><span style="color: red; font-size: 20px;">转载自：<a href="https://www.cnblogs.com/xyf327">唯有自己强大</a>          如有侵权，在下方评论  立刻删除。</span></p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt04多线程</title>
      <link href="/2025/03/13/Qt04%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2025/03/13/Qt04%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="一、知识回顾"><a href="#一、知识回顾" class="headerlink" title="一、知识回顾"></a><font color="FF0000">一、知识回顾</font></h3><p><strong>1，为什么需要多线程？</strong></p><ul><li><font color="FF0000">从计算机底层来说</font>： 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。 </li><li><font color="FF0000">从当代互联网发展趋势来说</font><strong>：</strong> 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</li></ul><p>再深入到计算机底层来探讨：</p><ul><li><font color="FF0000">单核时代</font>：在单核时代多线程主要是为了提高 CPU 和 IO 设备的综合利用率。举个例子：当只有一个线程的时候会导致 CPU 计算时，IO 设备空闲；进行 IO 操作时，CPU 空闲。我们可以简单地说这两者的利用率目前都是 50%左右。但是当有两个线程的时候就不一样了，当一个线程执行 CPU 计算时，另外一个线程可以进行 IO 操作，这样两个的利用率就可以在理想情况下达到 100%了。 </li><li><font color="FF0000">多核时代</font>: 多核时代多线程主要是为了提高 CPU 利用率。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，CPU 只会一个 CPU 核心被利用到，而创建多个线程就可以让多个 CPU 核心被利用到，这样就提高了 CPU 的利用率。</li></ul><p><strong>2，进程和线程的区别：</strong></p><p>进程：一个独立的程序，拥有独立的虚拟地址空间，要和其他进程通信，需要使用进程通信的机制。</p><p>线程：没有自己的资源，都是共享进程的虚拟地址空间，多个线程通信存在隐患。</p><p>PS：在操作系统每一个进程都拥有独立的内存空间，线程的开销远小于进程，一个进程可以拥有多个线程。（因此我们常用多线程并发，而非多进程并发）</p><p>为了更容易理解多线程的作用，先看一个实例：</p><p>在主线程中运行一个10s耗时的操作。（通过按钮来触发）</p><p><img src="https://bu.dusays.com/2025/03/13/67d28d3da16f3.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;threadtest.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;qthread.h&quot;</span></span></span><br><span class="line">Threadtest::<span class="built_in">Threadtest</span>(QWidget* parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    ui.<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">connect</span>(ui.btn_start, &amp;QPushButton::clicked, <span class="keyword">this</span>,  </span><br><span class="line">            &amp;Threadtest::on_pushButton_clicked);</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Threadtest::on_pushButton_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QThread::<span class="built_in">sleep</span>(<span class="number">10</span>);<span class="comment">//主线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到程序运行过程中，整个线程都在响应10秒的耗时操作，对于线程的消息循环exec()函数就未响应了（就是你在这个过程中拖动界面是无反应的）</p><p><img src="https://bu.dusays.com/2025/03/13/67d28db830489.png"></p><h3 id="二、线程类QThread"><a href="#二、线程类QThread" class="headerlink" title="二、线程类QThread"></a><font color="FF0000">二、线程类QThread</font></h3><p>Qt 中提供了一个线程类，通过这个类就可以创建子线程了，Qt 中一共提供了两种创建子线程的方式，后边会依次介绍其使用方式。先来看一下这个类中提供的一些常用 API 函数：</p><ul><li><strong>2.1 常用共用成员函数</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// QThread 类常用 API</span></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">QThread::<span class="built_in">QThread</span>(QObject *parent = Q_NULLPTR);</span><br><span class="line"><span class="comment">// 判断线程中的任务是不是处理完毕了</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QThread::isFinished</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 判断子线程是不是在执行任务</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QThread::isRunning</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Qt中的线程可以设置优先级</span></span><br><span class="line"><span class="comment">// 得到当前线程的优先级</span></span><br><span class="line"><span class="function">Priority <span class="title">QThread::priority</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QThread::setPriority</span><span class="params">(Priority priority)</span></span>;</span><br><span class="line">优先级:</span><br><span class="line">    QThread::IdlePriority        --&gt; 最低的优先级</span><br><span class="line">    QThread::LowestPriority</span><br><span class="line">    QThread::LowPriority</span><br><span class="line">    QThread::NormalPriority</span><br><span class="line">    QThread::HighPriority</span><br><span class="line">    QThread::HighestPriority</span><br><span class="line">    QThread::TimeCriticalPriority</span><br><span class="line">    QThread::InheritPriority    --&gt; 最高的优先级, 默认是这个</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 退出线程, 停止底层的事件循环</span></span><br><span class="line"><span class="comment">// 退出线程的工作函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QThread::exit</span><span class="params">(<span class="type">int</span> returnCode = <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="comment">// 调用线程退出函数之后, 线程不会马上退出因为当前任务有可能还没有完成, 调回用这个函数是</span></span><br><span class="line"><span class="comment">// 等待任务完成, 然后退出线程, 一般情况下会在 exit() 后边调用这个函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QThread::wait</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> time = ULONG_MAX)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><strong>2.2 信号槽</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 和调用 exit() 效果是一样的</span></span><br><span class="line"><span class="comment">// 调用这个函数之后, 再调用 wait() 函数</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QThread::quit</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 启动子线程</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QThread::start</span><span class="params">(Priority priority = InheritPriority)</span></span>;</span><br><span class="line"><span class="comment">// 线程退出, 可能是会马上终止线程, 一般情况下不使用这个函数</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QThread::terminate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程中执行的任务完成了, 发出该信号</span></span><br><span class="line"><span class="comment">// 任务函数中的处理逻辑执行完毕了</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QThread::finished</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 开始工作之前发出这个信号, 一般不使用</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QThread::started</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li><strong>2.3静态函数</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个指向管理当前执行线程的QThread的指针</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QThread *<span class="title">QThread::currentThread</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 返回可以在系统上运行的理想线程数 == 和当前电脑的 CPU 核心数相同</span></span><br><span class="line">[<span class="type">static</span>] <span class="function"><span class="type">int</span> <span class="title">QThread::idealThreadCount</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 线程休眠函数</span></span><br><span class="line">[<span class="type">static</span>] <span class="function"><span class="type">void</span> <span class="title">QThread::msleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> msecs)</span></span>;    <span class="comment">// 单位: 毫秒</span></span><br><span class="line">[<span class="type">static</span>] <span class="function"><span class="type">void</span> <span class="title">QThread::sleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> secs)</span></span>;    <span class="comment">// 单位: 秒</span></span><br><span class="line">[<span class="type">static</span>] <span class="function"><span class="type">void</span> <span class="title">QThread::usleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> usecs)</span></span>;    <span class="comment">// 单位: 微秒</span></span><br></pre></td></tr></table></figure><h3 id="三、Qt中实现多线程的两种方法"><a href="#三、Qt中实现多线程的两种方法" class="headerlink" title="三、Qt中实现多线程的两种方法"></a><font color="FF0000">三、Qt中实现多线程的两种方法</font></h3><p><strong>🧡🧡3.1.派生QThread类对象的方法（重写Run函数）</strong></p><p>首先，以文字形式来说明需要哪几个步骤。</p><ol><li>自定义一个自己的类，使其继承自QThread类；</li><li>在自定义类中覆写QThread类中的虚函数run()。</li></ol><p>这很可能就是C++中多态的使用。补充一点：QThread类继承自QObject类。</p><p>这里要重点说一下run()函数了。它作为线程的入口，也就是线程从run()开始执行，我们打算在线程中完成的工作都要写在run()函数中，个人认为可以把run()函数理解为线程函数。这也就是子类覆写基类的虚函数，基类QThread的run()函数只是简单启动exec()消息循环，关于这个exec()后面有很多东西要讲，请做好准备。<br>那么我们就来尝试用多线程实现10s耗时的操作：（用按钮触发)</p><ul><li><strong>1️⃣在编辑好ui界面后，先创建一个workThread的类。（继承自QThread类)</strong></li></ul><p><img src="https://bu.dusays.com/2025/03/13/67d2986e707f0.png"></p><ul><li>2️⃣<strong>在workThread1的类中重写run函数</strong></li></ul><p>在workThread.h的声明run函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;qthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">workThread</span> : <span class="keyword">public</span> QThread</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在workThread.cpp中重写run函数(并打印子线程的ID)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;workThread.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;qdebug.h&quot;</span></span></span><br><span class="line">workThread::<span class="built_in">workThread</span>(QObject* parent)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重写run函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">workThread::run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;当前子线程ID:&quot;</span> &lt;&lt; QThread::<span class="built_in">currentThreadId</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;开始执行线程&quot;</span>;</span><br><span class="line">    QThread::<span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;线程结束&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>3️⃣在主类中启动线程</strong></li></ul><p>threadtest.h中声明线程和按钮事件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtWidgets/QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_threadtest.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;workThread.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> execution_character_set(<span class="string">&quot;utf-8&quot;</span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Threadtest</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Threadtest</span>(QWidget *parent = Q_NULLPTR);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::ThreadtestClass ui;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">btn_clicked</span><span class="params">()</span></span>;</span><br><span class="line">workThread* thread;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>threadtest.cpp中实现，并启动子线程线程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;threadtest.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qthread.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qdebug.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Threadtest::<span class="built_in">Threadtest</span>(QWidget* parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    ui.<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">connect</span>(ui.btn_start, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;Threadtest::btn_clicked);</span><br><span class="line">   thread = <span class="keyword">new</span> <span class="built_in">workThread</span>(<span class="keyword">this</span>);  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Threadtest::btn_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;主线程id：&quot;</span> &lt;&lt; QThread::<span class="built_in">currentThreadId</span>();</span><br><span class="line">    thread-&gt;<span class="built_in">start</span>();<span class="comment">//启动子线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以实现，在执行耗时操作时也可拖动界面。</p><p><img src="https://bu.dusays.com/2025/03/13/67d28d3da16f3.png"></p><p><img src="https://bu.dusays.com/2025/03/13/67d298c015337.png"></p><p><strong>需要注意的是：</strong></p><p><strong>在主程序中添加workThread类的头文件时，需要将workThread.h放在threadtest.h中（不然会报错！！！！）</strong></p><p><img src="https://bu.dusays.com/2025/03/13/67d298dace251.png"></p><p>使用QThread::currentThreadId()来查看当前线程的ID，无论是子线程还是主线程，不同线程其ID是不同的。注意，这是一个静态函数，因此可以不经过对象来调用。</p><p><strong>创建的workThread1类的执行实际上是在主线程里的，只有run函数内的程序才会在子线程中执行！（即QThread只是线程的管理类，只有run()才是我们的线程函数）</strong></p><p>因此在QThread（即创建的类）中的成员变量属于主线程，在访问前需要判断访问是否安全。run（）中创建的变量属于子线程。</p><p>线程之间共享内存是不安全的（由于多线程争夺资源会影响数据安全问题），解决的办法就是要上锁。</p><p><strong><p align = "center">关于互斥锁</p></strong></p><p>个人认为，exec()这个点太重要了，同时还不太容易理解。</p><p>比如下面的代码中有两个exec()，我们讲“一山不容二虎”，放在这里就是说，一个线程中不能同时运行两个exec()，否则就会造成另一个消息循环得不到消息。像QDialog模态窗口中的exec()就是因为在主线程中同时开了两个exec()，导致主窗口的exec()接收不到用户的消息了。但是！但是！但是！我们这里却没有任何问题，因为它们没有出现在同一个线程中，一个是主线程中的exec()，一个是子线程中的exec()。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QThread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span>:<span class="keyword">public</span> QThread</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;child thread begin&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;child thread&quot;</span>&lt;&lt;QThread::<span class="built_in">currentThreadId</span>()&lt;&lt;endl;</span><br><span class="line">            QThread::<span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">            <span class="built_in">qDebugu</span>()&lt;&lt;<span class="string">&quot;QThread end&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">exec</span>();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> ** argv)</span> <span class="comment">//mian()作为主线程</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc,argv)</span></span>;</span><br><span class="line"> </span><br><span class="line">    MyThread thread; <span class="comment">//创建一个QThread派生类对象就是创建了一个子线程</span></span><br><span class="line">    thread.<span class="built_in">start</span>(); <span class="comment">//启动子线程，然后会自动调用线程函数run()</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;main thread&quot;</span>&lt;&lt;QThread::<span class="built_in">currentThreadId</span>()&lt;&lt;endl;</span><br><span class="line">    QThread::<span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">qDebugu</span>()&lt;&lt;<span class="string">&quot;main thread&quot;</span>&lt;&lt;QThread::<span class="built_in">currentThreadId</span>()&lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">    thread.<span class="built_in">quit</span>(); <span class="comment">//使用quit()或者exit()使得子线程能够退出消息循环，而不至于陷在子线程中</span></span><br><span class="line">    thread.<span class="built_in">wait</span>(); <span class="comment">//等待子线程退出，然后回收资源</span></span><br><span class="line">                   <span class="comment">//thread.wait(5000); //设定等待的时间</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果run()函数中没有执行exec()消息循环函数，那么run()执行完了也就意味着子线程退出了。一般在子线程退出的时候需要主线程去回收资源，可以调用QThread的wait()，使主线程等待子线程退出，然后回收资源。这里wait()是一个阻塞函数，有点像C++11中的join()函数。</p><p>但是！但是！但是！run()函数中调用了exec()函数，exec()是一个消息循环，也可以叫做事件循环，也是会阻塞的，相当于一个死循环使子线程卡在这里永不退出，必须调用QThread的quit()函数或者exit()函数才可以使子线程退出消息循环，并且有时还不是马上就退出，需要等到CPU的控制权交给线程的exec()。</p><p>所以先要thread.quit();使退出子线程的消息循环， 然后thread.wait();在主线程中回收子线程的资源。</p><p><strong>值得注意的有两点</strong>：子线程的exet()消息循环必须在run()函数中调用；如果没有消息循环的话，则没有必要调用quit( )或者exit()，因为调用了也不会起作用。</p><p>第一种创建线程的方式需要在run()中显式调用exec()，但是exec()有什么作用呢，目前还看不出来，需要在第二种创建线程的方式中才能知道。</p><hr><p> <strong>💜💜3.2.使用信号与槽方式来实现多线程</strong></p><p> 刚讲完使用QThread派生类对象的方法创建线程，现在就要来说它一点坏话。这种方法存在一个局限性，只有一个run()函数能够在线程中去运行，但是当有多个函数在同一个线程中运行时，就没办法了，至少实现起来很麻烦。所以，当当当当，下面将介绍第二种创建线程的方式：<strong>使用信号与槽的方式，也就是把在线程中执行的函数（我们可以称之为线程函数）定义为一个槽函数。</strong></p><p>仍然是首先以文字形式说明这种方法的几个步骤。</p><ul><li>创建一个新的类(mywork)，让这个类从 QObject 派生，在这个类中添加一个公共的成员函数(working)，函数体就是我们要子线程中执行的业务逻辑</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyWork</span>:<span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    .......</span><br><span class="line">    <span class="comment">// 函数名自己指定, 叫什么都可以, 参数可以根据实际需求添加</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">working</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在主线程中创建一个 QThread 对象，这就是子线程的对象</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QThread* sub = <span class="keyword">new</span> QThread;</span><br></pre></td></tr></table></figure><ul><li>在主线程中创建工作的类对象（千万不要指定给创建的对象指定父对象）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyWork* work = <span class="keyword">new</span> <span class="built_in">MyWork</span>(<span class="keyword">this</span>);    <span class="comment">// error</span></span><br><span class="line">MyWork* work = <span class="keyword">new</span> MyWork;          <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><ul><li>将 MyWork 对象移动到创建的子线程对象中，需要调用 QObject 类提供的 moveToThread() 方法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// void QObject::moveToThread(QThread *targetThread);</span></span><br><span class="line"><span class="comment">// 如果给work指定了父对象, 这个函数调用就失败了</span></span><br><span class="line"><span class="comment">// 提示： QObject::moveToThread: Cannot move objects with a parent</span></span><br><span class="line">work-&gt;<span class="built_in">moveToThread</span>(sub);    <span class="comment">// 移动到子线程中工作</span></span><br></pre></td></tr></table></figure><ul><li>启动子线程，调用 start(), 这时候线程启动了，但是移动到线程中的对象并没有工作</li><li>调用 MyWork 类对象的工作函数，让这个函数开始执行，这时候是在移动到的那个子线程中运行的</li></ul><p><strong>代码实例：</strong></p><ul><li>1️⃣<strong>创建一个workThread的类。（继承自QThread类）</strong></li></ul><p>定义槽函数（<strong>子线程执行的程序都可以放在槽函数中</strong>）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//workThread.cpp（先在workThread.h中声明槽函数）void workThread:: doWork()</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;当前线程ID:&quot;</span>&lt;&lt;QThread::<span class="built_in">currentThreadId</span>();</span><br><span class="line">      <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;开始执行&quot;</span>;</span><br><span class="line">      QThread::<span class="built_in">sleep</span>(<span class="number">10</span>);    </span><br><span class="line">      <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;结束执行&quot;</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>2️⃣<strong>主线程中分别对workThread类和QTread类实例化</strong></li></ul><p>在threadtest.h中声明</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtWidgets/QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_threadtest.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;workThread.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;qthread.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> execution_character_set(<span class="string">&quot;utf-8&quot;</span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Threadtest</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Threadtest</span>(QWidget *parent = Q_NULLPTR);  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::ThreadtestClass ui;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">btn_clicked</span><span class="params">()</span></span>;</span><br><span class="line">    workThread* thread; <span class="comment">//实例化workThread类</span></span><br><span class="line">    QThread* qthread;   <span class="comment">//实例化QThread类</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在threadtest.cpp中实现<strong>并通过moveToThread将自己放到线程QThread对象中，最后启动线程</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;threadtest.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;qthread.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;qdebug.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Threadtest::<span class="built_in">Threadtest</span>(QWidget* parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    ui.<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//不能指定自定义类的对象的父类为widget，即没有this（很重要！！！！）</span></span><br><span class="line">   thread = <span class="keyword">new</span> <span class="built_in">workThread</span>();  </span><br><span class="line">   qthread1 = <span class="keyword">new</span> <span class="built_in">QThread</span>(<span class="keyword">this</span>);</span><br><span class="line">   thread-&gt;<span class="built_in">moveToThread</span>(qthread1);</span><br><span class="line">   <span class="comment">//线程结束时清理线程内存</span></span><br><span class="line">   <span class="built_in">connect</span>(qthread1, &amp;QThread::finished, qthread1, &amp;QThread::deleteLater);</span><br><span class="line">   <span class="comment">//将按钮事件（信号）绑定槽函数</span></span><br><span class="line">   <span class="built_in">connect</span>(ui.btn_start, &amp;QPushButton::clicked, thread, &amp;workThread::dowork);</span><br><span class="line">   <span class="comment">//打印主线程</span></span><br><span class="line">   <span class="built_in">connect</span>(ui.btn_start, &amp;QPushButton::clicked, [=]() &#123;</span><br><span class="line">       <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;主线程id：&quot;</span> &lt;&lt; QThread::<span class="built_in">currentThreadId</span>();</span><br><span class="line">       &#125;);</span><br><span class="line">   <span class="comment">//线程启动</span></span><br><span class="line">   qthread1-&gt;<span class="built_in">start</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在运行槽函数时，不能在此直接调用（如：thread1-&gt;doWork()）。而是用connect连接信号和槽</p><p>这里将打印主线程和槽函数都绑定在了button按钮的click事件上了。</p><p><img src="https://bu.dusays.com/2025/03/13/67d28d3da16f3.png"></p><p><img src="https://bu.dusays.com/2025/03/13/67d2995e14e1b.png"></p><ul><li><strong>子线程中不能操作UI</strong></li></ul><p>Qt创建的子线程中是不能对UI对象进行任何操作的，即QWidget及其派生类对象，这个是我掉的第一个坑。可能是由于考虑到安全性的问题，所以Qt中子线程不能执行任何关于界面的处理，包括消息框的弹出。正确的操作应该是通过信号槽，将一些参数传递给主线程，让主线程（也就是Controller）去处理。</p><ul><li><strong>自定义的类不能指定父对象</strong></li></ul><p>比如上面程序中的：（不能指定自定义类对象为widget，即不可以加this）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread1=<span class="keyword">new</span> <span class="built_in">workThread1</span>();<span class="comment">//初始化</span></span><br></pre></td></tr></table></figure><ul><li><strong>QThread和connect的关系</strong></li></ul><p>我们使用最多的是QThread于connect的关系，在使用connect函数的时候，我们一般会把最后一个参数忽略掉。这时候我们需要看下函数原型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">static</span>] <span class="function">QMetaObject::Connection <span class="title">QObject::connect</span><span class="params">(<span class="type">const</span> QObject *sender, <span class="type">const</span> <span class="type">char</span> *signal, <span class="type">const</span> QObject *receiver, <span class="type">const</span> <span class="type">char</span> *method, Qt::ConnectionType type = Qt::AutoConnection)</span></span></span><br></pre></td></tr></table></figure><p>可以看到，最后一个参数代表的是连接的方式。我们一般会用到方式是有三种：</p><p><strong>自动连接(AutoConnection)</strong>：默认的连接方式。如果信号与槽，也就是发送者与接受者在同一线程，等同于直接连接；如果发送者与接受者处在不同线程，等同于队列连接。</p><p><strong>直接连接(Direct Connection)</strong>：当信号发射时，槽函数将直接被调用。无论槽函数所属对象在哪个线程，槽函数都在发射者所在线程执行。</p><p><strong>队列连接(Queued Connection)</strong>：当控制权回到接受者所在线程的事件循环式，槽函数被调用。槽函数在接收者所在线程执行。</p><p><strong>因此我们需要注意的是：</strong></p><ol><li>主线程对象发出信号连接QThread子类的槽函数，QThread子类对象在主线程创建的，无论采用哪种连接方式，槽函数都属在主线程调用。（如果在重写的run函数中调用了槽函数，此时槽函数在次线程执行，注意数据安全）。</li><li>次线程run中发出信号，槽函数可以是发出信号对象自身的槽函数，自发自收，都是次线程中行。槽函数是QThread子类的槽函数，或者主线程中对象的槽函数，这里的种情况需要你指明run中connect中的连接方式，直连则该槽函数在次线程中执行（可能发生数据安全问题），列队则在主线程执行。</li></ol><p><strong>🧡🧡总结一下：</strong></p><ul><li>一定要用信号槽机制，别想着直接调用，你会发现并没有在子线程中执行。</li><li>自定义的类不能指定父对象，因为moveToThread函数会将线程对象指定为自定义的类的父对象，当自定义的类对象已经有了父对象，就会报错。</li><li>当一个变量需要在多个线程间进行访问时，最好加上voliate关键字，以免读取到的是旧的值。当然，Qt中提供了线程同步的支持，比如互斥锁之类的玩意，使用这些方式来访问变量会更加安全。</li><li>分析发出信号的对象和接受信号对象所在的线程，再通过连接方式，判断槽函数在哪里执行。（小白在使用中就有在run中创建对象-因为多非槽函数都需要在次线程中执行，通过指针引出来，再connect与其他模块交互，指明连接方式为列队形式，所以相关执行都在次线程中执行）。这里记住moveToThread只能将槽函数移到次线程中。</li></ul><p><strong><p align = "center">启动多线程的操作思路</p></strong></p><p>如果我们需要实现一个排序操作，即首先获取1000个随机数，然后用冒泡排序法对其进行排序。</p><p><strong>方法一：重写run函数</strong></p><p> <strong>思路：（构建两个子线程，一个用于生成随机数，一个用于冒泡排序，主线程负责调用）</strong></p><ul><li>新建myThread类，在该类中重写run函数（即生随机数）。需要先接收主线程发送的要生成随机数的个数（scvnum信号）后再进行生成，生成完成以后发送一个sendArray信号</li><li>新建BubbleSort类，在该类中重写run函数（即冒泡排序算法）。需要先接收已经生成的随机数（rcvArray信号）后再进行排序，排序完成后发送一个finish信号</li><li>主线程通过stating信号告诉myThread线程要生成的个数，然后myThread线程通过scvnum信号接收，进行生成随机数，然后再发送一个sendArray信号（即生成随机数集合）</li><li>BubbleSort子线程通过rcvArray信号接收sendArray信号（即接收随机数）然后进行冒泡排序，再发送finish信号</li><li>主线程接收到finish信号后，将排序后的随机数显示在界面上</li></ul><p><strong>实现代码：</strong></p><ul><li><strong>子线程.h</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;qthread.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;qvector.h&quot;</span></span></span><br><span class="line"><span class="comment">//新建随机数类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myThread</span> :</span><br><span class="line">    <span class="keyword">public</span> QThread</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">myThread</span>(QObject* parent = <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">scvnum</span><span class="params">(<span class="type">int</span> num)</span></span>;<span class="comment">//接收数字</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendArray</span><span class="params">(QVector&lt;<span class="type">int</span>&gt;num)</span></span>;<span class="comment">//发送</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新建冒泡排序类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BubbleSort</span> :</span><br><span class="line">    <span class="keyword">public</span> QThread</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BubbleSort</span>(QObject* parent = <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rcvArray</span><span class="params">(QVector&lt;<span class="type">int</span>&gt;list)</span></span>;<span class="comment">//要接收的是排序的数</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">finish</span><span class="params">(QVector&lt;<span class="type">int</span>&gt;list)</span></span>;<span class="comment">//排序完成后发送一个finish信号</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QVector&lt;<span class="type">int</span>&gt;m_list;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>子线程.cpp</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myThread.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;qelapsedtimer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;qdebug.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">myThread::<span class="built_in">myThread</span>(QObject* parent) :<span class="built_in">QThread</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">BubbleSort::<span class="built_in">BubbleSort</span>(QObject* parent) : <span class="built_in">QThread</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myThread::scvnum</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_num = num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myThread::run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;child thread id&quot;</span> &lt;&lt; QThread::<span class="built_in">currentThreadId</span>();</span><br><span class="line">    QVector&lt;<span class="type">int</span>&gt; list;</span><br><span class="line">    QElapsedTimer time;</span><br><span class="line">    time.<span class="built_in">start</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        list.<span class="built_in">push_back</span>(<span class="built_in">qrand</span>() % <span class="number">100000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> milsec = time.<span class="built_in">elapsed</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;The number of&quot;</span> &lt;&lt; m_num &lt;&lt; <span class="string">&quot;generated&quot;</span>;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;shared&quot;</span> &lt;&lt; milsec &lt;&lt; <span class="string">&quot;second&quot;</span>;</span><br><span class="line">    <span class="function">emit <span class="title">sendArray</span><span class="params">(list)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort::rcvArray</span><span class="params">(QVector&lt;<span class="type">int</span>&gt; list)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_list = list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort::run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;BubbleSort thread id:&quot;</span> &lt;&lt; QThread::<span class="built_in">currentThreadId</span>();</span><br><span class="line">    QElapsedTimer time;</span><br><span class="line">    time.<span class="built_in">start</span>();</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_list.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m_list.<span class="built_in">size</span>()-i<span class="number">-1</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_list[j] &gt; m_list[j + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                temp = m_list[j];</span><br><span class="line">                m_list[j] = m_list[j + <span class="number">1</span>];</span><br><span class="line">                m_list[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> milsec = time.<span class="built_in">elapsed</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;shared&quot;</span> &lt;&lt; milsec &lt;&lt; <span class="string">&quot;second&quot;</span>;</span><br><span class="line">    <span class="function">emit <span class="title">finish</span><span class="params">(m_list)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>主线程.h</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtWidgets/QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;ui_list.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">list</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">list</span>(QWidget *parent = Q_NULLPTR);</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stating</span><span class="params">(<span class="type">int</span> num)</span></span>;<span class="comment">//设置要生成随机数个数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::listClass ui;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>主线程.cpp</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;list.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;myThread.h&quot;</span></span></span><br><span class="line">list::<span class="built_in">list</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    ui.<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//1.创建子线程对象</span></span><br><span class="line">    myThread* thread = <span class="keyword">new</span> <span class="built_in">myThread</span>();</span><br><span class="line">    BubbleSort* bub_thread = <span class="keyword">new</span> <span class="built_in">BubbleSort</span>();</span><br><span class="line">    <span class="comment">//向子线程发送要生成的随机数个数</span></span><br><span class="line">    <span class="built_in">connect</span>(<span class="keyword">this</span>,&amp;list::stating, thread, &amp;myThread::scvnum);</span><br><span class="line">    <span class="comment">//2启动子线程</span></span><br><span class="line">    <span class="built_in">connect</span>(ui.pushButton, &amp;QPushButton::clicked,  [=]() &#123;</span><br><span class="line">        emit <span class="built_in">stating</span>(<span class="number">1000</span>);<span class="comment">//主线程设置子线程随机数的个数</span></span><br><span class="line">        thread-&gt;<span class="built_in">start</span>();</span><br><span class="line">    </span><br><span class="line">        </span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="built_in">connect</span>(thread, &amp;myThread::sendArray, bub_thread, &amp;BubbleSort::rcvArray);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3接收子线程发送的数据</span></span><br><span class="line">    <span class="built_in">connect</span>(thread, &amp;myThread::sendArray,  [=](QVector&lt;<span class="type">int</span>&gt;list) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; list.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ui.randlist-&gt;<span class="built_in">addItem</span>(QString::<span class="built_in">number</span>(list.<span class="built_in">at</span>(i)));</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="built_in">connect</span>(thread, &amp;myThread::sendArray, [=](QVector&lt;<span class="type">int</span>&gt;list)&#123;</span><br><span class="line">        bub_thread-&gt;<span class="built_in">start</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="built_in">connect</span>(bub_thread, &amp;BubbleSort::finish, [=](QVector&lt;<span class="type">int</span>&gt;list) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; list. <span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ui.bubblelist-&gt;<span class="built_in">addItem</span>(QString::<span class="built_in">number</span>(list.<span class="built_in">at</span>(i)));</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2025/03/13/67d299b1220c9.gif"></p><p><strong>方法二：moveToThread()</strong> </p><p><strong>思路：</strong></p><ul><li>新建myThread类，用于生成随机数（working函数），在接受到主线程的信号后开始生成随机数</li><li>新建BubbleSort类，用于排序(working函数），在接受到myThread类生成的随机数后开始排序</li><li>最后显示在界面</li></ul><p><strong>代码实现：</strong></p><ul><li><strong>子线程.h</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;qthread.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;qvector.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;qobject.h&quot;</span></span></span><br><span class="line"><span class="comment">//新建随机数类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myThread</span> :</span><br><span class="line">    <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">myThread</span>(QObject* parent = <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">working</span><span class="params">(<span class="type">int</span> num)</span></span>;<span class="comment">//生成随机数</span></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendArray</span><span class="params">(QVector&lt;<span class="type">int</span>&gt;num)</span></span>;<span class="comment">//发送</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新建冒泡排序类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BubbleSort</span> :</span><br><span class="line">    <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BubbleSort</span>(QObject* parent = <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">working</span><span class="params">(QVector&lt;<span class="type">int</span>&gt;list)</span></span>;<span class="comment">//要接收的是排序的数</span></span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">finish</span><span class="params">(QVector&lt;<span class="type">int</span>&gt;list)</span></span>;<span class="comment">//排序完成后发送一个finish信号</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>子线程.cpp</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myThread.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;qelapsedtimer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;qdebug.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">myThread::<span class="built_in">myThread</span>(QObject* parent) :<span class="built_in">QObject</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">BubbleSort::<span class="built_in">BubbleSort</span>(QObject* parent) : <span class="built_in">QObject</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myThread::working</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;child thread id&quot;</span> &lt;&lt; QThread::<span class="built_in">currentThreadId</span>();</span><br><span class="line">    QVector&lt;<span class="type">int</span>&gt; list;</span><br><span class="line">    QElapsedTimer time;</span><br><span class="line">    time.<span class="built_in">start</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        list.<span class="built_in">push_back</span>(<span class="built_in">qrand</span>() % <span class="number">100000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> milsec = time.<span class="built_in">elapsed</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;The number of&quot;</span> &lt;&lt; m_num &lt;&lt; <span class="string">&quot;generated&quot;</span>;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;shared&quot;</span> &lt;&lt; milsec &lt;&lt; <span class="string">&quot;second&quot;</span>;</span><br><span class="line">    <span class="function">emit <span class="title">sendArray</span><span class="params">(list)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort::working</span><span class="params">(QVector&lt;<span class="type">int</span>&gt;list)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;BubbleSort thread id:&quot;</span> &lt;&lt; QThread::<span class="built_in">currentThreadId</span>();</span><br><span class="line">    QElapsedTimer time;</span><br><span class="line">    time.<span class="built_in">start</span>();</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; list.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; list.<span class="built_in">size</span>()-i<span class="number">-1</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (list[j] &gt; list[j + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                temp = list[j];</span><br><span class="line">                list[j] = list[j + <span class="number">1</span>];</span><br><span class="line">                list[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> milsec = time.<span class="built_in">elapsed</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;shared&quot;</span> &lt;&lt; milsec &lt;&lt; <span class="string">&quot;second&quot;</span>;</span><br><span class="line">    <span class="function">emit <span class="title">finish</span><span class="params">(list)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>主线程.h</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtWidgets/QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;ui_list.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">list</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">list</span>(QWidget *parent = Q_NULLPTR);</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stating</span><span class="params">(<span class="type">int</span> num)</span></span>;<span class="comment">//设置要生成随机数个数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::listClass ui;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>主线程.cpp</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;list.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;myThread.h&quot;</span></span></span><br><span class="line">list::<span class="built_in">list</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    ui.<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//1.创建QThread对象</span></span><br><span class="line">    QThread* thread1 = <span class="keyword">new</span> QThread;</span><br><span class="line">    QThread* thread2 = <span class="keyword">new</span> QThread;</span><br><span class="line">    <span class="comment">//2.创建子线程类对象</span></span><br><span class="line">    myThread* myth = <span class="keyword">new</span> <span class="built_in">myThread</span>();</span><br><span class="line">    BubbleSort* bub = <span class="keyword">new</span> <span class="built_in">BubbleSort</span>();</span><br><span class="line">    <span class="comment">//3通过movetothread将子线程对象移动到QThread对象中</span></span><br><span class="line">    myth-&gt;<span class="built_in">moveToThread</span>(thread1);</span><br><span class="line">    bub-&gt;<span class="built_in">moveToThread</span>(thread2);</span><br><span class="line">    <span class="comment">//4启动子线程</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//先向子线程发送要生成的随机数个数</span></span><br><span class="line">    <span class="built_in">connect</span>(<span class="keyword">this</span>,&amp;list::stating, myth, &amp;myThread::working);</span><br><span class="line">    <span class="comment">//再启动子线程</span></span><br><span class="line">    <span class="built_in">connect</span>(ui.pushButton, &amp;QPushButton::clicked,  [=]() &#123;</span><br><span class="line">        emit <span class="built_in">stating</span>(<span class="number">1000</span>);<span class="comment">//主线程设置子线程随机数的个数</span></span><br><span class="line">        thread1-&gt;<span class="built_in">start</span>();        </span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="comment">//将生成好的随机数发送给BubbleSort类</span></span><br><span class="line">    <span class="built_in">connect</span>(myth, &amp;myThread::sendArray, bub, &amp;BubbleSort::working);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将生成好的随机数显示在界面</span></span><br><span class="line">    <span class="built_in">connect</span>(myth, &amp;myThread::sendArray,  [=](QVector&lt;<span class="type">int</span>&gt;list) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; list.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ui.randlist-&gt;<span class="built_in">addItem</span>(QString::<span class="built_in">number</span>(list.<span class="built_in">at</span>(i)));</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="comment">//发送的同时启动排序算法</span></span><br><span class="line">    <span class="built_in">connect</span>(myth, &amp;myThread::sendArray, [=](QVector&lt;<span class="type">int</span>&gt;list)&#123;</span><br><span class="line">        thread2-&gt;<span class="built_in">start</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="comment">//将排序好的数显示在界面</span></span><br><span class="line">    <span class="built_in">connect</span>(bub, &amp;BubbleSort::finish, [=](QVector&lt;<span class="type">int</span>&gt;list) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; list. <span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ui.bubblelist-&gt;<span class="built_in">addItem</span>(QString::<span class="built_in">number</span>(list.<span class="built_in">at</span>(i)));</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结论</strong></p><p>通过对比，我们可以发现：</p><ul><li>由于第二种方法，我们可以自定义带参的子线程运行函数，因此代码更加简洁。</li><li>在第二种方法中，我们还可以随意修改需要在哪个线程中运行，代码也更加灵活。</li><li>第一种方法适合在线程中处理单一事件，其逻辑简单（只需要新建一个继承自QThread类的对象，重写run函数，然后启动即可），对于需要在一个线程中处理多个事件，还是用第二种方法比较好。</li><li>为什么不能在第二种方法中，给定义的子线程对象添加父类呢？ ：由于添加了父类以后就不能再移动到QThread中去了</li></ul><p><strong>如何进行线程资源的释放？</strong></p><ol><li>在new对象时候，直接用this指定其父类（即放入对象数中）</li><li>在程序最后自行释放资源</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(<span class="keyword">this</span>, &amp;list::destroyed, <span class="keyword">this</span>, [=]() &#123;</span><br><span class="line">    thread1-&gt;<span class="built_in">quit</span>();</span><br><span class="line">    thread1-&gt;<span class="built_in">wait</span>();</span><br><span class="line">    thread1-&gt;<span class="built_in">deleteLater</span>();</span><br><span class="line">    thread2-&gt;<span class="built_in">quit</span>();</span><br><span class="line">    thread2-&gt;<span class="built_in">wait</span>();</span><br><span class="line">    thread2-&gt;<span class="built_in">deleteLater</span>();</span><br><span class="line">    myth-&gt;<span class="built_in">deleteLater</span>();</span><br><span class="line">    bub-&gt;<span class="built_in">deleteLater</span>();</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><br><br><br><p><span style="color: red; font-size: 20px;">转载自：<a href="https://www.cnblogs.com/xyf327">唯有自己强大</a>          如有侵权，在下方评论  立刻删除。</span></p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt03文件读写</title>
      <link href="/2025/03/13/Qt03%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/"/>
      <url>/2025/03/13/Qt03%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/</url>
      
        <content type="html"><![CDATA[<p>Qt 提供了两种读写纯文本文件的基本方法：</p><ol><li>用 <strong>QFile 类</strong>的 IODevice 读写功能直接进行读写</li><li>利用 <strong>QFile</strong> 和 <strong>QTextStream</strong> 结合起来，用流（Stream)的方法进行文件读写。</li></ol><h3 id="一、文件读操作"><a href="#一、文件读操作" class="headerlink" title="一、文件读操作"></a><font color="FF0000">一、文件读操作</font></h3><p><strong>（1）使用QFile类</strong></p><p>Qt封装了QFile类，方便我们对文件进行操作，可以按照如下的步骤进行：</p><ul><li>使用QFile加载文件对象</li><li>打开文件 file.open(打开方式)</li><li>操作文件</li><li>关闭文件 file.close()</li></ul><p><strong>实例：点击读写文件按钮，读取文件内容到textEdit中</strong></p><p>1️⃣设置 ui 界面</p><p><img src="https://bu.dusays.com/2025/03/13/67d284db41c18.png"></p><p>2️⃣在widget.cpp中编辑代码（QFileDialog类是打开文件）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//点击选取文件按钮，弹出文件对话框</span></span><br><span class="line"> <span class="built_in">connect</span>(ui-&gt;pushButton,&amp;QPushButton::clicked,[=]()&#123;</span><br><span class="line"> QString path = QFileDialog::<span class="built_in">getOpenFileName</span>(<span class="keyword">this</span>,<span class="string">&quot;打开文件&quot;</span>,<span class="string">&quot;C:/Users/WFD/Desktop&quot;</span>);</span><br><span class="line"><span class="comment">//将路径显示在lineEdit中</span></span><br><span class="line">ui-&gt;lineEdit-&gt;<span class="built_in">setText</span>(path);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//读取文件内容，放入textEdit中</span></span><br><span class="line">   QFile <span class="built_in">file</span>(path);<span class="comment">//参数就是文件的路径</span></span><br><span class="line">   <span class="comment">//设置打开方式</span></span><br><span class="line">   file.<span class="built_in">open</span>(QIODevice::ReadOnly);</span><br><span class="line">   <span class="comment">//用QByteArray类去接收读取的信息</span></span><br><span class="line">   QByteArray array=file.<span class="built_in">readAll</span>();</span><br><span class="line">   <span class="comment">//将读取到的数据放入textEdit中</span></span><br><span class="line">   ui-&gt;textEdit-&gt;<span class="built_in">setText</span>(array);</span><br><span class="line">   <span class="comment">//关闭文件对象</span></span><br><span class="line">   file.<span class="built_in">close</span>();</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2025/03/13/67d2853788ad5.png"></p><p><strong>注意：在设置打开方式的时候</strong></p><p>QFile::open() 函数打开文件时需要传递 <code>QIODevice::OpenModeFlag</code> 枚举类型的参数，决定文件以什么方式打开，QIODevice::OpenModeFlag 类型的主要取值如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">QIODevice::ReadOnly  <span class="comment">//以只读方式打开文件，用于载入文件。</span></span><br><span class="line">QIODevice::WriteOnly  <span class="comment">//以只写方式打开文件，用于保存文件。</span></span><br><span class="line">QIODevice::ReadWrite <span class="comment">//以读写方式打开。</span></span><br><span class="line">QIODevice::Append  <span class="comment">//以添加模式打开，新写入文件的数据添加到文件尾部。</span></span><br><span class="line">QIODevice::Truncate <span class="comment">//以截取方式打开文件，文件原有的内容全部被删除。</span></span><br><span class="line">QIODevice::Text       <span class="comment">//以文本方式打开文件，读取时“\n”被自动翻译为换行符，写入时字符串结束符会自动翻译为系统平台的编码，如 Windows 平台下是“\r\n”。</span></span><br><span class="line"></span><br><span class="line">这些取值可以组合，例如 QIODevice::ReadOnly | QIODevice::Text 表示以只读和文本方式打开文件。</span><br></pre></td></tr></table></figure><p> <strong>注意：在操作文件时</strong></p><p>用只读方式打开一个文本文件，然后用readAll()方法将文件内容一次全部读取出来，返回值是字节数组QByteArray。QByteArray用来存放二进制数据，如果想要看文字内容需要转换成QString。(有时候系统会自动转换）</p><p>我们也可以使用readLine方法一次读取一行，然后每次对一行文字进行操作：（用file.atEnd判断是否读到最后一行）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QByteArray array;</span><br><span class="line"> <span class="keyword">while</span>(!file.<span class="built_in">atEnd</span>())</span><br><span class="line"> &#123;</span><br><span class="line">      array+=file.<span class="built_in">readLine</span>();<span class="comment">//+=叠加读过的行</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>（2）使用QTextStream类</strong></p><p>如果操作的是文本文件，Qt还专门封装了一个处理文本流的类，我们可以用它来读取文本内容</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//点击选取文件按钮，弹出文件对话框</span></span><br><span class="line"><span class="built_in">connect</span>(ui-&gt;pushButton,&amp;QPushButton::clicked,[=]()&#123;</span><br><span class="line">  QString path=  QFileDialog::<span class="built_in">getOpenFileName</span>(<span class="keyword">this</span>,<span class="string">&quot;打开文件&quot;</span>,<span class="string">&quot;C:/Users/WFD/Desktop&quot;</span>);</span><br><span class="line">  <span class="comment">//将路径放在lineEdit中</span></span><br><span class="line">  ui-&gt;lineEdit-&gt;<span class="built_in">setText</span>(path);</span><br><span class="line">  <span class="comment">//读取文件内容，放入textEdit中</span></span><br><span class="line">  QFile <span class="built_in">file</span>(path);<span class="comment">//参数就是文件的路径</span></span><br><span class="line">  <span class="comment">//设置打开方式</span></span><br><span class="line">  file.<span class="built_in">open</span>(QIODevice::ReadOnly);</span><br><span class="line">  <span class="comment">//用QTextStream类去读取文本信息</span></span><br><span class="line"> QTextStream <span class="built_in">QS</span>(&amp;file);</span><br><span class="line"> <span class="comment">//用QString类去接收读取的信息</span></span><br><span class="line"> QString array=QS.<span class="built_in">readAll</span>();</span><br><span class="line">  <span class="comment">//将读取到的数据放入textEdit中</span></span><br><span class="line">  ui-&gt;textEdit-&gt;<span class="built_in">setText</span>(array);</span><br><span class="line">  <span class="comment">//关闭文件对象</span></span><br><span class="line">  file.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure><h3 id="二、文件写操作"><a href="#二、文件写操作" class="headerlink" title="二、文件写操作"></a><font color="FF0000">二、文件写操作</font></h3><p><strong>（1）使用QFile类</strong></p><p>使用QFile同样可以对文件进行写操作：</p><p><img src="https://bu.dusays.com/2025/03/13/67d28680b7eb2.png"></p><p><strong>2）使用QTextStream类</strong></p><p> QTextStream类对操作符进行了重载，我们可以通过 &lt;&lt; 操作符将字符串流入文本文件：</p><p><img src="https://bu.dusays.com/2025/03/13/67d2869e099cf.png"></p><h3 id="三、文件信息读取"><a href="#三、文件信息读取" class="headerlink" title="三、文件信息读取"></a><font color="FF0000">三、文件信息读取</font></h3><p>除了对文件的读写操作，Qt还封装了QFileInfo类帮助我们获取文件的元数据，比如文件大小、后缀名、创建时间、最后修改时间等等：</p><p><img src="https://bu.dusays.com/2025/03/13/67d286ffb59dc.png"></p><p><strong>拓展：</strong></p><ul><li><strong>各编码转换</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QString -&gt; QByteArray      QString.<span class="built_in">toUtf8</span>();</span><br><span class="line"></span><br><span class="line">QByteArray -&gt; std::string  QByteArray.<span class="built_in">toStdString</span>();</span><br><span class="line"></span><br><span class="line">std::string -&gt; <span class="type">char</span> *        string.<span class="built_in">date</span>();</span><br></pre></td></tr></table></figure><ul><li><strong>常用静态函数</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QFileDialog::<span class="built_in">getOpenFileName</span>()    <span class="comment">//获取指定文件路径名返回QString</span></span><br><span class="line">QFileDialog::<span class="built_in">getExistingDirectory</span>()  <span class="comment">//获取指定路径返回QString</span></span><br><span class="line">QFileDialog::<span class="built_in">getSaveFileName</span>()    <span class="comment">//获取指定保存路径名返回QString</span></span><br></pre></td></tr></table></figure><p><strong><p align = "center">QT配置ini文件的建立，读取，写入操作</p></strong></p><p><strong>1 ini文件介绍</strong></p><p>.ini 文件是Initialization File的缩写，即初始化文件。</p><p>除了windows现在很多其他操作系统下面的应用软件也有.ini文件，用来配置应用软件以实现不同用户的要求。一般不用直接编辑这些.ini文件，应用程序的图形界面即可操作以实现相同的功能。它可以用来存放软件信息,注册表信息等。</p><p><strong>2 ini文件格式</strong></p><p>INI文件由节、键、值组成。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">节</span><br><span class="line"></span><br><span class="line">　　[section] </span><br><span class="line"></span><br><span class="line">参数（键=值）</span><br><span class="line"></span><br><span class="line">name=value</span><br></pre></td></tr></table></figure><p>下面是一个ini文件的例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[Section1 Name] 　　</span><br><span class="line"></span><br><span class="line">KeyName1=value1 　　</span><br><span class="line"></span><br><span class="line">KeyName2=value2 　　</span><br><span class="line"></span><br><span class="line">... 　　</span><br><span class="line"></span><br><span class="line">[Section2 Name] 　　</span><br><span class="line"></span><br><span class="line">KeyName21=value21 　　</span><br><span class="line"></span><br><span class="line">KeyName22=value22 　　</span><br></pre></td></tr></table></figure><p>其中：[Section1 Name]用来表示一个段落。因为INI文件可能是项目中共用的，所以使用[Section Name]段名来区分不同用途的参数区。例如：[Section1 Name]表示传感器灵敏度参数区；[Section2 Name]表示测量通道参数区等等。</p><p>注解：使用分号表示（;）。在分号后面的文字，直到该行结尾都全部为注解。</p><p><strong>3 Qt写ini文件</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSettings&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    <span class="comment">//Qt中使用QSettings类读写ini文件</span></span><br><span class="line">    <span class="comment">//QSettings构造函数的第一个参数是ini文件的路径,第二个参数表示针对ini文件,第三个参数可以缺省</span></span><br><span class="line">    QSettings *configIniWrite = <span class="keyword">new</span> <span class="built_in">QSettings</span>(<span class="string">&quot;hahaya.ini&quot;</span>, QSettings::IniFormat);</span><br><span class="line">    <span class="comment">//向ini文件中写入内容,setValue函数的两个参数是键值对</span></span><br><span class="line">    <span class="comment">//向ini文件的第一个节写入内容,ip节下的第一个参数</span></span><br><span class="line">    configIniWrite-&gt;<span class="built_in">setValue</span>(<span class="string">&quot;/ip/first&quot;</span>, <span class="string">&quot;192.168.0.1&quot;</span>);</span><br><span class="line">    <span class="comment">//向ini文件的第一个节写入内容,ip节下的第二个参数</span></span><br><span class="line">    configIniWrite-&gt;<span class="built_in">setValue</span>(<span class="string">&quot;ip/second&quot;</span>, <span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    <span class="comment">//向ini文件的第二个节写入内容,port节下的第一个参数</span></span><br><span class="line">    configIniWrite-&gt;<span class="built_in">setValue</span>(<span class="string">&quot;port/open&quot;</span>, <span class="string">&quot;2222&quot;</span>);</span><br><span class="line">    <span class="comment">//写入完成后删除指针</span></span><br><span class="line">    <span class="keyword">delete</span> configIniWrite;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序后，打开程序目录下的hahaya.ini文件，结果如下图所示：</p><p><img src="https://bu.dusays.com/2025/03/13/67d287cd1be9a.png"></p><p> <strong>4 Qt读ini文件</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSettings&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">      QSettings *configIniRead = <span class="keyword">new</span> <span class="built_in">QSettings</span>(<span class="string">&quot;hahaya.ini&quot;</span>, QSettings::IniFormat);</span><br><span class="line">      <span class="comment">//将读取到的ini文件保存在QString中，先取值，然后通过toString()函数转换成QString类型</span></span><br><span class="line">      QString ipResult = configIniRead-&gt;<span class="built_in">value</span>(<span class="string">&quot;/ip/second&quot;</span>).<span class="built_in">toString</span>();</span><br><span class="line">      QString portResult = configIniRead-&gt;<span class="built_in">value</span>(<span class="string">&quot;/port/open&quot;</span>).<span class="built_in">toString</span>();</span><br><span class="line">      <span class="comment">//打印得到的结果</span></span><br><span class="line">      <span class="built_in">qDebug</span>() &lt;&lt; ipResult;</span><br><span class="line">      <span class="built_in">qDebug</span>() &lt;&lt; portResult;</span><br><span class="line">      <span class="comment">//读入入完成后删除指针</span></span><br><span class="line">      <span class="keyword">delete</span> configIniRead;</span><br><span class="line">      <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2025/03/13/67d287e4a3dc2.png"></p><br><br><br><p><span style="color: red; font-size: 20px;">转载自：<a href="https://www.cnblogs.com/xyf327">唯有自己强大</a>          如有侵权，在下方评论  立刻删除。</span></p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt02信号和槽</title>
      <link href="/2025/03/13/Qt02%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD/"/>
      <url>/2025/03/13/Qt02%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD/</url>
      
        <content type="html"><![CDATA[<h3 id="一、信号和槽机制分析"><a href="#一、信号和槽机制分析" class="headerlink" title="一、信号和槽机制分析"></a><font color="FF0000">一、信号和槽机制分析</font></h3><p>​<strong>信号</strong>（Signal）就是在特定情况下被发射的事件，例如PushButton 最常见的信号就是鼠标单击时发射的 clicked() 信号，一个 ComboBox 最常见的信号是选择的列表项变化时发射的 CurrentIndexChanged() 信号。</p><p>​GUI 程序设计的主要内容就是对界面上各组件的信号的响应，只需要知道什么情况下发射哪些信号，合理地去响应和处理这些信号就可以了。</p><p>​<strong>槽</strong>（Slot）就是对信号响应的函数。槽就是一个函数，与一般的C++函数是一样的，可以定义在类的任何部分（public、private 或 protected），可以具有任何参数，也可以被直接调用。槽函数与一般的函数不同的是：槽函数可以与一个信号关联，当信号被发射时，关联的槽函数被自动执行。</p><p>​信号与槽关联是用 QObject::connect() 函数实现的，其基本格式是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QObject::<span class="built_in">connect</span>(sender, <span class="built_in">SIGNAL</span>(<span class="built_in">signal</span>()), receiver, <span class="built_in">SLOT</span>(<span class="built_in">slot</span>()));</span><br><span class="line"><span class="built_in">connect</span>(发出信号的对象，发出的信号，接收信号的对象，接收到信号之后需要调用的函数（槽函数））</span><br></pre></td></tr></table></figure><p><strong>connect()函数最常用的一般形式：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(sender, <span class="built_in">signal</span>(信号）, receiver, slot（槽）);</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2025/03/13/67d27c859f78b.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建第一个按钮</span></span><br><span class="line">  QPushButton *btn=<span class="keyword">new</span> QPushButton;</span><br><span class="line">  <span class="comment">//不能用btn-&gt;show();//show是以顶层方式弹出控件</span></span><br><span class="line">  <span class="comment">//让btn在widget窗口显示</span></span><br><span class="line">  btn-&gt;<span class="built_in">setParent</span>(<span class="keyword">this</span>);<span class="comment">//this指向当前对象的指针（即widget的地址）</span></span><br><span class="line">  <span class="comment">//显示文本</span></span><br><span class="line">  btn-&gt;<span class="built_in">setText</span>(<span class="string">&quot;关闭窗口&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//用信号和槽去实现点击按钮关闭窗口</span></span><br><span class="line">  <span class="built_in">connect</span>(btn,&amp;QPushButton::clicked,<span class="keyword">this</span>,&amp;QWidget::close);</span><br></pre></td></tr></table></figure><h3 id="二、自定义信号槽"><a href="#二、自定义信号槽" class="headerlink" title="二、自定义信号槽"></a><font color="FF0000">二、自定义信号槽</font></h3><p>1、定义自定义信号</p><p>在这个的基础上，我们先设定一个需求：屌丝男发向白富美表白，发送表白信号，白富美接收信号，并回应同意。</p><p>这里面有两个对象，一个屌丝男，一个白富美，我们将使用自定义的信号和槽将他们联系起来。</p><p><img src="https://bu.dusays.com/2025/03/13/67d27ebd77f3f.png"></p><p>类名自定义为boy，选择QObject为基类是为了将此类加入qt children中，而 QObject 是最基本的类。以同样的方式创建Girl类。</p><p>2、在boy类中加入自定义信号</p><p><img src="https://bu.dusays.com/2025/03/14/67d3e97f319ca.png"></p><p>3、 在Girl类头文件和源文件添加自定义槽函数的定义和实现</p><p><img src="https://bu.dusays.com/2025/03/14/67d3ea0b48134.png"></p><p><img src="https://bu.dusays.com/2025/03/14/67d3ea110e236.png"></p><p>4、 在widget.h中的widget类中添加两个成员，一个boy对象xgg（小哥哥），girl对象xjj（小姐姐）两个指针。</p><p><img src="https://bu.dusays.com/2025/03/14/67d3ea460c19f.png"></p><p>5、 在widget.cpp中new出对象并添加连接。</p><p><img src="https://bu.dusays.com/2025/03/07/67cad87144911.png"></p><p>6、 运行程序，程序在表白函数中发送示爱信息，接收者收到信息并执行相应的槽函数。</p><p>运行结果：打印出了槽函数中的信息。实现了自定义的信号和槽函数</p><p><img src="https://bu.dusays.com/2025/03/14/67d3ea8da7844.png"></p><p>7、 总结：自定义信号和槽的区别，<strong>信号和槽都为void类型</strong>，信号只需要定义，<strong>不需要实现</strong>，而槽函数<strong>既需要定义，也需要实现</strong>，<strong>信号和槽都可以有参数也都可以重载</strong>。emit是出发信号的标志，可要可不要。</p><h3 id="三、自定义信号和槽发生重载如何解决？"><a href="#三、自定义信号和槽发生重载如何解决？" class="headerlink" title="三、自定义信号和槽发生重载如何解决？"></a><font color="FF0000">三、自定义信号和槽发生重载如何解决？</font></h3><p>自定义的信号和槽<strong>可以带参数</strong>，<strong>可以重载</strong>，但是重载（或者带参数）后如何去用connect关联呢？</p><p>首先看需求，高富帅表白成功后，他们就很有默契了。他们就要约会对不会，男的想说我们去看电影吧，女孩就很听男的话，收到信号后，就同意男孩，我们就去看电影，就是男孩说什么，女孩就同意男孩也说什么，这之间的话，就通过信号的参数来传递。</p><p>好，还是来到我们上节课的项目。</p><p>1、 在boy.h的signals下重载love函数，带一个QString参数，就是这个传过去一句话，女孩也说这句话。</p><p><img src="https://bu.dusays.com/2025/03/14/67d3eb6b3233b.png"></p><p>记住，这个信号只需要定义，不需要实现，只要知道定义了这么一个带一个参数的信号就行了。触发这个信号，还需要一个QString的参数。</p><p>2、 在girl.cpp也重载一个带参数的回应的槽函数</p><p><img src="https://bu.dusays.com/2025/03/14/67d3eafc0227e.png"></p><p><img src="https://bu.dusays.com/2025/03/14/67d3eb4298513.png"></p><p>在实现的函数，将参数输出</p><p>3、 回到widget.cpp中会发现原来写好的没问题的connect函数有错误了。</p><p><img src="https://bu.dusays.com/2025/03/07/67cadb9162646.png"></p><p><img src="https://bu.dusays.com/2025/03/14/67d3ebb51a45e.png"></p><p>编译后发现错误，重载函数有歧义错误。什么意思呢，信号和槽的连接函数中，就是一个函数名，也就是函数地址，有没有发现，我们在重载之后，就有了两个love信号，也有了两个lovetoo槽，那么这个函数指针，到底指的是哪一个呢？这就让编译器为难了。</p><p>4、 我们可以使用带参数的函数指针来指向我们所要指向的那个函数，这个就可以消除歧义。</p><p><img src="https://bu.dusays.com/2025/03/14/67d3ec0d033cf.png"></p><p>这样子就消除错误了。可以编译通过，并运行。</p><p>5、 但是我发现一个问题，这样能运行，但是就什么输出都没了，为什么呢？因为我已经把前面的连接函数注释了，我们连接的带参数的信号，而我们原来的出发信号的函数是没有带参数的，所以不会出发这个带参数的信号，信号是可以多次出发的，我们在表白的函数中出发一个带参数的信号</p><p><img src="https://bu.dusays.com/2025/03/14/67d3ec52acb19.png"></p><p>再运行</p><p><img src="https://bu.dusays.com/2025/03/14/67d3ec6b5ced4.png"></p><p>这就能看到女孩那边回应的也是同样的一句话。说明信号跑通了。</p><p>6、 总结：注意信号重载函数指针指向哪一个函数的问题，对于重载函数的信号连接，要指明到底连接的是哪一个？</p><h3 id="四、信号连接信号"><a href="#四、信号连接信号" class="headerlink" title="四、信号连接信号"></a><font color="FF0000">四、信号连接信号</font></h3><p>这部分不放代码了，自己尝试着实践。</p><ol><li>信号可以连接信号</li><li>一个信号可以连接多个槽（点击按钮，触发信号并关闭窗口）</li><li>多个信号可以连接同一个槽（比如多个按钮都可以关闭窗口）</li><li>自定义槽函数可以写成：<ol><li>类的任意成员函数</li><li>静态函数</li><li>全局函数</li><li>lambda表达式</li></ol></li></ol><p><strong>归根究底：连接的原则就是信号和槽的参数必须一一对应！！</strong></p><h3 id="五、lambad表达式"><a href="#五、lambad表达式" class="headerlink" title="五、lambad表达式"></a><font color="FF0000">五、lambad表达式</font></h3><p>表达式用于定义并创建匿名的函数对象，以简化编程工作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[函数对象参数](操作符重载函数参数)<span class="keyword">mutable</span>或exception-&gt;返回值</span><br><span class="line">&#123;</span><br><span class="line">函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>1️⃣函数对象参数</strong></p><p>[ ]，标识一个 Lambda 的开始，这部分必须存在，不能省略。函数对象参数 是传递给编译器自动生成的函数对象类的构造函数的。函数对象参数只能使 用那些到定义 Lambda 为止时 Lambda 所在作用范围内可见的局部变量（包括 Lambda 所在类的 this）。函数对象参数有以下形式：（常用的就是&#x3D; &amp; this a）</p><ul><li><strong>空</strong>。没有使用任何函数对象参数。</li><li><strong>&#x3D;</strong>。函数体内可以使用 Lambda 所在作用范围内所有可见的局部变量（包 括 Lambda 所在类的 this），并且是<strong>值传递方式</strong>（相当于编译器自动为我 们按值传递了所有局部变量）。</li><li><strong>&amp;</strong>。函数体内可以使用 Lambda 所在作用范围内所有可见的局部变量（包 括 Lambda 所在类的 this），并且是<strong>引用传递方式</strong>（相当于编译器自动为 我们按引用传递了所有局部变量）。</li><li><strong>this</strong>。函数体内可以使用 Lambda 所在类中的成员变量。</li><li><strong>a</strong>。将 a 按值进行传递。按值进行传递时，函数体内不能修改传递进来的 a 的拷贝，因为默认情况下函数是 const 的。要修改传递进来的 a 的拷贝，可以添加 mutable 修饰符。</li><li><strong>&amp;a</strong>。将 a 按引用进行传递。</li><li><strong>a, &amp;b</strong>。将 a 按值进行传递，b 按引用进行传递。</li><li><strong>&#x3D;，&amp;a, &amp;b</strong>。除 a 和 b 按引用进行传递外，其他参数都按值进行传递。</li><li><strong>&amp;, a, b</strong>。除 a 和 b 按值进行传递外，其他参数都按引用进行传递。</li></ul><p><strong>如何用lambda表达式去修改按钮的名称：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数对象参数: =</span></span><br><span class="line">[=]()&#123;</span><br><span class="line">         btn-&gt;<span class="built_in">setText</span>(<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line">     &#125;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数对象参数:a</span></span><br><span class="line">     [btn]()&#123;</span><br><span class="line">          btn-&gt;<span class="built_in">setText</span>(<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line">   <span class="comment">//由于函数对象参数为btn，因此只能对btn操作，引入btn1会报错</span></span><br><span class="line">          <span class="comment">//btn1-&gt;setText(&quot;bbbb&quot;);</span></span><br><span class="line">      &#125;();</span><br></pre></td></tr></table></figure><p><font color="FF0000"><strong>注意：</strong></font>不加( )只是对lambad表达式的声明，加上( )才是对它的调用。（由于btn在创建的时候lambad作用范围内是不可见的，因此需要用&#x3D;让lambad表达式认识btn这个局部变量）</p><p><strong>2️⃣操作符重载函数参数</strong></p><p>标识重载的()操作符的参数，没有参数时，这部分可以省略。参数可以通过 按值（如：(a,b)）和按引用（如：(&amp;a,&amp;b)）两种方式进行传递</p><p><strong>3️⃣可修改标示符</strong></p><p>mutable 声明，这部分可以省略。按值传递函数对象参数时，加上 mutable 修饰符后，可以修改按值传递进来的拷贝（注意是能修改拷贝，而不是值本身）</p><p><strong>4️⃣错误抛出标示符</strong></p><p>exception 声明，这部分也可以省略。exception 声明用于指定函数抛出的异常，如抛出整数类型的异常，可以使用 throw(int）</p><p><strong>5️⃣函数返回值</strong></p><p>-&gt; 返回值类型，标识函数返回值的类型，当返回值为 void，或者函数体中只有一处 return 的地方（此时编译器可以自动推断出返回值类型）时，这部分可以省略。</p><p><strong>如</strong>：int一个ret去接收lanbda表达式返回的结果（注意：要用-&gt;标识返回值的类型）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ret=[]()-&gt;<span class="type">int</span>&#123;<span class="keyword">return</span> <span class="number">1000</span>;&#125;();</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;ret=:&quot;</span>&lt;&lt;ret;　　</span><br></pre></td></tr></table></figure><p><strong>6️⃣函数体</strong></p><p>{ }，标识函数的实现，这部分不能省略，但函数体可以为空</p><p><strong>💛💛💛槽函数也可以使用 Lambda 表达式的方式进行处理：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//创建两个按钮</span></span><br><span class="line"> QPushButton *myBtn = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="keyword">this</span>);</span><br><span class="line"> QPushButton *myBtn1 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="keyword">this</span>);</span><br><span class="line"> <span class="comment">//移动第二个按钮</span></span><br><span class="line"> myBtn1-&gt;<span class="built_in">move</span>(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line"> <span class="type">int</span> m =<span class="number">10</span>;</span><br><span class="line"> <span class="comment">//用槽函数（lambda表达式）改变m的copy值</span></span><br><span class="line"> <span class="built_in">connect</span>(myBtn,&amp;QPushButton::clicked,<span class="keyword">this</span>,[m]()<span class="keyword">mutable</span>&#123;m=<span class="number">100</span> + <span class="number">10</span>;<span class="built_in">qDebug</span>() &lt;&lt; m;&#125;);</span><br><span class="line"> <span class="built_in">connect</span>(myBtn1,&amp;QPushButton::clicked,<span class="keyword">this</span>,[=]() &#123;<span class="built_in">qDebug</span>() &lt;&lt; m;&#125;);</span><br><span class="line"> <span class="built_in">qDebug</span>() &lt;&lt; m;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于第一个connect函数来说：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(myBtn,&amp;QPushButton::clicked,<span class="keyword">this</span>,[m]()<span class="keyword">mutable</span>&#123;m=<span class="number">100</span><span class="number">+10</span>;<span class="built_in">qDebug</span>()&lt;&lt;m;&#125;);</span><br></pre></td></tr></table></figure><p>当函数对象参数为m时候，若要修改该值传递进来的拷贝，需要加上mutable 关键字。（注意只能修改拷贝，而不是值本身）</p><p><strong>一般来说，lambda表达式中很少去加关键字的，除非你有什么特殊的需求。</strong></p><p><strong>总的来说：</strong></p><ul><li>用lambda写槽函数可以在lambda表达式的函数体内写多个函数。（如上面m&#x3D;100+10;和qDebug()&lt;&lt;m;)</li><li>lambda常用表达式：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[=]()&#123;&#125;</span><br></pre></td></tr></table></figure><p>对于嵌套窗口，其坐标是相对于父窗口来说的。</p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt01对象树和窗口坐标体系</title>
      <link href="/2025/03/13/Qt01%E5%AF%B9%E8%B1%A1%E6%A0%91%E5%92%8C%E7%AA%97%E5%8F%A3%E5%9D%90%E6%A0%87%E4%BD%93%E7%B3%BB/"/>
      <url>/2025/03/13/Qt01%E5%AF%B9%E8%B1%A1%E6%A0%91%E5%92%8C%E7%AA%97%E5%8F%A3%E5%9D%90%E6%A0%87%E4%BD%93%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<h3 id="一、QT基本框架"><a href="#一、QT基本框架" class="headerlink" title="一、QT基本框架"></a><font color = "FF0000">一、QT基本框架</font></h3><p>创建一个项目，先看下main.cpp这个文件</p><p><img src="https://bu.dusays.com/2025/03/13/67d2403c08fc9.png"></p><p><strong><font color = "FF0000">注意：</font></strong></p><ol><li>每个Qt程序有且只能有一个QApplication对象，没有会报错。</li><li>Qt里面的头文件和类名是一致的，知道头文件就知道类名，反之亦然</li><li>Qt头文件是没有.h的，基本都是以大写的Q开头</li></ol><p>根据以上的分析，我们可以得出Qt的程序框架代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span>      </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;  </span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">       在这里写你的代码</span></span><br><span class="line"><span class="comment">     */</span>     </span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>widget.h和widget.cpp分析</strong></li></ul><p>打开头文件里面的widget.h,和sources里面的widget.app，可以看到以下代码：</p><p><img src="https://bu.dusays.com/2025/03/13/67d242912f352.png"></p><p><img src="https://bu.dusays.com/2025/03/13/67d242a1e99ab.png"></p><p>最上面的<strong>MyfirstQt.pro</strong>,是管理项目的文件，用来存储项目设置。</p><p>后缀为“.pro”的文件是项目的管理文件，文件名就是项目的名称，如本项目中的 MyfirstQt.pro。（类似与VS工程的.sln文件）</p><p><strong>💛💛实例（用代码创建一个button）：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;widget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_widget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QPushButton&gt;</span><span class="comment">//按钮控件的头文件</span></span></span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::Widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建第一个按钮</span></span><br><span class="line">    QPushButton *btn=<span class="keyword">new</span> QPushButton;</span><br><span class="line">    <span class="comment">//不能用btn-&gt;show();//show是以顶层方式弹出控件</span></span><br><span class="line">    <span class="comment">//让btn在widget窗口显示</span></span><br><span class="line">    btn-&gt;<span class="built_in">setParent</span>(<span class="keyword">this</span>);<span class="comment">//this指向当前对象的指针（即widget的地址）</span></span><br><span class="line">    <span class="comment">//显示文本</span></span><br><span class="line">    btn-&gt;<span class="built_in">setText</span>(<span class="string">&quot;第一个按钮&quot;</span>);</span><br><span class="line">    <span class="comment">//创建第二个按钮</span></span><br><span class="line">    <span class="comment">//注意：这种方法是按照按钮的大小创建窗口</span></span><br><span class="line">    QPushButton *btn2=<span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;第二个按钮&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//移动btn2的位置（由于创建的两个按钮位置重叠了）</span></span><br><span class="line">    btn2-&gt;<span class="built_in">move</span>(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">    <span class="comment">//因此需要重置窗口大小</span></span><br><span class="line">    <span class="built_in">resize</span>(<span class="number">600</span>,<span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置窗口标题</span></span><br><span class="line">    <span class="built_in">setWindowTitle</span>(<span class="string">&quot;唯有自己强大&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、对象树"><a href="#二、对象树" class="headerlink" title="二、对象树"></a><font color = "FF0000">二、对象树</font></h3><p><strong>💚💚什么是对象树？</strong></p><p>我们常常听到 QObject 会用对象树来组织管理自己，那什么是对象树？</p><p>这个概念非常好理解。因为 QObject 类就有一个私有变量 QList&lt;QObject *&gt;，专门存储这个类的子孙后代们。比如创建一个 QObject 对象并指定父对象时，就会把自己加入到父对象的 childre() 列表中，也就是 QList&lt;QObject *&gt; 变量中。</p><p> 父对象析构的时候，这个列表中的所有对象也会被析构。<strong>（注意，这 里的父对象并不是继承意义上的父类！）</strong></p><p>举个例子，有一个窗口 Window，里面有 Label标签、TextEdit文本输入框、Button按钮这三个元素，并且都设置 Window 为它们的父对象。这时候我做了一个关闭窗口的操作，作为程序员的你是不是自然想到将所有和窗口相关的对象析构啊？古老的办法就是一个个手动 delete 呗。是不是很麻烦？Qt 运用对象树模式，当父对象被析构时，子对象自动就 delete 掉了，不用再写一大堆的代码了。</p><p><strong>QWidget 是能够在屏幕上显示的一切组件的父类（QWidget 继承自 QObject，因此也继承了这种对象树关系。）</strong></p><p><strong>💛💛注意构建&#x2F;析构 QObject 的顺序问题</strong></p><p>正常情况下，最后被创建出来的会先被析构掉。就好比我有一个大桌子，上面先摆放一个盘子，再摆放一个碗。当我要把桌子撤掉的时候，会先撤掉碗，再撤掉盘子，最后撤掉桌子。</p><p>用代码演示一下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     QWidget window;</span><br><span class="line">     <span class="function">QPushButton <span class="title">quit</span><span class="params">(<span class="string">&quot;Quit&quot;</span>, &amp;window)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后创建的 quit 对象指定了 window 为其父对象。那么关闭程序时，会先调用它的析构函数，然后调用 window 的析构函数。</p><p><strong><font color="FF0000">这就牵扯到一个特殊情况：</font></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QPushButton <span class="title">quit</span><span class="params">(<span class="string">&quot;Quit&quot;</span>)</span></span>;</span><br><span class="line">    QWidget window;</span><br><span class="line"> </span><br><span class="line">    quit.<span class="built_in">setParent</span>(&amp;window);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果反过来，由于 window 后创建，程序关闭时先调用 window 的析构函数（此时 quit 被第一次析构）。接着调用 quit 的析构函数（此时 quit 被第二次析构），这时由于被两次析构，所以出问题了。</p><p>这种特殊情况在编程中很隐蔽，不容易发现。因为编译的时候不会报错，只有运行时才会产生问题。</p><p><strong>解决办法如下：</strong></p><ol><li><p><strong>栈对象的析构顺序</strong><br> 两个栈对象 <code>window</code>（父）和 <code>quit</code>（子）会在 <code>main</code> 函数结束时按创建<strong>相反的顺序</strong>析构：</p><ul><li>先析构 <code>window</code>（后创建）</li><li>再析构 <code>quit</code>（先创建）</li></ul></li><li><p><strong>Qt 的父子对象机制</strong><br> 当父对象（<code>window</code>）被销毁时，Qt 会自动递归销毁其子对象（<code>quit</code>）。由于 <code>window</code> 是栈对象，其析构过程会<strong>触发 <code>delete &amp;quit</code></strong>，但 <code>quit</code> 同样是个栈对象（未通过 <code>new</code> 在堆上分配）。</p></li><li><p><strong>双重释放错误</strong></p><ul><li>第一次析构（错误）：通过 <code>window</code> 销毁子对象时，对栈地址 <code>&amp;quit</code> 调用 <code>delete</code>，本质是对非堆内存进行释放。</li><li>第二次析构（正常）：<code>quit</code> 离开作用域时，触发栈对象的自然析构，再次调用析构函数。</li></ul><p>❌ 这将引发<strong>双重释放（double free）或内存访问冲突</strong>，导致程序崩溃。</p></li></ol><p>我们最好从开始就养成良好习惯，在 Qt 中，尽量在构造的时候就指定 parent 对象，并且大胆在堆上创建。</p><h3 id="三、Qt窗口坐标体系"><a href="#三、Qt窗口坐标体系" class="headerlink" title="三、Qt窗口坐标体系"></a><font color = "FF0000">三、Qt窗口坐标体系</font></h3><p>Qt的窗口坐标系以左上角为原点，X 向右增加，Y 向下增加。</p><p><img src="https://bu.dusays.com/2025/03/13/67d277561fcbf.png"></p><p>对于嵌套窗口，其坐标是相对于父窗口来说的。</p><br><br><br><p><span style="color: red; font-size: 20px;">转载自：<a href="https://www.cnblogs.com/xyf327">唯有自己强大</a>          如有侵权，在下方评论  立刻删除。</span></p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多模态融合和跨模态对齐</title>
      <link href="/2025/03/12/%E5%A4%9A%E6%A8%A1%E6%80%81%E8%9E%8D%E5%90%88%E5%92%8C%E8%B7%A8%E6%A8%A1%E6%80%81%E5%AF%B9%E9%BD%90/"/>
      <url>/2025/03/12/%E5%A4%9A%E6%A8%A1%E6%80%81%E8%9E%8D%E5%90%88%E5%92%8C%E8%B7%A8%E6%A8%A1%E6%80%81%E5%AF%B9%E9%BD%90/</url>
      
        <content type="html"><![CDATA[<p>多模态学习（Multimodal Learning）是一种通过整合多种数据模态（如文本、图像、音频、视频等）来提升模型对复杂信息的理解能力的技术。其核心目标是利用不同模态的互补性与冗余性，突破单一模态的信息局限，模拟人类多感官协同认知的能力。</p><p>多模态融合和跨模态对齐是多模态学习的两个核心方面。多模态融合通过整合不同模态的数据来提高模型的感知和理解能力；而跨模态对齐则确保不同模态数据之间的准确对应，为融合提供可靠的基础。</p><p><img src="https://bu.dusays.com/2025/03/12/67d13c8eeb659.png"></p><h3 id="什么是多模态融合？"><a href="#什么是多模态融合？" class="headerlink" title="什么是多模态融合？"></a><p align="center">什么是多模态融合？</p></h3><p><strong>模态融合能够充分利用各模态之间的互补优势，将来自不同模态的信息整合成一个稳定且全面的多模态表征。</strong></p><p><strong>表征学习通过从原始数据中自动提取各模态有效特征，生成稳定全面的多模态表征。</strong></p><p><strong>表征学习（Representation Learning） ≈ 向量化（Embedding）</strong></p><p><strong>从数据处理的层次角度来划分，多模态融合可分为数据级融合、特征级融合和目标级融合。</strong></p><p><img src="https://bu.dusays.com/2025/03/12/67d13f78705ba.png"></p><h4 id="一、数据级融合（Data-Level-Fusion）："><a href="#一、数据级融合（Data-Level-Fusion）：" class="headerlink" title="一、数据级融合（Data-Level Fusion）："></a><strong>一、数据级融合（Data-Level Fusion）</strong>：</h4><p><strong>数据级融合是在预处理阶段将不同模态的原始数据直接合并，适用于高度相关和互补的数据场景。</strong></p><h4 id="二、特征级融合（Feature-Level-Fusion）："><a href="#二、特征级融合（Feature-Level-Fusion）：" class="headerlink" title="二、特征级融合（Feature-Level Fusion）："></a><strong>二、特征级融合（Feature-Level Fusion）</strong>：</h4><p><strong>特征级融合是在特征提取之后、决策之前进行的融合。不同模态的数据首先被分别处理，提取出各自的特征表示，然后将这些特征表示在某一特征层上进行融合。广泛应用于图像分类、语音识别、情感分析等多模态任务中。</strong></p><h4 id="三、目标级融合（Decision-Level-Fusion）："><a href="#三、目标级融合（Decision-Level-Fusion）：" class="headerlink" title="三、目标级融合（Decision-Level Fusion）："></a><strong>三、目标级融合（Decision-Level Fusion）：</strong></h4><p><strong>目标级融合是在各单模态模型决策后将预测结果进行整合以得出最终决策,，适用于多模型预测结果综合的场景，如多传感器数据融合、多专家意见综合等</strong></p><p><img src="https://bu.dusays.com/2025/03/12/67d142b18c030.png"></p><h3 id="什么是跨模态对齐"><a href="#什么是跨模态对齐" class="headerlink" title="什么是跨模态对齐?"></a><p align = "center">什么是跨模态对齐?</p></h3><p>​<strong>跨模态对齐是指利用各种技术手段，使不同模态的数据（例如图像、文本、音频等）在特征、语义或表示层面上能够达到匹配与对应。</strong></p><p><strong>跨模态对齐主要分为两大类：显示对齐和隐式对齐。</strong></p><p><img src="https://bu.dusays.com/2025/03/12/67d143d0e4778.png"></p><p><strong>什么是显示对齐？           -&gt;直接建立不同模态之间的对应关系，包括无监督对齐和监督对齐。</strong></p><p><strong>无监督对齐利用数据自身特性自动发现模态间对应关系，如CCA和自编码器；监督对齐则利用标签信息指导对齐，如多模态嵌入和多任务学习模型。</strong></p><p><strong>什么是隐式对齐（Implicit Alignment）？          -&gt;不直接建立对应关系，而是通过模型内部机制隐式地实现跨模态的对齐。这包括注意力对齐和语义对齐。</strong></p><h4 id="一、注意力对齐"><a href="#一、注意力对齐" class="headerlink" title="一、注意力对齐"></a><strong>一、注意力对齐</strong></h4><p><strong>通过注意力机制动态地生成不同模态之间的权重向量，实现跨模态信息的加权融合和对齐。</strong></p><ul><li><strong>Transformer模型：在跨模态任务中（如图像描述生成），利用自注意力机制和编码器-解码器结构，自动学习图像和文本之间的注意力分布，实现隐式对齐。</strong></li><li><strong>BERT-based模型：在问答系统或文本-图像检索中，结合BERT的预训练表示和注意力机制，隐式地对齐文本查询和图像内容。</strong></li></ul><h4 id="二、语义对齐"><a href="#二、语义对齐" class="headerlink" title="二、语义对齐"></a><strong>二、语义对齐</strong></h4><p><strong>在语义层面上实现不同模态之间的对齐，需要深入理解数据的潜在语义联系。</strong></p><ul><li><strong>图神经网络（GNN）：在构建图像和文本之间的语义图时，利用GNN学习节点（模态数据）之间的语义关系，实现隐式的语义对齐。</strong></li><li><strong>预训练语言模型与视觉模型结合：如CLIP（Contrastive Language-Image Pre-training），通过对比学习在大量图像-文本对上训练，使模型学习到图像和文本在语义层面上的对应关系，实现高效的隐式语义对齐。</strong></li></ul><p><img src="https://bu.dusays.com/2025/03/12/67d1460e59413.png"></p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科研记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt几个面试问题</title>
      <link href="/2025/03/07/Qt%E5%87%A0%E4%B8%AA%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/"/>
      <url>/2025/03/07/Qt%E5%87%A0%E4%B8%AA%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h4 id="QT多线程"><a href="#QT多线程" class="headerlink" title="QT多线程"></a>QT多线程</h4><h4 id="QML"><a href="#QML" class="headerlink" title="QML"></a>QML</h4><p><strong>QML（Qt Meta-Object Language）</strong> 是 <strong>Qt框架</strong> 中用于构建用户界面（UI）的声明式编程语言。它专注于界面设计与用户交互，与C++后端逻辑结合，适用于开发跨平台、动态且现代化的应用程序（如桌面、移动及嵌入式应用）。以下是其核心特性与作用：</p><ul><li>ECMAScript</li><li>Qt 对象系统</li><li>Qt Quick 标准库</li></ul><p>用于定义和创建动态可视化界面</p><p>Qt Quick 是一种基于 Qt 的用户界面设计技术。它允许开发人员使用 QML（Qt Meta-Object Language）语言和 JavaScript 以声明式的方式创建动态的、高效的、流畅的用户界面。Qt Quick 技术不同于传统的基于部件（widget-based）的用户界面设计，其设计哲学是将界面的各个元素抽象出来，然后通过组合这些元素来实现各种不同的界面和交互效果。</p><h4 id="多线程的实现：信号和槽"><a href="#多线程的实现：信号和槽" class="headerlink" title="多线程的实现：信号和槽"></a>多线程的实现：信号和槽</h4><p>api函数   成员函数、<strong>2.2 信号槽</strong>  <strong>2.3静态函数</strong></p><p><strong>派生QThread类对象的方法（重写Run函数）</strong></p><p>启动事件循环：当一个程序调用 exec()（3456例如 QApplication::exec()）后，当前线程会进入一个阻塞状态，并开始无限循环地监听和分发事件（如鼠标点击、键盘输入、定时器触达、网络响应等）。</p><p><strong>使用信号与槽方式来实现多线程</strong></p><p>种方法存在一个局限性，只有一个run()函数能够在线程中去运行，但是当有多个函数在同一个线程中运行时，就没办法了，至少实现起来很麻烦</p><p>从 QObject 派生，在这个类中添加一个公共的成员函数(working)，函数体就是我们要子线程中执行的业务逻辑</p><ul><li>在主线程中创建一个 QThread 对象，这就是子线程的对象</li><li>在主线程中创建工作的类对象（千万不要指定给创建的对象指定父对象）</li><li>将 MyWork 对象移动到创建的子线程对象中，需要调用 QObject 类提供的 moveToThread() 方法</li><li>启动子线程，调用 start(), 这时候线程启动了，但是移动到线程中的对象并没有工作</li><li>调用 MyWork 类对象的工作函数，让这个函数开始执行，这时候是在移动到的那个子线程中运行的</li></ul><h3 id="共享内存-队列"><a href="#共享内存-队列" class="headerlink" title="共享内存  队列"></a>共享内存  队列</h3><p>在Qt中，<strong>共享内存（Shared Memory）</strong> 是一种允许不同进程访问同一块内存区域的机制。这是实现进程间通信（IPC）的一种高效方式，尤其适用于需要<strong>高频数据交换</strong>的场景（如实时数据传输）。Qt提供了 <strong><code>QSharedMemory</code></strong> 类来简化共享内存的操作。Qt提供了 <strong><code>QSharedMemory</code></strong> 类来简化共享内存的操作</p><h3 id="QT-事件过滤器"><a href="#QT-事件过滤器" class="headerlink" title="QT 事件过滤器"></a>QT 事件过滤器</h3><p>在Qt中，<strong>事件过滤器（Event Filter）</strong> 是一种强大的机制，允许一个对象监视或拦截另一个对象的事件处理流程。通过事件过滤器，可以在事件到达目标对象前进行预处理或完全拦截，这在需要自定义事件行为或跨组件交互时非常实用。</p><p>继承 <code>QObject</code> 并重写 <code>eventFilter()</code> 方法。该方法在目标对象的事件被处理前调用。</p><h4 id="安装过滤器到目标对象"><a href="#安装过滤器到目标对象" class="headerlink" title="安装过滤器到目标对象"></a><strong>安装过滤器到目标对象</strong></h4><p>目标对象通过 <code>installEventFilter()</code> 注册过滤器，使其事件被监控。</p><h3 id="QT定时器"><a href="#QT定时器" class="headerlink" title="QT定时器"></a>QT定时器</h3><p>Qt中有两种方法来使用定时器，一种是定时器事件，另一种是使用信号和槽。</p><ul><li>利用对void timerEvent(QTimerEvent* e)事件的重写。</li><li>启动定时器 int QObject::startTimer ( int interval ) ;</li></ul><p>开启一个定时器，返回值为int类型。他的参数interval是毫秒级别。当开启成功后会返回这个定时器的ID, 并且每隔interval 时间后会进入timerEvent 函数。直到定时器被杀死（killTimer）</p><ul><li>timerEvent的返回值是定时器的唯一标识。可以和e-&gt;timerId比较</li><li>void killTimer(int id); &#x2F;&#x2F;停止 ID 为 id 的计时器，ID 由 startTimer()函数返回</li></ul><p><strong>方式：</strong></p><ol><li>利用定时器类QTimer</li><li>创建定时器对象 QTimer *timer&#x3D;new QTimer(this)</li><li>启动定时器timer-&gt;start( 500） &#x2F;&#x2F;参数：每隔n毫秒发送一个信号（timeout）</li><li>用connect连接信号和槽函数（自定义槽）</li><li>暂停 timer-&gt;stop</li></ol><p>**实例：**启动label 每隔0.5秒计时</p><h3 id="QT和MFC底层机制"><a href="#QT和MFC底层机制" class="headerlink" title="QT和MFC底层机制"></a>QT和MFC底层机制</h3><p>QT</p><p><strong>事件驱动模型</strong>：</p><ul><li><p><strong>事件循环</strong>：每个 Qt 应用程序有一个全局事件队列（<code>QEventLoop</code>），管理用户输入、定时器、网络事件等。</p></li><li><p>事件分发</p><p>：</p><ul><li>Qt 将操作系统的原生事件（如鼠标点击、按键）封装为 <code>QEvent</code> 对象（如 <code>QMouseEvent</code>）。</li><li>通过 <code>QObject::event()</code> 和 <code>QWidget::eventFilter()</code> 分发事件。</li></ul></li><li><p>信号槽机制</p><p>：</p><ul><li>通过元对象系统（Meta-Object System，由 <code>moc</code> 生成）实现松耦合通信。</li><li>类型安全，支持跨线程通信。</li></ul></li></ul><p>MFC</p><p>核心：基于 Win32 API，依赖 Windows 的 HWND（窗口句柄）和消息队列。<br>消息传递：<br>Windows 消息（如 WM_PAINT、WM_CLOSE）通过 消息循环（PeekMessage&#x2F;GetMessage）分发给窗口过程（WndProc）。<br>MFC 封装了消息处理流程，通过 消息映射宏（如 ON_WM_PAINT()）将消息与成员函数绑定。</p><p><strong>QJSON</strong></p><p>Json 是一种轻量级的数据交换格式。它使得人们很容易进行阅读和编写。</p><p>QJson 是 Json的一种扩展，也就是一种简单的数据结构。</p><p>JSON 基于两种结构：1️⃣名称：值       2️⃣值的有序列表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QJsonDocument&gt;</span>  <span class="comment">// 读取和写入Json类</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QJsonValue&gt;</span>   <span class="comment">// Json值有下面几种形式：空、布尔值、浮点数、字符串、数组、对象（可以是另一个Json）、未定义</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QJsonObject&gt;</span><span class="comment">// JSON对象是键值对的列表中，其中键是唯一的字符串，值由QJsonValue表示。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QJsonArray&gt;</span>  <span class="comment">// JSON 数组是一个值列表。可通过从数组中插入和删除QJsonValue 来操作列表。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QJsonParseError&gt;</span> <span class="comment">// 报告Json解析过程中的错误。</span></span></span><br></pre></td></tr></table></figure><h4 id="QT图表功能"><a href="#QT图表功能" class="headerlink" title="QT图表功能"></a>QT图表功能</h4><p>Qt Charts是基于Qt Graphics View实现的一个图表的组件，可以用来在QT GUI程序中添加现在风格的、可交互的、以数据为中心的图表，可以用作QWidget或者 QGraphicsWidget，也可用在QML中。支持的图标类型有：折线图跟曲线图、面积图、饼图、柱状图等。</p><h4 id="QT-QSS"><a href="#QT-QSS" class="headerlink" title="QT QSS"></a>QT QSS</h4><p>​    QT样式表，用来实现对控件外观的自定义。</p><h4 id="QT-信号只声明没有定义"><a href="#QT-信号只声明没有定义" class="headerlink" title="QT  信号只声明没有定义"></a>QT  信号只声明没有定义</h4><p>​<strong>在 Qt 中，自定义信号（Signal）只需要在头文件中声明，无需手动在源文件中实现（定义）。</strong> 这是因为 Qt 的元对象系统（Meta-Object System，由 <code>Q_OBJECT</code> 宏和元对象编译器 <code>moc</code> 实现）<strong>会自动生成信号的底层代码</strong>，负责信号的触发与槽的连接机制。</p><p><strong>Qt元对象系统MOC的责任</strong></p><p>信号的“实现”由 moc 完成<br>信号本质是一个“标记”，当你在代码中使用 <code>emit mySignal();</code> 时：<code>emit</code> 关键字向 moc 生成的代码下发触发指令。moc 负责管理信号与槽的连接关系，并将参数传递给槽函数。</p><p><strong>信号的本质</strong>：信号是接口而非功能函数   信号的目的是触发事件通知，而非具体实现逻辑。用户只需要声明信号的格式（名称、参数类型），告知元对象系统如何传递数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">signals:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">healthChanged</span><span class="params">(<span class="type">int</span> newHealth)</span></span>;  <span class="comment">// 声明信号</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">positionUpdated</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span></span>; <span class="comment">// 血量</span></span><br></pre></td></tr></table></figure><p><strong>发射信号</strong> <code>emit</code>：在需要的位置调用<code>emit</code>，时间的逻辑处理由接收该信号的槽函数实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Aladdin::takeDamage</span><span class="params">(<span class="type">int</span> damage)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_health -= damage;</span><br><span class="line">    <span class="function">emit <span class="title">healthChanged</span><span class="params">(m_health)</span></span>; <span class="comment">// 触发信号，通知外部当前的血量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比槽函数（需要手动实现）</p><h4 id="信号为何必须是-void-类型？"><a href="#信号为何必须是-void-类型？" class="headerlink" title="信号为何必须是 void 类型？"></a>信号为何必须是 <code>void</code> 类型？</h4><p>信号的作用是触发事件通知，而不是返回值。若想传递数据，应通过参数传递，而非返回值。</p><h4 id="信号是否可重载？"><a href="#信号是否可重载？" class="headerlink" title="信号是否可重载？"></a><strong>信号是否可重载？</strong></h4><p>是的，允许通过参数类型或数量重载信号。连接时需使用 <code>QOverload</code> 或 <code>static_cast</code> 明确指定重载版本。</p><h4 id="为何有时无法触发信号？"><a href="#为何有时无法触发信号？" class="headerlink" title="为何有时无法触发信号？"></a><strong>为何有时无法触发信号？</strong></h4><ul><li>未正确连接信号与槽（<code>connect</code> 错误）。</li><li>未添加 <code>Q_OBJECT</code> 宏或未重新生成 moc。</li><li>发射信号的对象被提前销毁。</li></ul><h4 id="QT自定义控件的使用流程"><a href="#QT自定义控件的使用流程" class="headerlink" title="QT自定义控件的使用流程"></a>QT自定义控件的使用流程</h4><p>备注下</p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试问题 </tag>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用满血版deepseek</title>
      <link href="/2025/02/18/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%BB%A1%E8%A1%80%E7%89%88deepseek/"/>
      <url>/2025/02/18/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%BB%A1%E8%A1%80%E7%89%88deepseek/</url>
      
        <content type="html"><![CDATA[<p>本教程是在硅基流动获取API，并在Cherry Studio上面使用</p><h3 id="一、注册硅基流动"><a href="#一、注册硅基流动" class="headerlink" title="一、注册硅基流动"></a>一、注册硅基流动</h3><p>SiliconCloud 基于华为云昇腾云服务，首发推出了 DeepSeek R1 &amp; V3 模型推理服务。注册即赠送 14 元余额，邀请注册还可再获得 14 元余额（2000 万 Tokens）。</p><ul><li><strong>邀请链接：</strong> <a href="https://cloud.siliconflow.cn/i/ePZNK3HT">硅基流动统一登录</a></li><li><strong>邀请码：</strong> ePZNK3HT</li></ul><p>注册完成后，可在模型广场上找到 deepseek-ai&#x2F;DeepSeek-R1 模型，显示 671B 的满血版。</p><p><img src="https://bu.dusays.com/2025/02/18/67b3659255843.png"></p><p>但这个页面不必理会，点击左侧API密钥，如下图所示，点击新建API密钥（注意保护隐私），密钥描述随便填。</p><p><img src="https://bu.dusays.com/2025/02/18/67b366658f7b3.png"></p><p>建完API密钥后就来到第二步了。</p><h3 id="二、下载Cherry-Studio"><a href="#二、下载Cherry-Studio" class="headerlink" title="二、下载Cherry Studio"></a>二、下载Cherry Studio</h3><p>用户可以选择需要的软件来调用接口。推荐使用「CherryStudio」软件，支持 Windows、Mac 和 Linux 客户端。</p><p><strong>Cherry Studio 官网下载链接：</strong> <a href="https://docs.cherry-ai.com/cherrystudio/download?login=from_csdn">https://docs.cherry-ai.com/cherrystudio/download?login=from_csdn</a></p><p>安装完成之后，运行「CherryStudio」软件，点击左下角的设置按钮，选择 <strong>硅基流动</strong>，复制第一步创建的API密钥，输入刚刚复制的密钥粘贴进去即可。点击检查，软件将会自动对密钥进行验证，通过即可进行使用。</p><p><img src="https://bu.dusays.com/2025/02/18/67b3677c3ff7b.png"></p><p>通过下面的管理功能，可以添加硅基流动平台所有的模型，需要什么点击添加即可。</p><p><img src="https://bu.dusays.com/2025/02/18/67b368c449509.png"></p><p>点击助手即可进入对话页面，上方点击即可选择对话的模型</p><p><img src="https://bu.dusays.com/2025/02/18/67b3690603033.png"></p><p>以上是完整的使用教程！！！如果可以的话，请使用我的邀请码：ePZNK3HT</p>]]></content>
      
      
      <categories>
          
          <category> 分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
